[
["index.html", "Interactive web-based data visualization with R, plotly, and shiny Welcome", " Interactive web-based data visualization with R, plotly, and shiny Carson Sievert 2019-03-09 Welcome This book teaches you how to create interactive and dynamic web graphics using the R packages plotly and shiny. The majority of the book uses R code examples to demonstrate features and functionality available in plotly.1 Along the way, you‚Äôll also learn about other R tools (e.g., tidyverse packages) that help make plotly such a productive tool for both exploratory analysis and presentation of your data. In addition to data visualization principles, you‚Äôll also learn some effective strategies for graphical exploration of high-dimensional data. By mastering these concepts and tools, you‚Äôll impress your colleagues with your ability to generate more graphical insights faster via highly interactive graphics that you can share over email, export to pdf, and more. An online version of this book, available at https://plotly-book.cpsievert.me, is free to use and is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 United States License. Both the print and online versions of the book are written in rmarkdown with bookdown and those source files are available at https://github.com/cpsievert/plotly_book. The online version will continue to evolve in between reprints of the physical book. All the software tools in this book are 100% free and open source. Many people think the R package plotly is not free and open-source, but both the R package and the JavaScript library it depends on (plotly.js) are MIT-licensed.‚Ü© "],
["introduction.html", "1 Introduction 1.1 What you will learn 1.2 How this book is organized 1.3 What you won‚Äôt learn 1.4 Prerequisites 1.5 Run code examples 1.6 Getting help and learning more 1.7 Acknowledgements 1.8 Colophon", " 1 Introduction 1.1 What you will learn This book provides the foundation necessary to create highly interactive and scalable 1.2 How this book is organized Chapter 1 designed to help ggplot2 users transfer knowledge to plot_ly(). 1.3 What you won‚Äôt learn 1.3.1 Web technologies Although this book is fundamentally about creating web graphics, it does not aim to teach you web technologies (e.g., HTML, SVG, CSS, JavaScript, etc). It‚Äôs true that becoming a competent web developer gives you the power and freedom to create more types of visuals, but the opporunities costs involved with learning all the relevant tools is not worth it for most data analysts. Moreover, most web programming tools are not well-suited for the exploratory phase of a data science workflow where iteration between data visualization, transformation, and modeling is a necessary task that often impedes hypothesis generation and sense-making (more on this in section 2). As a result, even if you do become web developer, you‚Äôll find the cognitive burden required to create a web graphic will hamper your ability to derive new insights from data. 1.3.2 d3js The JavaScript library D3 is a great tool for data visualization assuming you‚Äôre familiar with web technologies and are primarily interested in expository (not exploratory) visualization. There are already lots of great resources for learning D3, including the numerous books (Murray 2013); (Murray 2017). 1.3.3 ggplot2 The book does contain some ggplot2 code examples (which are then converted to plotly via ggplotly()), but it‚Äôs not designed to teach you ggplot2. For those looking to learn ggplot2, I recommend using the learning materials listed at https://ggplot2.tidyverse.org. 1.3.4 Graphical data analysis How to perform data analysis via graphics (carefully, correctly, and creatively) is a large topic unto itself. Although this book does have hints and examples of graphical data analysis, it does not aim to provide a comprehensive foundation. For a nice resource on graphical data analysis topic, see (Unwin 2015). 1.3.5 Data visualization best practices Encoding information in a graphic (concisely and effectively) is a large topic unto itself. Although this book does have some ramblings related to best practices in data visualization, it does not aim to provide a comprehensive foundation. For some approachable and fun resources on the topic, see (Tufte 2001a); (Yau 2011); (Healey 2018); (Wilke 2018). 1.4 Prerequisites For those new to R and/or data visualization, R for Data Science provides a nice foundation for understanding concepts in this book (Wickham and Grolemund 2018). In particular, the chapter on data visualization is essentially assumed knowledge during some portions of this book. 1.5 Run code examples While reading this book, it can be helpful to run the code examples. A computing environment with all the required software to run these examples is available at http://bit.ly/plotly-book-cloud. This RStudio Cloud project provides a computing environment that you can use to follow along with the book. Most examples produce an interactive graphic, but the interactives themselves are not always included. Sometimes, instead of the interactive, a video is included to demonstrate the interactive capabilities. In those cases, you can copy/paste code in RStudio Cloud to get at the interactive plot. if (!require(remotes)) install.packages(&quot;remotes&quot;) remotes::install_github(&quot;cpsievert/plotly_book&quot;) 1.6 Getting help and learning more https://community.rstudio.com/tags/plotly 1.7 Acknowledgements This book wouldn‚Äôt be possible without the generous assistance and mentorship of many people: Toby Dylan Hocking for many helpful conversations, his mentorship in the R packages animint and plotly, and laying the original foundation behind ggplotly(). Heike Hofmann and Di Cook for many helpful conversations about interactive graphics. Joe Cheng for many helpful conversations and inspiring section 17.1. √âtienne T√©treault-Pinard, Alex Johnson, and the other plotly.js core developers for responding to my feature requests and bug reports. Yihui Xie for his work on knitr, rmarkdown, bookdown, and responding to my feature requests. Without bookdown, this book would never have happened. Hadley Wickham and the ggplot2 team for maintaining ggplot2. Anthony Unwin for helpful feedback, suggestions, and for inspiring Figure 17.14. Hadley Wickham and Garret Grolemund for writing R for Data Science and allowing me to model this introduction after their introduction. Adam Loy for inspiring Figure 15.5. 1.8 Colophon An online version of this book is available at https://plotly-book.cpsievert.me. It will continue to evolve in between reprints of the physical book. The source of the book is available at https://github.com/cpsievert/plotly_book. The book is powered by https://bookdown.org which makes it easy to turn R markdown files into HTML, PDF, and EPUB. This book was built with the following computing environment: devtools::session_info(&quot;plotly&quot;) #&gt; ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #&gt; setting value #&gt; version R version 3.5.2 (2018-12-20) #&gt; os macOS Mojave 10.14.2 #&gt; system x86_64, darwin15.6.0 #&gt; ui X11 #&gt; language (EN) #&gt; collate en_US.UTF-8 #&gt; ctype en_US.UTF-8 #&gt; tz America/Chicago #&gt; date 2019-02-07 #&gt; #&gt; ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #&gt; package * version date lib source #&gt; askpass 1.1 2019-01-13 [1] CRAN (R 3.5.2) #&gt; assertthat 0.2.0 2017-04-11 [1] CRAN (R 3.5.0) #&gt; base64enc 0.1-3 2015-07-28 [1] CRAN (R 3.5.0) #&gt; BH 1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2) #&gt; bindr 0.1.1 2018-03-13 [1] CRAN (R 3.5.0) #&gt; bindrcpp * 0.2.2 2018-03-29 [1] CRAN (R 3.5.0) #&gt; cli 1.0.1 2018-09-25 [1] CRAN (R 3.5.0) #&gt; colorspace 1.4-0 2019-01-13 [1] CRAN (R 3.5.2) #&gt; crayon 1.3.4 2017-09-16 [1] CRAN (R 3.5.0) #&gt; crosstalk 1.0.0 2016-12-21 [1] CRAN (R 3.5.0) #&gt; curl 3.3 2019-01-10 [1] CRAN (R 3.5.2) #&gt; data.table 1.12.0 2019-01-13 [1] CRAN (R 3.5.2) #&gt; digest 0.6.18 2018-10-10 [1] CRAN (R 3.5.1) #&gt; dplyr * 0.7.8 2018-11-10 [1] CRAN (R 3.5.0) #&gt; fansi 0.4.0 2018-12-03 [1] Github (brodieG/fansi@ab11e9c) #&gt; ggplot2 * 3.1.0 2018-10-25 [1] CRAN (R 3.5.0) #&gt; glue 1.3.0 2018-07-17 [1] CRAN (R 3.5.0) #&gt; gtable 0.2.0 2016-02-26 [1] CRAN (R 3.5.0) #&gt; hexbin 1.27.2 2018-01-15 [1] CRAN (R 3.5.0) #&gt; htmltools 0.3.6.9003 2018-12-05 [1] local #&gt; htmlwidgets 1.3 2019-02-06 [1] local #&gt; httpuv 1.4.5.1 2018-12-18 [1] CRAN (R 3.5.0) #&gt; httr 1.4.0 2018-12-11 [1] CRAN (R 3.5.1) #&gt; jsonlite 1.6 2018-12-07 [1] CRAN (R 3.5.1) #&gt; labeling 0.3 2014-08-23 [1] CRAN (R 3.5.0) #&gt; later 0.7.5 2018-09-18 [1] CRAN (R 3.5.1) #&gt; lattice 0.20-38 2018-11-04 [1] CRAN (R 3.5.2) #&gt; lazyeval 0.2.1 2017-10-29 [1] CRAN (R 3.5.0) #&gt; magrittr 1.5 2014-11-22 [1] CRAN (R 3.5.0) #&gt; MASS 7.3-51.1 2018-11-01 [1] CRAN (R 3.5.2) #&gt; Matrix 1.2-15 2018-11-01 [1] CRAN (R 3.5.2) #&gt; mgcv 1.8-26 2018-11-21 [1] CRAN (R 3.5.2) #&gt; mime 0.6 2018-10-05 [1] CRAN (R 3.5.1) #&gt; munsell 0.5.0 2018-06-12 [1] CRAN (R 3.5.0) #&gt; nlme 3.1-137 2018-04-07 [1] CRAN (R 3.5.2) #&gt; openssl 1.2.1 2019-01-17 [1] CRAN (R 3.5.2) #&gt; pillar 1.3.1.9000 2019-01-23 [1] Github (r-lib/pillar@3a54b8d) #&gt; pkgconfig 2.0.2 2018-08-16 [1] CRAN (R 3.5.0) #&gt; plogr 0.2.0 2018-03-25 [1] CRAN (R 3.5.0) #&gt; plotly * 4.8.0.9000 2019-02-07 [1] local #&gt; plyr 1.8.4 2016-06-08 [1] CRAN (R 3.5.0) #&gt; promises 1.0.1 2018-04-13 [1] CRAN (R 3.5.0) #&gt; purrr 0.3.0 2019-01-27 [1] CRAN (R 3.5.2) #&gt; R6 2.3.0 2018-10-04 [1] CRAN (R 3.5.1) #&gt; RColorBrewer 1.1-2 2014-12-07 [1] CRAN (R 3.5.0) #&gt; Rcpp 1.0.0 2018-11-07 [1] CRAN (R 3.5.0) #&gt; reshape2 1.4.3 2017-12-11 [1] CRAN (R 3.5.0) #&gt; rlang 0.3.1 2019-01-08 [1] CRAN (R 3.5.2) #&gt; scales 1.0.0 2018-08-09 [1] CRAN (R 3.5.0) #&gt; shiny 1.2.0.9000 2019-01-28 [1] local #&gt; sourcetools 0.1.7 2018-04-25 [1] CRAN (R 3.5.0) #&gt; stringi 1.2.4 2018-07-20 [1] CRAN (R 3.5.0) #&gt; stringr 1.3.1 2018-05-10 [1] CRAN (R 3.5.0) #&gt; sys 2.1 2018-11-13 [1] CRAN (R 3.5.1) #&gt; tibble 2.0.1 2019-01-12 [1] CRAN (R 3.5.2) #&gt; tidyr 0.8.2 2018-10-28 [1] CRAN (R 3.5.1) #&gt; tidyselect 0.2.5 2018-10-11 [1] CRAN (R 3.5.1) #&gt; utf8 1.1.4 2018-05-24 [1] CRAN (R 3.5.0) #&gt; viridisLite 0.3.0 2018-02-01 [1] CRAN (R 3.5.0) #&gt; withr 2.1.2 2018-03-15 [1] CRAN (R 3.5.0) #&gt; xtable 1.8-3 2018-08-29 [1] CRAN (R 3.5.0) #&gt; yaml 2.2.0 2018-07-25 [1] CRAN (R 3.5.0) #&gt; #&gt; [1] /Library/Frameworks/R.framework/Versions/3.5/Resources/library References "],
["why-web-graphics.html", "2 Why interactive web graphics in R?", " 2 Why interactive web graphics in R? Data science workflow Interactivity augments exploration Some historical context and examples (https://talks.cpsievert.me/20180202/#7) ‚ÄúInteractive graphics enable the analyst to pursue follow-up questions‚Äù ‚Äì Cook &amp; Swayne, GGobi book, p15 A case study of US election data GUI and command-line - conflict or synergy? https://talks.cpsievert.me/20180305/#12 Web-based visualization New capabilites (e.g. easy sharing, portability) brings new set of concerns (e.g., client-server, security, etc) Great tools for expository vis (d3.js, vega, plotly.js) Lack of tools for exploratory vis (i.e. tools for iteration) Why plotly for R? MIT-licensed software built with plotly.js and htmlwidgets Perhaps mention the plotly.js development pace Users can opt into plotly cloud Mention orca? Built on sound visualization and programming principles: The Grammar of Graphics Pure functional programming Two approaches, one object Works well with the tidyverse "],
["overview.html", "3 Overview 3.1 Intro to plot_ly() 3.2 Intro to plotly.js 3.3 Intro to ggplotly()", " 3 Overview This part of the book teaches you how to leverage the plotly R package to create a variety of interactive graphics. There are two main ways to creating a plotly object: either by transforming a ggplot2 object (via ggplotly()) into a plotly object or by directly initializing a plotly object with plot_ly()/plot_geo()/plot_mapbox(). Both approaches have somewhat complementary strengths and weaknesses, so it can pay off to learn both approaches. Moreover, both approaches are an implementation of the Grammar of Graphics and both are powered by the JavaScript graphing library plotly.js, so many of the same concepts and tools that you learn for one interface can be reused in the other. The subsequent chapters within this ‚ÄòCreating views‚Äô part dive into specific examples and use cases, but this introductory chapter outlines some over-arching concepts related to plotly in general. It also provides definitions for terminology used throughout the book and introduces some concepts useful for understanding the infrastructure behind any plotly object. Most of these details aren‚Äôt necessarily required to get started with plotly, but it will envitably help you get ‚Äòun-stuck‚Äô, write better code, and do more advanced things with plotly. 3.1 Intro to plot_ly() Any graph made with the plotly R package is powered by the JavaScript library plotly.js. The plot_ly() function provides a ‚Äòdirect‚Äô interface to plotly.js with some additional abstractions to help reduce typing. These abstractions, inspired by the Grammar of Graphics and ggplot2, make it much faster to iterate from one graphic to another, making it easier to discover interesting features in the data (Wilkinson 2005); (Wickham 2009). To demonstrate, we‚Äôll use plot_ly() to explore the diamonds dataset from ggplot2 and learn a bit how plotly and plotly.js work along the way. # load the plotly R package library(plotly) # load the diamonds dataset from the ggplot2 package data(diamonds, package = &quot;ggplot2&quot;) diamonds #&gt; # A tibble: 53,940 x 10 #&gt; carat cut color clarity depth table price x y z #&gt; &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 #&gt; 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 #&gt; 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 #&gt; 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 #&gt; 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 #&gt; 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 #&gt; # ‚Ä¶ with 5.393e+04 more rows If we assign variable names (e.g., cut, clarity, etc) to visual properties (e.g., x, y, color, etc) within plot_ly(), as done in Figure 3.1, it tries to find a sensible geometric representation of that information for us. Shortly we‚Äôll cover how to specify these geometric representations (as well as other visual encodings) to create different kinds of charts. # create three visualizations of the diamonds dataset plot_ly(diamonds, x = ~cut) plot_ly(diamonds, x = ~cut, y = ~clarity) plot_ly(diamonds, x = ~cut, color = ~clarity, colors = &quot;Accent&quot;) The ~ operator is only needed when refering to a column name in data (the first argument to plot_ly()). Moreover, the data argument is optional, meaning you can also provide column(s) directly to plot_ly(x = diamonds$cut) FIGURE 3.1: Three examples of visualizing categorical data with plot_ly(): (top) mapping cut to x yields a bar chart, (middle) mapping cut &amp; clarity to x &amp; y yields a heatmap, and (c) mapping cut &amp; clarity to x &amp; color yields a dodged bar chart. The plot_ly() function has numerous arguments that are unique to the R package (e.g., color, stroke, span, symbol, linetype, etc) and make it easier to encode data as visual properties. By default, these arguments map values to a visual range defined by the plural form of the argument (e.g., colors, strokes, spans, symbols, linetypes, etc). Figure 3.2 depicts how the combination of color (e.g., clarity levels) and colors (e.g., the \"Accent\" color palette from the RColorBrewer package) can be used to specify a mapping from data values to color codes. Besides providing a palette by name, one may also provide their own mapping function (e.g., colorRamp()), or even a set of custom color codes. See Chapter 4 for many more examples and Chapter 31 for more details about working with colors. FIGURE 3.2: Mapping data values to a visual color range. Since these arguments, by default, map values to a visual range, you will obtain unexpected results if you try to specify the visual range directly, as in the top portion of Figure 3.3. If you want to specify the visual range directly, use the I() function to declare this value to be taken ‚ÄòAsIs‚Äô, as in the bottom portion of Figure 3.3. As discussed in more detail in section 3.2, these ‚Äòaesthetic mapping‚Äô arguments are not officially part of plotly.js, but the R package transform this information into valid plotly.js figures. Many other examples in the book will leverage these arguments, especially Chapter 4. Another resource to learn more details about these arguments (especially their defaults) is the R documentation page available by entering help(plot_ly) in your R console. # doesn&#39;t produce black bars plot_ly(diamonds, x = ~cut, color = &quot;black&quot;) # produces red bars with black outline plot_ly(diamonds, x = ~cut, color = I(&quot;red&quot;), stroke = I(&quot;black&quot;), span = I(2)) FIGURE 3.3: Using I() to supply visual properties directly instead of mapping values to a visual range. In the top portion of this figure, the value 'black' is being mapped to a visual range spanned by colors (which, for discrete data, defaults to 'Set2'). The plotly package takes a purely functional approach to a layered grammar of graphics (Wickham 2010).2 The purely functional part means, (almost) every function anticipates a plotly object as input to it‚Äôs first argument and returns a modified version of that plotly object. Furthermore, that modification is completely determined by the input values to the function (i.e., it doesn‚Äôt rely on any side-effects, unlike, for example, base R graphics). For a quick example, the layout() function anticipates a plotly object in it‚Äôs first argument and it‚Äôs other arguments add and/or modify various layout components of that object (e.g., the title): layout( plot_ly(diamonds, x = ~cut), title = &quot;My beatiful histogram&quot; ) For more complex plots that modify a plotly graph many times over, code written in this way can become cumbersome to read. In particular, we have to search for the inner-most part of the R expression, then work outwards towards the end result. The %&gt;% operator from the magrittr package allows us to re-arrange this code so that we can read the sequence of modifications from left-to-right rather than inside-out (Bache and Wickham 2014). The %&gt;% operator enable this by placing the object on the left-hand side of the %&gt;% into the first argument of the function of the right-hand side. diamonds %&gt;% plot_ly(x = ~cut) %&gt;% layout(title = &quot;My beatiful histogram&quot;) In addition to layout() for adding/modifying part(s) of the graphs‚Äôs layout, there are also a family of add_*() functions (e.g., add_histogram(), add_lines(), etc) that define how to render data into geometric objects. Borrowing terminology from the layered grammar of graphics, these functions add a graphical layer to a plot. A layer can be thought of as a group of graphical elements that can be sufficiently described using only 5 components: data, aethestic mappings (e.g., assigning clarity to color), a geometric representation (e.g. rectangles, circles, etc), statistical transformations (e.g., sum, mean, etc), and positional adjustments (e.g., dodge, stack, etc). If you‚Äôre paying attention, you‚Äôll notice that in the examples thus far, we have not specified a layer! The layer has been added for us automatically by plot_ly(). To be explicit about what plot_ly(diamonds, x = ~cut) generates, we should add a add_histogram() layer: diamonds %&gt;% plot_ly() %&gt;% add_histogram(x = ~cut) As you‚Äôll learn more about in Section 6, plotly has both add_histogram() and add_bars(). The difference is that add_histogram() performs statistics (i.e., a binning algorithm) dynamically in the web browser, whereas add_bars() requires the bar heights to be pre-specified. That means, to replicate the last example with add_bars(), the number of observations must be computed ahead-of-time. diamonds %&gt;% dplyr::count(cut) %&gt;% plot_ly() %&gt;% add_bars(x = ~cut, y = ~n) There are numerous other add_*() functions that calculate statistics in the browser (e.g., add_histogram2d(), add_contour(), add_boxplot(), etc), but most other functions aren‚Äôt considered statistical. Making the distinction might not seem useful now, but they have their own respective trade-offs when it comes to speed and interactivity. Generally speaking, non-statistical layers will be faster and more responsive at run-time (since they require less computational work), whereas the statistical layers allow for more flexibility when it comes to client-side interactivity, as covered in section 17. Practically speaking, the difference in performance is often negligible ‚Äì the more common bottleneck occurs when attempting to render lots of graphical elements at a time (e.g., a scatterplot with a million points). In those scenarios, you likely want to render your plot in Canvas rather than SVG (the default) via toWebGL() ‚Äì for more information on scaling views, see 19. In many scenarios, it can be useful to combine multiple graphical layers into a single plot. In this case, it becomes useful to know a few things about plot_ly(): Arguments specified in plot_ly() are global, meaning that any downstream add_*() functions inherit these arguments (unless inherit = FALSE). Data manipulation verbs from the dplyr package may be used to transform the data underlying a plotly object.3 Using these two properties of plot_ly(), Figure 3.4 demonstrates how we could leverage these properties of plot_ly() to do the following: Globally assign cut to x. Add a histogram layer (inherits the x from plot_ly()). Use dplyr verbs to modify the data underlying the plotly object. Here we just count the number of diamonds in each cut category. Add a layer of text using the summarized counts. Note that the global x mapping, as well as the other mappings local to this text layer (text and y), reflect data values from step 3. library(dplyr) diamonds %&gt;% plot_ly(x = ~cut) %&gt;% add_histogram() %&gt;% group_by(cut) %&gt;% summarise(n = n()) %&gt;% add_text( text = ~scales::comma(n), y = ~n, textposition = &quot;top middle&quot;, cliponaxis = FALSE ) FIGURE 3.4: Using add_histogram(), add_text(), and dplyr verbs to compose a plot that leverages a raw form of the data (e.g., histogram) as well as a summarized version (e.g., text labels). Before using multiple add_*() in a single plot, make sure that you actually want to show those layers of information on the same set of axes. If it makes sense to display the information on the same axes, consider making multiple plotly objects and combining them into as grid-like layout using subplot(), as described in section 14. Also, when using dplyr verbs to modify the data underlying the plotly object, you can use the plotly_data() function to obtain the data at any point in time. This can be helpful for finding why something has diamonds %&gt;% plot_ly(x = ~cut) %&gt;% add_histogram() %&gt;% group_by(cut) %&gt;% summarise(n = n()) %&gt;% plotly_data() #&gt; # A tibble: 5 x 2 #&gt; cut n #&gt; &lt;ord&gt; &lt;int&gt; #&gt; 1 Fair 1610 #&gt; 2 Good 4906 #&gt; 3 Very Good 12082 #&gt; 4 Premium 13791 #&gt; 5 Ideal 21551 This introduction to plot_ly() has mainly focused on concepts unique to the R package plotly that are generally useful for creating most kinds of data views. The section outlines how plotly generates plotly.js figures and how to inspect the underlying data structure that plotly.js uses to render the graph. Not only is this information useful for debugging, but it‚Äôs also a nice way to learn how to work with plotly.js directly, which you may need to improve performance in shiny apps (Chapter 18.3.1) and/or for adding custom behavior with JavaScript (Chapter 23). 3.2 Intro to plotly.js To recreate the plots in Figure 3.1 using plotly.js directly, it would take significantly more code and knowledge of plotly.js. That being said, learning how plotly generates the underlying plotly.js figure is a useful introduction to plotly.js itself, and knowledge of plotly.js becomes useful when you need more flexible control over plotly. As Figure 3.5 illustrates, when you print any plotly object, the plotly_build() function is applied to that object, and that generates an R list which adheres to a syntax that plotly.js understands. This syntax is a JavaScript Object Notation (JSON) specification that plotly.js uses to represent, seralize, and render web graphics. A lot of documentation you‚Äôll find online about plotly (e.g., the online figure reference) implictly refers to this JSON specification, so it can helpful to know how to ‚Äúwork backwards‚Äù from that documentation (i.e., translate JSON into to R code). If you‚Äôd like to learn details about mapping between R and JSON, section 24 provides an introduction aimed at R programmers, and Ooms (2014) provides a cohesive overview of the jsonlite package, which is what plotly uses to map between R and JSON. FIGURE 3.5: A diagram of what happens when you print a plotly graph. For illustration purposes, Figure 3.5 shows how this workflow applies to a simple bar graph (with values directly supplied instead of a data column name reference like Figure 3.1), but the same concept applies for any graph created via plotly. As the diagram suggests, both the plotly_build() and plotly_json() functions can be used to inspect the underlying data structure on both the R and JSON side of things. For example, Figure 3.6 shows the data portion of the JSON created for the last graph in Figure 3.6. p &lt;- plot_ly(diamonds, x = ~cut, color = ~clarity, colors = &quot;Accent&quot;) plotly_json(p) FIGURE 3.6: A portion of the JSON data behind the bottom plot of Figure 3.1. This dodged bar chart has 8 layers of data (i.e., 8 traces) ‚Äì one for each level of clarity. In plotly.js terminology, a figure has two key components: data (aka, traces) and a layout. A trace defines a mapping from data and visuals.4 Every trace has a type (e.g., histogram, pie, scatter, etc) and the trace type determines what other attributes (i.e., visual and/or interactive properties, like x, hoverinfo, name) are available to control the trace mapping. That is, not every trace attribute is available to every trace type, but many attributes (e.g., the name of the trace) are available in every trace type and serve a similar purpose. From Figure 3.6 we can see that it takes multiple traces to generate the dodged bar chart, but instead of clicking through JSON viewer, sometimes it‚Äôs easier to use plotly_build() and compute on the plotly.js figure definition to verify certain things exist. Since plotly uses the htmlwidgets standard5, the actual plotly.js figure definition appears under a list element named x (Vaidyanathan et al. 2016). # use plotly_build() to get at the plotly.js definition # behind *any* plotly object b &lt;- plotly_build(p) # Confirm there 8 traces length(b$x$data) #&gt; [1] 8 # Extract the `name` of each trace. plotly.js uses `name` to populate legend entries and tooltips purrr::map_chr(b$x$data, &quot;name&quot;) #&gt; [1] &quot;IF&quot; &quot;VVS1&quot; &quot;VVS2&quot; &quot;VS1&quot; &quot;VS2&quot; &quot;SI1&quot; &quot;SI2&quot; &quot;I1&quot; # Every trace has a type of histogram unique(purrr::map_chr(b$x$data, &quot;type&quot;)) #&gt; [1] &quot;histogram&quot; Here we‚Äôve learned that plotly creates 8 histogram traces to generate the dodged bar chart: one trace for each level of clarity.6 Why one trace per category? As illustrated in Figure 3.7 there are two main reasons: to populate a tooltip and legend entry for each level of clarity level. FIGURE 3.7: Leveraging two interactive features that require one trace per level of clarity: (1) Using ‚ÄòCompare data on hover‚Äô mode to get counts for every level of clarity for a given level of cut and (2) Using the ability to hide/show clarity levels via their legend entries. If we investigated further, we‚Äôd notice that color and colors are not officially part of the plotly.js figure definition ‚Äì the plotly_build() function has effectively transformed that information into a sensible plotly.js figure definition (e.g., marker.color contains the actual bar color codes). In fact, the color argument in plot_ly() is just one example of an abstraction the R package has built on top of plotly.js to make it easier to map data values to visual attributes, and many of these are covered in Section 4. 3.3 Intro to ggplotly() The ggplotly() function from the plotly package has the ability to translate ggplot2 to plotly. This functionality can be really helpful for quickly adding interactivity to your existing ggplot2 workflow.7 Moreover, even if you know plot_ly() and plotly.js well, ggplotly() can still be desirable for creating visualizations that aren‚Äôt necessarily straight-forward to acheive without it. To demonstrate, let‚Äôs explore the relationship between price and other variables from the well-known diamonds dataset. Hexagonal binning (i.e., geom_hex()) is useful way to visualize a 2D density8, like the relationship between price and carat as shown in Figure 3.8. From Figure 3.8, we can see there is a strong positive linear relationship between the log of carat and price. It also shows that many the carat is only rounded to a particular number (indicated by the light blue bands) and no diamonds are priced around $1500. Making this plot interactive makes it easier to decode the hexagonal colors into the counts that they represent. p &lt;- ggplot(diamonds, aes(x = log(carat), y = log(price))) + geom_hex(bins = 100) ggplotly(p) FIGURE 3.8: A hexbin plot of diamond carat versus price. I often use ggplotly() over plot_ly() to leverage ggplot2‚Äôs consistent and expressive interface for exploring statistical summaries across groups. For example, by including a discrete color variable (e.g., cut) with geom_freqpoly(), you get a frequency polygon for each level of that variable. This ability to quickly generate visual encodings of statisitical summaries across an arbitrary number of groups works for basically any geom (e.g. geom_boxplot(), geom_histogram(), geom_density(), etc) and is a key feature of ggplot2. p &lt;- ggplot(diamonds, aes(x = log(price), color = clarity)) + geom_freqpoly() ggplotly(p) FIGURE 3.9: Frequency polygons of diamond price by diamond clarity. This visualization indicates there may be significant main effects. Now, to see how price varies with both cut and clarity, we could repeat this same visualization for each level of cut. This is where ggplot2‚Äôs facet_wrap() comes in handy. Moreover, to facilitate comparisons, we can have geom_freqpoly() display relative rather than absolute frequencies. By making this plot interactive, we can more easily compare particular levels of clarity (as shown in Figure 3.10) by leveraging the legend filtering capabilites. p &lt;- ggplot(diamonds, aes(x = log(price), color = clarity)) + geom_freqpoly(stat = &quot;density&quot;) + facet_wrap(~cut) ggplotly(p) FIGURE 3.10: Diamond price by clarity and cut. In addition to supporting most of the ‚Äòcore‚Äô ggplot2 API, ggplotly() can automatically convert any ggplot2 extension packages that return a ‚Äòstandard‚Äô ggplot2 object. By standard, I mean that the object is comprised of ‚Äòcore‚Äô ggplot2 data structures and not the result of custom geoms.9 Some great examples of R packages that extend ggplot2 using core data structures are ggforce, naniar, and GGally (Pedersen 2019); (Tierney et al., n.d.); (Schloerke et al. 2016). Figure 3.11 demonstrates another way of visualizing the same information found in Figure 3.10 using geom_sina() from the ggforce package (instead of geom_freqpoly()). This visualization jitters the raw data within the density for each group ‚Äì allowing us not only only see where the majority observations fall within a group, but also across all across all groups. By making this layer interactive, we can query individual points for more information and zoom into interesting regions. The second layer of Figure 3.11 uses ggplot2‚Äôs stat_summary() to overlay a 95% confidence interval esimated via a bootstrap algorithm via the Hmisc package (Harrell Jr, Charles Dupont, and others. 2019). p &lt;- ggplot(diamonds, aes(x = clarity, y = log(price), color = clarity)) + ggforce::geom_sina(alpha = 0.1) + stat_summary(fun.data = &quot;mean_cl_boot&quot;, color = &quot;black&quot;) + facet_wrap(~cut) # WebGL is a lot more efficient at rendering lots of points toWebGL(ggplotly(p)) FIGURE 3.11: A sina plot of diamond price by clarity and cut. As noted by Wickham and Grolemund (2018), it‚Äôs surprising that the diamond price would decline with an increase of diamond clarity. As it turns out, if we account for the carat of the diamond, then see that better diamond clarity does indeed lead to a higher diamond price, as shown in Figure 3.12. Seeing such a strong pattern in the residuals of simple linear model of carat vs price indicates that our model could be greatly improved by adding clarity as a predictor of price. m &lt;- lm(log(price) ~ log(carat), data = diamonds) diamonds &lt;- modelr::add_residuals(diamonds, m) p &lt;- ggplot(diamonds, aes(x = clarity, y = resid, color = clarity)) + ggforce::geom_sina(alpha = 0.1) + stat_summary(fun.data = &quot;mean_cl_boot&quot;, color = &quot;black&quot;) + facet_wrap(~cut) toWebGL(ggplotly(p)) FIGURE 3.12: A sina plot of diamond price by clarity and cut, after accounting for carat. As discussed in Section 17.4.7 the GGally package provides a convenient interface for making similar types of model diagnostic visualizations via the ggnostic() function. It also provides a convenience function for visualizating the coefficient estimates and their standard errors via the ggcoef() function. Figure 3.13 shows how injecting interactivity to this plot allows us to query exact values and zoom in on the most intere library(GGally) m &lt;- lm(log(price) ~ log(carat) + cut, data = diamonds) gg &lt;- ggcoef(m) # dynamicTicks means generate new axis ticks on zoom ggplotly(gg, dynamicTicks = TRUE) FIGURE 3.13: Zooming in on a coefficient plot generated from the ggcoef() function from the GGally package. Although the diamonds dataset does not contain any missing values, it‚Äôs a very common problem in real data analysis problems. The naniar package provides a suite of computational and visual resources for working with and revealing structure in missing values. All the ggplot2 based visualizations return an object that can be converted by ggplotly(). Moreover, naniar provides a custom geom, geom_miss_point(), that can be useful for visualizing missingness structure. Figure 3.14 demonstrates this by introducing fake missing values to the diamond price. library(naniar) # fake some missing data diamonds$price_miss &lt;- ifelse(diamonds$depth &gt; 60, diamonds$price, NA) p &lt;- ggplot(diamonds, aes(x = clarity, y = log(price_miss))) + geom_miss_point(alpha = 0.1) + stat_summary(fun.data = &quot;mean_cl_boot&quot;, colour = &quot;black&quot;) + facet_wrap(~cut) toWebGL(ggplotly(p)) FIGURE 3.14: Using the geom_miss_point() function from the naniar package to visualize missing values in relation to non-missing values. Missing values are shown in red. In short, the ggplot2 ecosystem provides a world-class exploratory visualization toolkit, and having the ability to quickly insert interactivity such as hover, zoom, and filter via ggplotly() makes it even more powerful for exploratory analysis. In this introduction to ggplotly(), we‚Äôve only seen relatively simple techniques that come for free out-of-the-box, but the true power of interactive graphics lies in linking multiple views. In that part of the book, you can find lots of examples of linking multiple (ggplotly() &amp; plot_ly()) graphs purely client-side as well as with shiny. It‚Äôs also worth mentioning that ggplotly() conversions are not always perfect and ggplot2 doesn‚Äôt provide an API for interactive features, so sometimes it‚Äôs desirable to modify the return values of ggplotly(). Section 37 talks generally about modifying the data structure underlying ggplotly() (which, by the way, uses the same a plotly.js figure definition as discussed in Section 3.2). Moreover, Section 29.2 outlines various ways to customize the tooltip that ggplotly() produces. References "],
["scatter-traces.html", "4 Scattered foundations 4.1 Markers 4.2 Lines 4.3 Polygons", " 4 Scattered foundations As we learned in Section 3.2, a plotly.js figure contains one (or more) trace(s), and every trace has a type. The trace type scatter is great for drawing low-level geometries (e.g., points, lines, text, and polygons) and provides the foundation for many add_*() functions (e.g., add_markers(), add_lines(), add_paths(), add_segments(), add_ribbons(), add_area(), and add_polygons()) as well as many ggplotly() charts. These scatter-based layers provide a more convenient interface to special cases of the scatter trace by doing a bit of data wrangling and transformation under-the-hood before mapping to scatter trace(s). For a simple example, add_lines() ensures lines are drawn according to the ordering of x, which is desirable for a time series plotting. This behavior is subtly different than add_paths() which uses row ordering instead. library(plotly) data(economics, package = &quot;ggplot2&quot;) # sort economics by psavert, just to # show difference between paths and lines p &lt;- economics %&gt;% arrange(psavert) %&gt;% plot_ly(x = ~date, y = ~psavert) add_paths(p) add_lines(p) FIGURE 4.1: The difference between add_paths() and add_lines(): the top panel connects observations according to the ordering of psavert (personal savings rate), whereas the bottom panel connects observations according to the ordering of x (the date). Section 3.1 introduced ‚Äòaesthetic mapping‚Äô arguments (unique to the R package) which make it easier to map data to visual properties (e.g., color, linetype, etc). In addition to these arguments, dplyr groupings can be used to ensure there is at least one geometry per group. The top panel of Figure 4.1 demonstrates how group_by() could be used to effectively wrap the time series from Figure 4.1 by year, which can be useful for visualizing annual seasonality. Another approach to generating at least one geometry per ‚Äògroup‚Äô is to provide categorical variable to a relevant aesthetic (e.g., color), as shown in the bottom panel of Figure 4.1. library(lubridate) econ &lt;- economics %&gt;% mutate(yr = year(date), mnth = month(date)) # one trace (more performant, but less interactive) econ %&gt;% group_by(yr) %&gt;% plot_ly(x = ~mnth, y = ~uempmed) %&gt;% add_lines(text = ~yr) # multiple traces (less performant, but more interactive) plot_ly(econ, x = ~mnth, y = ~uempmed) %&gt;% add_lines(color = ~ordered(yr)) # the split argument guarantees one trace per group level (regardless of the variable type) # this is useful if you want a consistent visual properties over multiple traces # plot_ly(econ, x = ~mnth, y = ~uempmed) %&gt;% # add_lines(split = ~yr, color = I(&quot;black&quot;)) FIGURE 4.2: Drawing multiple lines using dplyr groups (top panel) versus a categorical color mapping (bottom panel). Comparatively speaking, the bottom panel has more interactive capabilites (e.g., legend-based filtering and multiple tooltips), but it does not scale as well with many lines. Not only do these plots differ in visual appearance, they also differ in interactive capabilties, computational performance, and underlying implementation. That‚Äôs because, the grouping approach (top panel of Figure 4.2) uses just one plotly.js trace (more performant, less interactive), whereas the color approach (bottom panel of Figure 4.2) generates one trace per line/year. In this case, the benefit of having multiple traces is that we can perform interactive filtering via the legend and compare multiple y-values at a given x. The cost of having those capabilities is that plots starts to be become sluggish after a few hundred traces, whereas thousands of lines can be rendered fairly easily in one trace. See section 19 for more details on scaling and performance. These features make it easier to get started using plotly.js, but it still pays off to learn how to use plotly.js directly. You won‚Äôt find plotly.js attributes listed as explicit arguments in any plotly function (except for the special type attribute), but they are passed along verbatim to the plotly.js figure definition through the ... operator. The scatter-based layers in this chapter fix the type plotly.js attribute to \"scatter\" as well as the mode (e.g., add_markers() uses mode='markers' etc), but you could also use the lower-level add_trace() to work more directly with plotly.js. For example, Figure 4.3 shows how to render markers, lines, and text in the same scatter trace. It also demonstrates how to leverage nested plotly.js attributes, like textfont and xaxis ‚Äì these attributes contain other attributes, so you need to supply a suitable named list to these arguments. set.seed(99) plot_ly() %&gt;% add_trace( type = &quot;scatter&quot;, mode = &quot;markers+lines+text&quot;, x = 4:6, y = 4:6, text = replicate(3, praise::praise(&quot;You are ${adjective}! üôå&quot;)), textposition = &quot;right&quot;, hoverinfo = &quot;text&quot;, textfont = list(family = &quot;Roboto Condensed&quot;, size = 16) ) %&gt;% layout(xaxis = list(range = c(3, 8))) FIGURE 4.3: Using the generic add_trace() function to render markers, lines, and text in a single scatter trace. This add_trace() function, as well as any add_*() function allows you to directly specify plotly.js attributes. If you are new to plotly.js, I recommend taking a bit of time to look through the plotly.js attributes that are available to the scatter trace type and think how you might be able to use them. Most of these attributes work for other trace types as well, so learning an attribute once for a specific plot can pay off in other contexts as well. The online plotly.js figure reference, https://plot.ly/r/reference/#scatter, is a decent place to search and learn about the attributes, but I recommend using the schema() function instead for a few reasons: schema() provides a bit more information than the online docs (e.g., value types, default values, acceptable ranges, etc). The interface makes it a bit easier to traverse and discover new attributes. You can be absolutely sure it matches the version used in the R package (the online docs might use a different ‚Äì probably older ‚Äì version). schema() FIGURE 4.4: Using schema() function to traverse through the attributes available to a given trace type (e.g., scatter) The sections that follow in this chapter demonstrate various type of data views using scatter-based layers. In attempt to avoid duplication of documentation, a particular emphasis is put on features only currently availble from the R package (e.g. the aesthetic mapping arguments). 4.1 Markers This section details scatter traces with a mode of \"markers\" (i.e., add_markers()). For simplicity, many of the examples here use add_markers() with a numeric x and y axis, which results in scatterplot ‚Äì a common way to visualize the association between two quantitative variables. The content that follows is still relevant markers displayed non-numeric x and y (aka dot pots) as shown in Section 4.1.6 4.1.1 Alpha blending As Unwin (2015) notes, scatterplots can be useful for exposing other important features including: casual relationships, outliers, clusters, gaps, barriers, and conditional relationships. A common problem with scatterplots however is overplotting, meaning that there are multiple observations occupying the same (or similar) x/y locations. Figure 4.5 demonstrates one way to combat overplotting via alpha blending. When dealing with tens of thousands of points (or more), consider using toWebGL() to render plots using Canvas rather than SVG (more in section 19), or leveraging 2D density estimation (section 8.2). subplot( plot_ly(mpg, x = ~cty, y = ~hwy, name = &quot;default&quot;), plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(alpha = 0.2, name = &quot;alpha&quot;) ) FIGURE 4.5: Combating overplotting in a scatterplot with alpha blending. 4.1.2 Colors As discussed in 3.2, mapping a discrete variable to color produces one trace per category, which is desirable for it‚Äôs legend and hover properties. On the other hand, mapping a numeric variable to color produces one trace, as well as a colorbar guide for visually decoding colors back to data values. The colorbar() function can be used to customize the appearance of this automatically generated guide. The default colorscale is viridis, a perceptually-uniform colorscale (even when converted to black-and-white), and perceivable even to those with common forms of color blindness (Data Science 2016). Viridis is also the default colorscale for ordered factors. p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.5) subplot( add_markers(p, color = ~cyl, showlegend = FALSE) %&gt;% colorbar(title = &quot;Viridis&quot;), add_markers(p, color = ~factor(cyl)) ) FIGURE 4.6: Variations on a numeric color mapping. There are numerous ways to alter the default color scale via the colors argument. This argument excepts one of the following: (1) a color brewer palette name (see the row names of RColorBrewer::brewer.pal.info for valid names), (2) a vector of colors to interpolate, or (3) a color interpolation function like colorRamp() or scales::colour_ramp(). Although this grants a lot of flexibility, one should be conscious of using a sequential colorscale for numeric variables (&amp; ordered factors) as shown in 4.7, and a qualitative colorscale for discrete variables as shown in 4.8. col1 &lt;- c(&quot;#132B43&quot;, &quot;#56B1F7&quot;) col2 &lt;- viridisLite::inferno(10) col3 &lt;- colorRamp(c(&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;)) subplot( add_markers(p, color = ~cyl, colors = col1) %&gt;% colorbar(title = &quot;ggplot2 default&quot;), add_markers(p, color = ~cyl, colors = col2) %&gt;% colorbar(title = &quot;Inferno&quot;), add_markers(p, color = ~cyl, colors = col3) %&gt;% colorbar(title = &quot;colorRamp&quot;) ) %&gt;% hide_legend() FIGURE 4.7: Three variations on a numeric color mapping. col1 &lt;- &quot;Accent&quot; col2 &lt;- colorRamp(c(&quot;red&quot;, &quot;blue&quot;)) col3 &lt;- c(`4` = &quot;red&quot;, `5` = &quot;black&quot;, `6` = &quot;blue&quot;, `8` = &quot;green&quot;) subplot( add_markers(p, color = ~factor(cyl), colors = col1), add_markers(p, color = ~factor(cyl), colors = col2), add_markers(p, color = ~factor(cyl), colors = col3) ) %&gt;% hide_legend() FIGURE 4.8: Three variations on a discrete color mapping. As introduced in Figure 3.3, color codes can be specified manually (i.e., avoid mapping data values to a visual range) by using the I() function. Figure 4.9 provides a simple example using add_markers(). Any color understood by the col2rgb() function from the grDevices package can be used in this way. Chapter 31 provides even more details about working with different color specifications when specifying colors manually. add_markers(p, color = I(&quot;black&quot;)) FIGURE 4.9: Setting a fixed color directly using I(). The color argument is meant to control the ‚Äòfill-color‚Äô of a geometric object, whereas stroke (section 4.1.4) is meant to control the ‚Äòoutline-color‚Äô of a geometric object. In the case of add_markers(), than means color maps to the plotly.js attribute marker.color and stroke maps to marker.line.color. Not all, but many, marker symbols have a notion of stroke. 4.1.3 Symbols The symbol argument can be used to map data values to the marker.symbol plotly.js attribute. It uses the same semantics that we‚Äôve already seen for color: A numeric mapping generates trace. A discrete mapping generates multiple traces (one trace per category). The plural, symbols, can be used to specify the visual range for the mapping. Mappings are avoided entirely through I(). For example, the left panel of Figure 4.10 uses a numeric mapping and the right panel uses a discrete mapping. As a result, the left panel is linked to the first legend entry, whereas the right panel is linked to the bottom three legend entries. When plotting multiple traces and no color is specifed, the plotly.js colorway is applied (i.e., each trace will be rendered a different color). To set a fixed color, you can set the color of every trace generated from this layer with color = I(\"black\"), or similar. p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.3) subplot( add_markers(p, symbol = ~cyl, name = &quot;A single trace&quot;), add_markers(p, symbol = ~factor(cyl), color = I(&quot;black&quot;)) ) FIGURE 4.10: Mapping symbol to a numeric variable (left panel) and a factor (right panel). There are two ways to specify the visual range of symbols: (1) numeric codes (interpreted as a pch codes) or (2) a character string specifying a valid marker.symbol value. Figure 4.11 uses pch codes (left panel) as well as their corresponding marker.symbol name (right panel) to specify the visual range. subplot( add_markers(p, symbol = ~cyl, symbols = c(17, 18, 19)), add_markers(p, symbol = ~factor(cyl), symbols = c(&quot;triangle-up&quot;, &quot;diamond&quot;, &quot;circle&quot; ), color = I(&quot;black&quot;)) ) FIGURE 4.11: Specifying the visual range of symbols. These symbols (i.e., the visual range) can also be supplied directly to symbol through I(). For example, Figure 4.12 fixes the marker symbol to a diamond shape. plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(symbol = I(18), alpha = 0.5) FIGURE 4.12: Setting a fixed symbol directly using I(). If you‚Äôd like to see all the symbols available to plotly, as well as a method for supplying your own custom glyphs, see Chapter 32. 4.1.4 Stroke and span The stroke argument follows the same semantics as color and symbol when it comes to variable mappings and specifying visual ranges. Typically you don‚Äôt want to map data values to stroke, you just want to specify a fixed outline color. For example, Figure 4.13 modifies Figure 4.12 to simply add a black outline. By default, the span, or width of the stroke, is zero, you‚Äôll likely want to set the width to be around one pixel. plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(symbol = I(18), alpha = 0.5, stroke = I(&quot;black&quot;), span = I(1)) FIGURE 4.13: Using stroke and span to control the outline color as well as the width of that outline. 4.1.5 Size For scatterplots, the size argument controls the area of markers (unless otherwise specified via sizemode), and must be a numeric variable. The sizes argument controls the minimum and maximum size of circles, in pixels: p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.3) subplot( add_markers(p, size = ~cyl, name = &quot;default&quot;), add_markers(p, size = ~cyl, sizes = c(1, 500), name = &quot;custom&quot;) ) FIGURE 4.14: Controlling the size range via sizes (measured in pixels). Similar to other arguments, I() can be used to specify the size directly. In the case of markers, size controls the marker.size plotly.js attribute. Remember, you always have the option to set this attribute directly by doing something similar to Figure 4.15. plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.3, marker = list(size = 10)) FIGURE 4.15: Setting a fixed marker size directly using marker.size. 4.1.6 Dotplots &amp; error bars A dotplot is similar to a scatterplot, except instead of two numeric axes, one is categorical. The usual goal of a dotplot is to compare value(s) on a numerical scale over numerous categories. In this context, dotplots are preferable to pie charts since comparing position along a common scale is much easier than comparing angle or area (Cleveland and McGill 1984); (Bostock 2010). Furthermore, dotplots can be preferable to bar charts, especially when comparing values within a narrow range far away from 0 (Few 2006). Also, when presenting point estimates, and uncertainty associated with those estimates, bar charts tend to exaggerate the difference in point estimates, and lose focus on uncertainty (Messing 2012). A popular application for dotplots (with error bars) is the so-called ‚Äúcoefficient plot‚Äù for visualizing the point estimates of coefficients and their standard error. The coefplot() function in the coefplot package (Lander 2016) and the ggcoef() function in the GGally both produce coefficient plots for many types of model objects in R using ggplot2, which we can translate to plotly via ggplotly(). Since these packages use points and segments to draw the coefficient plots, the hover information is not the best, and it‚Äôd be better to use error objects. Figure 4.16 uses the tidy() function from the broom package (Robinson 2016) to obtain a data frame with one row per model coefficient, and produce a coefficient plot with error bars along the x-axis. library(broom) library(forcats) # Fit a full-factorial linear model m &lt;- lm(Sepal.Length ~ Sepal.Width * Petal.Length * Petal.Width, data = iris) # (1) get a tidy() data structure of covariate-level info (e.g., point estimate, standard error, etc) # (2) make sure term column is a factor ordered by the estimate # (3) plot estimate by term with an error bar for the standard error tidy(m) %&gt;% mutate(term = fct_reorder(term, estimate)) %&gt;% plot_ly(x = ~estimate, y = ~term) %&gt;% add_markers( error_x = ~list(value = std.error), color = I(&quot;black&quot;), hoverinfo = &quot;x&quot; ) FIGURE 4.16: A coefficient plot. 4.2 Lines Many of the same principles we learned about aesthetic mappings with respect to markers (Section 4.1) also apply to lines.10 Moreover, at the start of this chapter (namely Figure 4.2) we also learned how to use dplyr‚Äôs group_by() to ensure there is at least one geometry (in this case, line) per group. We also learned the difference between add_paths() and add_lines() ‚Äì the former draws lines according to row ordering whereas the latter draw them according to x. In this chapter, we‚Äôll learn about linetype/linetype, an aesthetic that applies to lines and polygons. We‚Äôll also discuss some other important chart types that can be implemented with add_paths(), add_lines(), and add_segments(). 4.2.1 Linetypes Generally speaking, it‚Äôs hard to perceive more than 8 different colors/linetypes/symbols in a given plot, so sometimes we have to filter data to use these effectively. Here we use the dplyr package to find the top 5 cities in terms of average monthly sales (top5), then effectively filter the original data to contain just these cities via semi_join(). As Figure 4.17 demonstrates, once we have the data filtered, mapping city to color or linetype is trivial. The color palette can be altered via the colors argument, and follows the same rules as scatterplots. The linetype palette can be altered via the linetypes argument, and accepts R‚Äôs lty values or plotly.js dash values. library(dplyr) top5 &lt;- txhousing %&gt;% group_by(city) %&gt;% summarise(m = mean(sales, na.rm = TRUE)) %&gt;% arrange(desc(m)) %&gt;% top_n(5) tx5 &lt;- semi_join(txhousing, top5, by = &quot;city&quot;) plot_ly(tx5, x = ~date, y = ~median) %&gt;% add_lines(linetype = ~city) FIGURE 4.17: Using color and/or linetype to differentiate groups of lines. If you‚Äôd like to control exactly which linetype is used to encode a particular data value, you can provide a named character vector, like in Figure 4.18. Note that this is similar to how we provided a discrete colorscale manually for markers in Figure 4.8. ltys &lt;- c( Austin = &quot;dashdot&quot;, `Collin County` = &quot;longdash&quot;, Dallas = &quot;dash&quot;, Houston = &quot;solid&quot;, `San Antonio` = &quot;dot&quot; ) plot_ly(tx5, x = ~date, y = ~median) %&gt;% add_lines(linetype = ~city, linetypes = ltys) FIGURE 4.18: Providing a named character vector to linetypes in order to control exactly what linetype gets mapped to which city. 4.2.2 Segments The add_segments() function essentially provides a way to connect two points [(x, y) to (xend, yend)] with a line. Segments form the building blocks for numerous useful chart types, including slopegraphs, dumbell charts, candlestick charts, and more. Slopegraphs and dumbell charts are useful for comparing numeric values across numerous categories. Candlestick charts are typically used for visualizing change in a financial asset over time. Segments can also provide a useful alternative to add_bars() (covered in Section 6), especially for animations. In particular, Figure 15.5 of Section 15.2 shows how implement an animated population pyramid using segments instead of bars. 4.2.2.1 Slopegraph The slope graph, made popular by Tufte (2001b), is a great way to compare the change in a measurement across numerous groups. This change could be along either a discrete or a continuous axis. For a continuous axis, the slopegraph could be thought of as a decomposition of a line graph into multiple segments. The slopegraph R package provides a succinct interface for creating slopegraphs with base or ggplot2 graphics and also some convenient data sets which we‚Äôll make use of here (Leeper 2017). Figure 4.19 recreates an example from Tufte (2001b), using the gdp data set from slopegraph, and demonstrates a common issue with labelling in slopegraphs ‚Äì it‚Äôs easy to have overlapping labels when anchoring labels on data values. For that reason, this implementation leverages plotly ability to interactively edit annotation positions. See Section 13 for similar examples of ‚Äòediting views‚Äô. Click to show code data(gdp, package = &quot;slopegraph&quot;) gdp$Country &lt;- row.names(gdp) plot_ly(gdp) %&gt;% add_segments( x = 1, xend = 2, y = ~Year1970, yend = ~Year1979, color = I(&quot;gray90&quot;) ) %&gt;% add_annotations( x = 1, y = ~Year1970, text = ~paste(Country, &quot; &quot;, Year1970), xanchor = &quot;right&quot;, showarrow = FALSE ) %&gt;% add_annotations( x = 2, y = ~Year1979, text = ~paste(Year1979, &quot; &quot;, Country), xanchor = &quot;left&quot;, showarrow = FALSE ) %&gt;% layout( title = &quot;Current Receipts of Goverment as a Percentage of Gross Domestic Product&quot;, showlegend = FALSE, xaxis = list( range = c(0, 3), ticktext = c(&quot;1970&quot;, &quot;1979&quot;), tickvals = c(1, 2), zeroline = FALSE ), yaxis = list( title = &quot;&quot;, showgrid = FALSE, showticks = FALSE, showticklabels = FALSE ) ) %&gt;% config(edits = list(annotationPosition = TRUE)) FIGURE 4.19: Interactively editing the label positioning in a slopegraph. 4.2.2.2 Dumbell So called dumbell charts are similar in concept to slope graphs, but not quite as general. They are typically used to compare two different classes of numeric values across numerous groups. Figure 4.20 uses the dumbell approach to show average miles per gallon city and highway for different car models. With a dumbell chart, it‚Äôs always a good idea to order the categories by a sensible metric ‚Äì for Figure 4.20, the categories are ordered by the city miles per gallon. mpg %&gt;% group_by(model) %&gt;% summarise(c = mean(cty), h = mean(hwy)) %&gt;% mutate(model = forcats::fct_reorder(model, c)) %&gt;% plot_ly() %&gt;% add_segments( x = ~c, y = ~model, xend = ~h, yend = ~model, color = I(&quot;gray&quot;), showlegend = FALSE ) %&gt;% add_markers( x = ~c, y = ~model, color = I(&quot;blue&quot;), name = &quot;mpg city&quot; ) %&gt;% add_markers( x = ~h, y = ~model, color = I(&quot;red&quot;), name = &quot;mpg highway&quot; ) %&gt;% layout(xaxis = list(title = &quot;Miles per gallon&quot;)) FIGURE 4.20: A dumbell chart of mile per gallon city vs highway by model of car. 4.2.2.3 Candlestick Figure 4.21 uses the quantmod package (Ryan 2016) to obtain stock price data for Microsoft and plots two segments for each day: one to encode the opening/closing values, and one to encode the daily high/low. library(quantmod) msft &lt;- getSymbols(&quot;MSFT&quot;, auto.assign = F) dat &lt;- as.data.frame(msft) dat$date &lt;- index(msft) dat &lt;- subset(dat, date &gt;= &quot;2016-01-01&quot;) names(dat) &lt;- sub(&quot;^MSFT\\\\.&quot;, &quot;&quot;, names(dat)) plot_ly(dat, x = ~date, xend = ~date, color = ~Close &gt; Open, colors = c(&quot;red&quot;, &quot;forestgreen&quot;), hoverinfo = &quot;none&quot;) %&gt;% add_segments(y = ~Low, yend = ~High, size = I(1)) %&gt;% add_segments(y = ~Open, yend = ~Close, size = I(3)) %&gt;% layout(showlegend = FALSE, yaxis = list(title = &quot;Price&quot;)) %&gt;% rangeslider() FIGURE 4.21: A candlestick chart built out of segments 4.2.3 Density plots In Section 6, we leverage a number of algorithms in R for computing the ‚Äúoptimal‚Äù number of bins for a histogram, via hist(), and routing those results to add_bars(). We can leverage the density() function for computing kernel density estimates in a similar way, and route the results to add_lines(), as is done in 4.22. kerns &lt;- c(&quot;gaussian&quot;, &quot;epanechnikov&quot;, &quot;rectangular&quot;, &quot;triangular&quot;, &quot;biweight&quot;, &quot;cosine&quot;, &quot;optcosine&quot;) p &lt;- plot_ly() for (k in kerns) { d &lt;- density(economics$pce, kernel = k, na.rm = TRUE) p &lt;- add_lines(p, x = d$x, y = d$y, name = k) } p FIGURE 4.22: Various kernel density estimates. 4.2.4 Parallel Coordinates One very useful, but often overlooked, visualization technique is the parallel coordinates plot. Parallel coordinates provide a way to compare values along a common (or non-aligned) positional scale(s) ‚Äì the most basic of all perceptual tasks ‚Äì in more than 3 dimensions (Cleveland and McGill 1984). Usually each line represents every measurement for a given row (or observation) in a data set. It‚Äôs true that plotly.js provides a trace type, parcoords, specifically for parallel coordinates, but When measurements are on very different scales, some care must be taken, and variables must transformed to be put on a common scale. As Figure 4.23 shows, even when variables are measured on a similar scale, it can still be informative to transform variables in different ways. iris$obs &lt;- seq_len(nrow(iris)) iris_pcp &lt;- function(transform = identity) { iris[] &lt;- purrr::map_if(iris, is.numeric, transform) tidyr::gather(iris, variable, value, -Species, -obs) %&gt;% group_by(obs) %&gt;% plot_ly(x = ~variable, y = ~value, color = ~Species) %&gt;% add_lines(alpha = 0.3) } subplot( iris_pcp(), iris_pcp(scale), iris_pcp(scales::rescale), nrows = 3, shareX = TRUE ) %&gt;% hide_legend() FIGURE 4.23: Parallel coordinates plots of the Iris dataset. The top panel shows all variables on a common scale. The middle panel scales each variable to have mean of 0 and standard deviation of 1. In the bottom panel, each variable is scaled to have a minimum of 0 and a maximum of 1. It is also worth noting that the GGally offers a ggparcoord() function which creates parallel coordinate plots via ggplot2, which we can convert to plotly via ggplotly(). Thanks to the linked highlighting framework, parallel coordinates created in this way could be linked to lower dimensional (but sometimes higher resolution) graphics of related data to guide multi-variate data exploration. The pedestrians package provides some examples of linking parallel coordinates to other views such as a grand tour for exposing unusual features in a high-dimensional space (Sievert 2019a). 4.3 Polygons The add_polygons() function is essentially equivalent to add_paths() with the fill attribute set to ‚Äútoself‚Äù. Polygons form the basis for other, higher-level scatter-based layers (e.g., add_ribbons() and add_sf()) that don‚Äôt have a dedicated plotly.js trace type. Polygons can be use to draw many things, but perhaps the most familiar application where you might want to use add_polygons() is to draw geo-spatial objects. If and when you use add_polygons() to draw a map, make sure you fix the aspect ratio (e.g. xaxis.scaleanchor). On the other hand, Section 5.2 shows you how to make a custom maps using the sf package and add_sf(), which is a bit a work to get started, but is absolutely worth the investment. base &lt;- map_data(&quot;world&quot;, &quot;canada&quot;) %&gt;% group_by(group) %&gt;% plotly_empty(x = ~long, y = ~lat, alpha = 0.2) %&gt;% layout(showlegend = FALSE, xaxis = list(scaleanchor = &quot;y&quot;)) base %&gt;% add_polygons(hoverinfo = &quot;none&quot;, color = I(&quot;black&quot;)) %&gt;% add_markers(text = ~paste(name, &quot;&lt;br /&gt;&quot;, pop), hoverinfo = &quot;text&quot;, color = I(&quot;red&quot;), data = maps::canada.cities) FIGURE 4.24: Using add_polygons() to make a map of Canada and major Canadian cities via data provided by the maps package (Richard A. Becker, Ray Brownrigg. Enhancements by Thomas P Minka, and Deckmyn. 2018). As discussion surrounding Figure 5.9 points out, scatter-based polygon layers (i.e., add_polygons(), add_ribbons(), etc) render all the polygons using one plotly.js trace by default. This approach is computationally efficient, but it‚Äôs not always desirable (e.g. can‚Äôt have multiple fills per trace, interactivity is relatively limited). To work around the limitations, consider using split (or color with a discrete variable) to split the polygon data into multiple traces. Figure 4.25 demonstrates using split which will impose plotly.js‚Äô colorway to each trace (i.e., subregion) and leverage hoveron to generate one tooltip per sub-region. add_polygons(base, split = ~subregion, hoveron = &quot;fills&quot;) FIGURE 4.25: Using split to render polygons with different fills and interactive properties. 4.3.1 Ribbons Ribbons are useful for showing uncertainty bounds as a function of x. The add_ribbons() function creates ribbons and requires the arguments: x, ymin, and ymax. The augment() function from the broom package appends observational-level model components (e.g., fitted values stored as a new column .fitted) which is useful for extracting those components in a convenient form for visualization. Figure 4.26 shows the fitted values and uncertainty bounds from a linear model object. m &lt;- lm(mpg ~ wt, data = mtcars) broom::augment(m) %&gt;% plot_ly(x = ~wt, showlegend = FALSE) %&gt;% add_markers(y = ~mpg, color = I(&quot;black&quot;)) %&gt;% add_ribbons(ymin = ~.fitted - 1.96 * .se.fit, ymax = ~.fitted + 1.96 * .se.fit, color = I(&quot;gray80&quot;)) %&gt;% add_lines(y = ~.fitted, color = I(&quot;steelblue&quot;)) FIGURE 4.26: Plotting fitted values and uncertainty bounds of a linear model via the broom package. References "],
["maps.html", "5 Maps 5.1 Integrated maps 5.2 Custom maps", " 5 Maps There are numerous ways to make a map with plotly ‚Äì each with it‚Äôs own strengths and weaknesses. Generally speaking the approaches fall under two categories: integrated or custom. Integrated maps leverage plotly.js‚Äô built-in support for rendering a basemap layer. Currently there are two supported ways of making integrated maps: either via Mapbox or via an integrated d3.js powered basemap. The integrated approach is convenient if you need a quick map and don‚Äôt necessarily need sophisticated representations of geo-spatial objects. On the other hand, the custom mapping approach offers complete control since you‚Äôre providing all the information necessary to render the geo-spatial object(s). Section 5.2 covers making sophisticated maps (e.g., cartograms) using the sf R package, but it‚Äôs also possible to make custom plotly maps via other tools for geo-computing (e.g., sp, ggmap, etc). 5.1 Integrated maps 5.1.1 Overview If you have fairly simple latitude/longitude data and want to make a quick map, you may want to try one of plotly‚Äôs integrated mapping options (i.e., plot_mapbox() and plot_geo()). Generally speaking, you can treat these constructor functions as a drop-in replacement for plot_ly() and get a dynamic basemap rendered behind your data. Furthermore, all the scatter-based layers we learned about in Section 4 work as you‚Äôd expect it to with plot_ly().11 For example, Figure 5.1 uses plot_mapbox() and add_markers() to create a bubble chart: plot_mapbox(maps::canada.cities) %&gt;% add_markers( x = ~long, y = ~lat, size = ~pop, color = ~country.etc, colors = &quot;Accent&quot;, text = ~paste(name, pop), hoverinfo = &quot;text&quot; ) FIGURE 5.1: A mapbox powered bubble chart showing the population of various cities in Canada. The Mapbox basemap styling is controlled through the layout.mapbox.style attribute. The plotly package comes with support for 7 different styles, but you can also supply a custom URL to a custom mapbox style. To obtain all the pre-packaged basemap style names, you can grab them from the official plotly.js schema(): styles &lt;- schema()$layout$layoutAttributes$mapbox$style$values styles #&gt; [1] &quot;basic&quot; &quot;streets&quot; &quot;outdoors&quot; #&gt; [4] &quot;light&quot; &quot;dark&quot; &quot;satellite&quot; #&gt; [7] &quot;satellite-streets&quot; Any one of these values can be used for a mapbox style. Figure 5.2 demonstrates the satellite earth imagery basemap. layout( plot_mapbox(), mapbox = list(style = &quot;satellite&quot;) ) FIGURE 5.2: Zooming in on earth satellite imagery using plot_mapbox(). Figure 5.3 demonstrates how to create an integrated plotly.js dropdown menu to control the basemap style via the layout.updatemenus attribute. The idea behind an integrated plotly.js dropdown is to supply a list of buttons (i.e., menu items) where each button invokes a plotly.js method with some arguments. In this case, each button uses the relayout method to modify the layout.mapbox.style attribute.12 style_buttons &lt;- lapply(styles, function(s) { list(label = s, method = &quot;relayout&quot;, args = list(&quot;mapbox.style&quot;, s)) }) layout( plot_mapbox(), mapbox = list(style = &quot;dark&quot;), updatemenus = list( list(y = 0.8, buttons = style_buttons) ) ) FIGURE 5.3: Providing a dropdown menu to control the styling of the mapbox baselayer. The other integrated mapping solution in plotly is plot_geo(). Compared to plot_mapbox(), this approach has support for different mapping projections, but styling the basemap is limited and can be more cumbersome. Figure 5.4 demonstrates using plot_geo() in conjunction with add_markers() and add_segments() to visualize flight paths within the United States. Whereas plot_mapbox() is fixed to a mercator projection, the plot_geo() constructor has a handful of different projection available to it, including the orthographic projection which gives the illusion of the 3D globe. Click to show code library(plotly) library(dplyr) # airport locations air &lt;- read.csv(&#39;https://raw.githubusercontent.com/plotly/datasets/master/2011_february_us_airport_traffic.csv&#39;) # flights between airports flights &lt;- read.csv(&#39;https://raw.githubusercontent.com/plotly/datasets/master/2011_february_aa_flight_paths.csv&#39;) flights$id &lt;- seq_len(nrow(flights)) # map projection geo &lt;- list( projection = list( type = &#39;orthographic&#39;, rotation = list(lon = -100, lat = 40, roll = 0) ), showland = TRUE, landcolor = toRGB(&quot;gray95&quot;), countrycolor = toRGB(&quot;gray80&quot;) ) plot_geo(color = I(&quot;red&quot;)) %&gt;% add_markers( data = air, x = ~long, y = ~lat, text = ~airport, size = ~cnt, hoverinfo = &quot;text&quot;, alpha = 0.5 ) %&gt;% add_segments( data = group_by(flights, id), x = ~start_lon, xend = ~end_lon, y = ~start_lat, yend = ~end_lat, alpha = 0.3, size = I(1), hoverinfo = &quot;none&quot; ) %&gt;% layout(geo = geo, showlegend = FALSE) FIGURE 5.4: A mapbox powered bubble chart showing the population of various cities in Canada. One nice thing about plot_geo() is that it automatically projects geometries into the proper coordinate system defined by the map projection. For example, in Figure 5.5 the simple line segment is straight when using plot_mapbox() yet curved when using plot_geo(). It‚Äôs possible to acheive the same effect using plot_ly() or plot_mapbox(), but the relevant marker/line/polygon data has to be put into an sf data structure before rendering (see Section 5.2.1 for more details). map1 &lt;- plot_mapbox() %&gt;% add_segments(x = -100, xend = -50, y = 50, yend = 75) %&gt;% layout( mapbox = list( zoom = 0, center = list(lat = 65, lon = -75) ) ) map2 &lt;- plot_geo() %&gt;% add_segments(x = -100, xend = -50, y = 50, yend = 75) %&gt;% layout(geo = list(projection = list(type = &quot;mercator&quot;))) library(htmltools) browsable(tagList(map1, map2)) FIGURE 5.5: Three different ways to render a map. On the top left is plotly‚Äôs default cartesian coordinate system, on the top right is plotly‚Äôs custom geographic layout, and on the bottom is mapbox. 5.1.2 Choropleths In addition to scatter-based layers, the plot_geo() constructor also supports a choropleth layer. Figure 5.6 shows the population density of the U.S. via a choropleth, and also layers on markers for the state center locations, using the U.S. state data from the datasets package (R Core Team 2016). By simply providing a z attribute, plotly_geo() objects will try to create a choropleth, but you‚Äôll also need to provide locations and a locationmode. It‚Äôs worth noting that the locationmode is currently limited to countries and US states, so if you need to a different geo-unit (e.g., counties, muncipalities, etc), you can use the the custom mapping approach discussed in Section 5.2. density &lt;- state.x77[, &quot;Population&quot;] / state.x77[, &quot;Area&quot;] g &lt;- list( scope = &#39;usa&#39;, projection = list(type = &#39;albers usa&#39;), lakecolor = toRGB(&#39;white&#39;) ) plot_geo() %&gt;% add_trace( z = ~density, text = state.name, span = I(0), locations = state.abb, locationmode = &#39;USA-states&#39; ) %&gt;% layout(geo = g) FIGURE 5.6: A map of U.S. population density using the state.x77 data from the datasets package. Figure 5.6 helps illuminate a problem with choropleths from a graphical perception point of view. We typically use the color in choropleths to encode a numeric variable (e.g., GDP, net exports, average SAT score, etc) and the eye naturally perceives the area that a particular color covers as proportional to its overall effect. This ends up being misleading since the area the color covers typically has no sensible relationship with the data encoded by the color. A classic example of this misleading effect in action is in US election maps ‚Äì the proportion of red to blue coloring is not representative of the overall popular vote (Newman 2016). Cartograms are an approach to reducing this misleading effect and grants another dimension to encode data through the size of geo-spatial features. Section 5.2.2 covers how to render cartograms in plotly using sf and cartogram. 5.2 Custom maps 5.2.1 Simple features (sf) The sf R package is a modern approach to working with geo-spatial data structures based on tidy data principles (Pebesma 2018); (Wickham 2014b). The key idea behind sf is that it stores geo-spatial geometries in a list-column of a data frame. This allows each row to represent the real unit of observation/interest ‚Äì whether it‚Äôs a polygon, multi-polygon, point, line, or even a collection of these features ‚Äì and as a result, works seamlessly inside larger tidy workflows.13 The sf package itself does not really provide geo-spatial data ‚Äì it provides the framework and utilties for storing and computing on geo-spatial data structures in an opinionated way. There are numerous packages for accessing geo-spatial data as simple features data structures. A couple notable examples include rnaturalearth and USAboundaries. The rnaturalearth package is better for obtaining any map data in the world via an API provided by https://www.naturalearthdata.com/ (South 2017). The USAboundaries package is great for obtaining map data for the United States at any point in history (Mullen and Bratt 2018). It doesn‚Äôt really matter what tool you use to obtain or create an sf object ‚Äì once you have one, plot_ly() knows how to render it: library(rnaturalearth) world &lt;- ne_countries(returnclass = &quot;sf&quot;) class(world) #&gt; [1] &quot;sf&quot; &quot;data.frame&quot; plot_ly(world, color = I(&quot;gray90&quot;), stroke = I(&quot;black&quot;), span = I(1)) FIGURE 5.7: Rendering all the world‚Äôs countries using plot_ly() and the ne_countries() function from the rnaturalearth package. How does plot_ly() know how to render the countries? It‚Äôs because the geo-spatial features are encoded in special (geometry) list-column. Also, meta-data about the geo-spatial structure are retained as special attributes of the data. Figure 5.8 augments the print method for sf to data frames to demonstrate that all the information needed to render the countries (i.e., polygons) in Figure 5.7 is contained within the world data frame. Note also, that sf provides special dplyr methods for this special class of data frame so that you can treat data manipulations as if it were a ‚Äòtidy‚Äô data structure. One thing about this method is that the special ‚Äògeometry‚Äô column is always retained ‚Äì if we try to just select the name column, then we get both the name and the geometry. library(sf) world %&gt;% select(name) %&gt;% print(n = 4) FIGURE 5.8: A diagram of a simple features data frame. The geometry column tracks the spatial features attached to each row in the data frame. There are actually 4 different ways to render sf objects with plotly: plot_ly(), plot_mapbox(), plot_geo(), and via ggplot2‚Äôs geom_sf(). These functions render multiple polygons using a single trace by default, which is fast, but you may want to leverage the added flexibility of multiple traces. For example, a given trace can only have one fillcolor, so it‚Äôs impossible to render multiple polygons with different colors using a single trace. For this reason, if you want to vary the color of multiple polygons, make sure the split by a unique identifier (e.g. name), as done in Figure 5.9. Note that, as discussed for line charts in Figure 4.2, using multiple traces automatically adds the ability to filter name via legend entries. canada &lt;- ne_states(country = &quot;Canada&quot;, returnclass = &quot;sf&quot;) plot_ly(canada, split = ~name, color = ~provnum_ne) FIGURE 5.9: Using split and color to create a choropleth map of provinces in Canada. Another important feature for maps that may require you to split multiple polygons into multiple traces is the ability to display a different hover-on-fill for each polygon. By providing text that is unique within each polygon and specifying hoveron='fills', the tooltip behavior is tied to the trace‚Äôs fill (instead of displayed at each point along the polygon). plot_ly( canada, split = ~name, color = I(&quot;gray90&quot;), text = ~paste(name, &quot;is \\n province number&quot;, provnum_ne), hoveron = &quot;fills&quot;, hoverinfo = &quot;text&quot;, showlegend = FALSE ) FIGURE 5.10: Using split, text, and hoveron='fills' to display a tooltip specific to each Canadian province. Although the integrated mapping approaches (plot_mapbox() and plot_geo()) can render sf objects, the custom mapping approaches (plot_ly() and geom_sf()) are more flexible because they allow for any well-defined mapping projection. Working with and understanding map projections can be intimatidating for a causal map maker. Thankfully, there are nice resources for searching map projections in a human-friendly interface, like http://spatialreference.org/. Through this website, one can search desirable projections for a given portion of the globe and extract commands for projecting their geo-spatial objects into that projection. One way way to perform the projection is to supply the relevant PROJ4 command to the st_transform() function in sf (PROJ contributors 2018). # filter the world sf object down to canada canada &lt;- filter(world, name == &quot;Canada&quot;) # coerce cities lat/long data to an official sf object cities &lt;- st_as_sf( maps::canada.cities, coords = c(&quot;long&quot;, &quot;lat&quot;), crs = 4326 ) # A PROJ4 projection designed for Canada # http://spatialreference.org/ref/sr-org/7/ # http://spatialreference.org/ref/sr-org/7/proj4/ moll_proj &lt;- &quot;+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs&quot; # perform the projections canada &lt;- st_transform(canada, moll_proj) cities &lt;- st_transform(cities, moll_proj) # plot with geom_sf() p &lt;- ggplot() + geom_sf(data = canada) + geom_sf(data = cities, aes(size = pop), color = &quot;red&quot;, alpha = 0.3) ggplotly(p) FIGURE 5.11: The population of various Canadian cities rendered on a custom basemap using a Mollweide projection. Some geo-spatial objects have an unnecessarily high resolution for a given visualization. In these cases, you may want to consider simplifying the geo-spatial object to improve the speed of the R code and responsiveness of the visualization. For example, we could recreate Figure 5.7 with a much higher resolution by specifying scale = \"large\" in ne_countries() this gives us a sf object with over 50 times more spatial coordinates than the default scale. The higher resolution allows us to zoom in better on more complex geo-spatial regions, but it allow leads to slower R code, larger HTML files, and slower responsiveness. Sievert (2018b) explores this issue in more depth and demonstrates how to use the st_simplify() function from sf to simplify features before plotting them. sum(rapply(world$geometry, nrow)) #&gt; [1] 10586 world_large &lt;- ne_countries(scale = &quot;large&quot;, returnclass = &quot;sf&quot;) sum(rapply(world_large$geometry, nrow)) #&gt; [1] 548121 Analogous to the discussion surrounding 4.2, it pays to be aware of the tradeoffs involved with rendering plotly graphics using one or many traces, and knowledgable about how to leverage either approach. Specifically, by default, plotly attempts to render all simple features in a single trace, which is performant, but doesn‚Äôt have a lot of interactivity. plot_mapbox(world_large, color = NA, stroke = I(&quot;black&quot;), span = I(0.5)) For those interested in learning more about geocomputation in R with sf and other great R packages like sp and raster, Robin Lovelace (2019) provides lots of nice and freely available learning resources (Pebesma and Bivand 2005); (Hijmans 2019). 5.2.2 Cartograms Cartograms distort the size of geo-spatial polygons to encode a numeric variable other than the land size. There are numerous types of cartograms and they are typically categorized by their ability to perserve shape and maintain contingous regions. Cartograms has been shown to be an effective approach to both encode and teach about geo-spatial data, though the effects certainly vary by cartogram type (Nusrat S, Alam MJ, Kobourov S. 2018). The R package cartogram provides an interface to several popular cartogram algorithms (Jeworutzki 2018). A number of other R packages provide cartogram algorithms, but the great thing about cartogram is that all the functions can take an sf (or sp) object as input and return an sf object. This makes it incredibly easy to go from raw spatial objects, to transformed objects, to visual. Figure 5.12 demonstrates a continuous area cartogram of US population in 2014 using a rubber sheet distortion algorithm from Dougenik, J. A., Chrisman, N. R., &amp; Niemeyer, D. R. (1985). library(cartogram) library(albersusa) us_cont &lt;- cartogram_cont(usa_sf(&quot;laea&quot;), &quot;pop_2014&quot;) plot_ly(us_cont) %&gt;% add_sf( color = ~pop_2014, split = ~name, span = I(1), text = ~paste(name, scales::number_si(pop_2014)), hoverinfo = &quot;text&quot;, hoveron = &quot;fills&quot; ) %&gt;% layout(showlegend = FALSE) %&gt;% colorbar(title = &quot;Population \\n 2014&quot;) FIGURE 5.12: A cartogram of US population in 2014. A cartogram sizes the area of geo-spatial objects proportional to some metric (e.g., population). Figure 5.13 demonstrates a non-continuous Dorling cartogram of US population in 2014 from Dorling, D (1996). This cartogram does not try to preserve the shape of polygons (i.e., states), but instead uses circles instead to represent each geo-spatial object, then encodes the variable of interest (i.e., population) using the area of the circle. us &lt;- usa_sf(&quot;laea&quot;) us_dor &lt;- cartogram_dorling(us, &quot;pop_2014&quot;) plot_ly(stroke = I(&quot;black&quot;), span = I(1)) %&gt;% add_sf( data = us, color = I(&quot;gray95&quot;), hoverinfo = &quot;none&quot; ) %&gt;% add_sf( data = us_dor, color = ~pop_2014, split = ~name, text = ~paste(name, scales::number_si(pop_2014)), hoverinfo = &quot;text&quot;, hoveron = &quot;fills&quot; ) %&gt;% layout(showlegend = FALSE) FIGURE 5.13: A dorling cartogram of US population in 2014. A dorling cartogram sizes the circles proportional to some metric (e.g., population). Figure 5.14 demonstrates a non-continuous cartogram of US population in 2014 from Olson, J. M. (1976). In contrast to the Dorling cartogram, this approach does preserve the shape of polygons. The implementation behind Figure 5.14 is to simply take the implementation of Figure 5.13 and change cartogram_dorling() to cartogram_ncont(). FIGURE 5.14: A non-continguous cartogram of US population in 2014 that preserves shape. A popular class of contiguous cartograms that do not preserve shape are sometimes referred to as tile catograms (aka tilegrams). At the time of writing, there doesn‚Äôt seem to be a great R package for computing tilegrams, but Pitch Interactive provides a nice web service where you can generate tilegrams from existing or custom data https://pitchinteractiveinc.github.io/tilegrams/. Moreover, the service allows you to download a TopoJSON file of the generated tilegram, which we can read in R and convert into an sf object via geojsonio (Chamberlain and Teucher 2018). Figure 5.15 demonstrates a tilegram of U.S. Population in 2016 exported directly from Pitch‚Äôs free web service. library(geojsonio) tiles &lt;- geojson_read(&quot;~/Downloads/tiles.topo.json&quot;, what = &quot;sp&quot;) tiles_sf &lt;- st_as_sf(tiles) plot_ly(tiles_sf, split = ~name) FIGURE 5.15: A tile cartogram of U.S. population in 2016. 5.2.3 Geo faceting https://ryanhafen.com/blog/geofacet/ References "],
["bars-histograms.html", "6 Bars &amp; histograms 6.1 Multiple numeric distributions 6.2 Multiple discrete distributions", " 6 Bars &amp; histograms The add_bars() and add_histogram() functions wrap the bar and histogram plotly.js trace types. The main difference between them is that bar traces require bar heights (both x and y), whereas histogram traces require just a single variable, and plotly.js handles binning in the browser.14 And perhaps confusingly, both of these functions can be used to visualize the distribution of either a numeric or a discrete variable. So, essentially, the only difference between them is where the binning occurs. Figure 6.1 compares the default binning algorithm in plotly.js to a few different algorithms available in R via the hist() function. Although plotly.js has the ability to customize histogram bins via xbins/ybins, R has diverse facilities for estimating the optimal number of bins in a histogram that we can easily leverage.15 The hist() function alone allows us to reference 3 famous algorithms by name (Sturges 1926); (Freedman and Diaconis 1981); (Scott 1979), but there are also packages (e.g. the histogram package) which extend this interface to incorporate more methodology (Mildenberger, Rozenholc, and Zasada. 2009). The price_hist() function below wraps the hist() function to obtain the binning results, and map those bins to a plotly version of the histogram using add_bars(). p1 &lt;- plot_ly(diamonds, x = ~price) %&gt;% add_histogram(name = &quot;plotly.js&quot;) price_hist &lt;- function(method = &quot;FD&quot;) { h &lt;- hist(diamonds$price, breaks = method, plot = FALSE) plot_ly(x = h$mids, y = h$counts) %&gt;% add_bars(name = method) } subplot( p1, price_hist(), price_hist(&quot;Sturges&quot;), price_hist(&quot;Scott&quot;), nrows = 4, shareX = TRUE ) FIGURE 6.1: plotly.js‚Äôs default binning algorithm versus R‚Äôs hist() default Figure 6.2 demonstrates two ways of creating a basic bar chart. Although the visual results are the same, its worth noting the difference in implementation. The add_histogram() function sends all of the observed values to the browser and lets plotly.js perform the binning. It takes more human effort to perform the binning in R, but doing so has the benefit of sending less data, and requiring less computation work of the web browser. In this case, we have only about 50,000 records, so there is not much of a difference in page load times or page size. However, with 1 Million records, page load time more than doubles and page size nearly doubles.16 p1 &lt;- plot_ly(diamonds, x = ~cut) %&gt;% add_histogram() p2 &lt;- diamonds %&gt;% dplyr::count(cut) %&gt;% plot_ly(x = ~cut, y = ~n) %&gt;% add_bars() subplot(p1, p2) %&gt;% hide_legend() FIGURE 6.2: Number of diamonds by cut. 6.1 Multiple numeric distributions It is often useful to see how the numeric distribution changes with respect to a discrete variable. When using bars to visualize multiple numeric distributions, I recommend plotting each distribution on its own axis, rather than trying to overlay them on a single axis.17. This is where the subplot() infrastructure, and its support for trellis displays, comes in handy. Figure 6.3 shows a trellis display of diamond price by diamond color. Note how the one_plot() function defines what to display on each panel, then a split-apply-recombine strategy is employed to generate the trellis display. one_plot &lt;- function(d) { plot_ly(d, x = ~price) %&gt;% add_annotations( ~unique(clarity), x = 0.5, y = 1, xref = &quot;paper&quot;, yref = &quot;paper&quot;, showarrow = FALSE ) } diamonds %&gt;% split(.$clarity) %&gt;% lapply(one_plot) %&gt;% subplot(nrows = 2, shareX = TRUE, titleX = FALSE) %&gt;% hide_legend() FIGURE 6.3: A trellis display of diamond price by diamond clarity. 6.2 Multiple discrete distributions Visualizing multiple discrete distributions is difficult. The subtle complexity is due to the fact that both counts and proportions are important for understanding multi-variate discrete distributions. Figure 6.4 presents diamond counts, divided by both their cut and clarity, using a grouped bar chart. plot_ly(diamonds, x = ~cut, color = ~clarity) %&gt;% add_histogram() FIGURE 6.4: A grouped bar chart Figure 6.4 is useful for comparing the number of diamonds by clarity, given a type of cut. For instance, within ‚ÄúIdeal‚Äù diamonds, a cut of ‚ÄúVS1‚Äù is most popular, ‚ÄúVS2‚Äù is second most popular, and ‚ÄúI1‚Äù the least popular. The distribution of clarity within ‚ÄúIdeal‚Äù diamonds seems to be fairly similar to other diamonds, but it‚Äôs hard to make this comparison using raw counts. Figure 6.5 makes this comparison easier by showing the relative frequency of diamonds by clarity, given a cut. # number of diamonds by cut and clarity (n) cc &lt;- count(diamonds, cut, clarity) # number of diamonds by cut (nn) cc2 &lt;- left_join(cc, count(cc, cut, wt = n)) cc2 %&gt;% mutate(prop = n / nn) %&gt;% plot_ly(x = ~cut, y = ~prop, color = ~clarity) %&gt;% add_bars() %&gt;% layout(barmode = &quot;stack&quot;) FIGURE 6.5: A stacked bar chart showing the proportion of diamond clarity within cut. This type of plot, also known as a spine plot, is a special case of a mosaic plot. In a mosaic plot, you can scale both bar widths and heights according to discrete distributions. For mosaic plots, I recommend using the ggmosaic package (Jeppson, Hofmann, and Cook 2016), which implements a custom ggplot2 geom designed for mosaic plots, which we can convert to plotly via ggplotly(). Figure 6.6 shows a mosaic plot of cut by clarity. Notice how the bar widths are scaled proportional to the cut frequency. library(ggmosaic) p &lt;- ggplot(data = cc) + geom_mosaic(aes(weight = n, x = product(cut), fill = clarity)) ggplotly(p) FIGURE 6.6: Using ggmosaic and ggplotly() to create advanced interactive visualizations of categorical data References "],
["boxplots.html", "7 Boxplots", " 7 Boxplots Boxplots encode the five number summary of a numeric variable, and are more efficient than trellis displays of histograms for comparing many numeric distributions. The add_boxplot() function requires one numeric variable, and guarantees boxplots are oriented correctly, regardless of whether the numeric variable is placed on the x or y scale. As Figure 7.1 shows, on the axis orthogonal to the numeric axis, you can provide a discrete variable (for conditioning) or supply a single value (to name the axis category). p &lt;- plot_ly(diamonds, y = ~price, color = I(&quot;black&quot;), alpha = 0.1, boxpoints = &quot;suspectedoutliers&quot;) p1 &lt;- p %&gt;% add_boxplot(x = &quot;Overall&quot;) p2 &lt;- p %&gt;% add_boxplot(x = ~cut) subplot( p1, p2, shareY = TRUE, widths = c(0.2, 0.8), margin = 0 ) %&gt;% hide_legend() FIGURE 7.1: Overall diamond price and price by cut. If you want to partition by more than one discrete variable, I recommend mapping the interaction of those variables to the discrete axis, and coloring by the nested variable, as Figure 7.2 does with diamond clarity and cut. plot_ly(diamonds, x = ~price, y = ~interaction(clarity, cut)) %&gt;% add_boxplot(color = ~clarity) %&gt;% layout(yaxis = list(title = &quot;&quot;)) FIGURE 7.2: Diamond prices by cut and clarity. It is also helpful to sort the boxplots according to something meaningful, such as the median price. Figure 7.3 presents the same information as Figure 7.2, but sorts the boxplots by their median, and makes it immediately clear that diamonds with a cut of ‚ÄúSI2‚Äù have the highest diamond price, on average. d &lt;- diamonds %&gt;% mutate(cc = interaction(clarity, cut)) # interaction levels sorted by median price lvls &lt;- d %&gt;% group_by(cc) %&gt;% summarise(m = median(price)) %&gt;% arrange(m) %&gt;% pull(cc) plot_ly(d, x = ~price, y = ~factor(cc, lvls)) %&gt;% add_boxplot(color = ~clarity) %&gt;% layout(yaxis = list(title = &quot;&quot;)) FIGURE 7.3: Diamond prices by cut and clarity, sorted by price median. Similar to add_histogram(), add_boxplot() sends the raw data to the browser, and lets plotly.js compute summary statistics. Unfortunately, plotly.js does not yet allow precomputed statistics for boxplots.18 Follow the issue here https://github.com/plotly/plotly.js/issues/242‚Ü© "],
["frequencies-2D.html", "8 2D frequencies 8.1 Rectangular binning in plotly.js 8.2 Rectangular binning in R 8.3 Categorical axes", " 8 2D frequencies 8.1 Rectangular binning in plotly.js The plotly package provides two functions for displaying rectangular bins: add_heatmap() and add_histogram2d(). For numeric data, the add_heatmap() function is a 2D analog of add_bars() (bins must be pre-computed), and the add_histogram2d() function is a 2D analog of add_histogram() (bins can be computed in the browser). Thus, I recommend add_histogram2d() for exploratory purposes, since you don‚Äôt have to think about how to perform binning. It also provides a useful zsmooth attribute for effectively increasing the number of bins (currently, ‚Äúbest‚Äù performs a bi-linear interpolation, a type of nearest neighbors algorithm), and nbinsx/nbinsy attributes to set the number of bins in the x and/or y directions. Figure 8.1 compares three different uses of add_histogram(): (1) plotly.js‚Äô default binning algorithm, (2) the default plus smoothing, (3) setting the number of bins in the x and y directions. Its also worth noting that filled contours, instead of bins, can be used in any of these cases by using histogram2dcontour() instead of histogram2d(). p &lt;- plot_ly(diamonds, x = ~log(carat), y = ~log(price)) subplot( add_histogram2d(p) %&gt;% colorbar(title = &quot;default&quot;) %&gt;% layout(xaxis = list(title = &quot;default&quot;)), add_histogram2d(p, zsmooth = &quot;best&quot;) %&gt;% colorbar(title = &quot;zsmooth&quot;) %&gt;% layout(xaxis = list(title = &quot;zsmooth&quot;)), add_histogram2d(p, nbinsx = 60, nbinsy = 60) %&gt;% colorbar(title = &quot;nbins&quot;) %&gt;% layout(xaxis = list(title = &quot;nbins&quot;)), shareY = TRUE, titleX = TRUE ) FIGURE 8.1: Three different uses of histogram2d() 8.2 Rectangular binning in R In Bars &amp; histograms, we leveraged a number of algorithms in R for computing the ‚Äúoptimal‚Äù number of bins for a histogram, via hist(), and routing those results to add_bars(). There is a surprising lack of research and computational tools for the 2D analog, and among the research that does exist, solutions usually depend on characteristics of the unknown underlying distribution, so the typical approach is to assume a Gaussian form (Scott 1992). Practically speaking, that assumption is not very useful, but 2D kernel density estimation provides a useful alternative that tends to be more robust to changes in distributional form. Although kernel density estimation requires choice of kernel and a bandwidth parameter, the kde2d() function from the MASS package provides a well-supported rule-of-thumb for estimating the bandwidth of a Gaussian kernel density (Venables and Ripley 2002). Figure 8.2 uses kde2d() to estimate a 2D density, scales the relative frequency to an absolute frequency, then uses the add_heatmap() function to display the results as a heatmap. kde_count &lt;- function(x, y, ...) { kde &lt;- MASS::kde2d(x, y, ...) df &lt;- with(kde, setNames(expand.grid(x, y), c(&quot;x&quot;, &quot;y&quot;))) # The &#39;z&#39; returned by kde2d() is a proportion, # but we can scale it to a count df$count &lt;- with(kde, c(z) * length(x) * diff(x)[1] * diff(y)[1]) data.frame(df) } kd &lt;- with(diamonds, kde_count(log(carat), log(price), n = 30)) plot_ly(kd, x = ~x, y = ~y, z = ~count) %&gt;% add_heatmap() %&gt;% colorbar(title = &quot;Number of diamonds&quot;) FIGURE 8.2: 2D Density estimation via the kde2d() function 8.3 Categorical axes The functions add_histogram(), add_histogram2contour(), and add_heatmap() all support categorical axes. Thus, add_histogram() can be used to easily display 2-way contingency tables, but since its easier to compare values along a common scale rather than compare colors (Cleveland and McGill 1984), I recommend creating grouped bar charts instead. The add_heatmap() function can still be useful for categorical axes, however, as it allows us to display whatever quantity we want along the z axis (color). Figure 8.3 uses add_heatmap() to display a correlation matrix. Notice how the limits arguments in the colorbar() function can be used to expand the limits of the color scale to reflect the range of possible correlations (something that is not easily done in plotly.js). corr &lt;- cor(dplyr::select_if(diamonds, is.numeric)) plot_ly(x = rownames(corr), y = colnames(corr), z = corr, colors = &quot;RdBu&quot;) %&gt;% add_heatmap() %&gt;% colorbar(limits = c(-1, 1)) FIGURE 8.3: Displaying a correlation matrix with add_heatmap() and controling the scale limits with colorbar(). References "],
["d-charts.html", "9 3D charts", " 9 3D charts 9.0.1 Markers and lines As it turns out, by simply adding a z attribute plot_ly() will know how to render markers, lines, and paths in three dimensions. That means, all the techniques we learned in Sections 4.1 and 4.2 can re-used for 3D charts: plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_markers(color = ~cyl) FIGURE 9.1: A 3D scatterplot. 9.0.2 3D paths To make a path in 3D, use add_paths() in the same way you would for a 2D path, but add a third variable z, as Figure 9.2 does. plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_paths(color = ~displ) FIGURE 9.2: A path in 3D Figure 9.3 uses add_lines() instead of add_paths() to ensure the points are connected by the x axis instead of the row ordering. plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_lines(color = ~displ) FIGURE 9.3: A 3D line plot In scatter traces, we saw how to make 3D scatter plots and 3D paths/lines, but plotly.js also supports 3D surface and triangular mesh surfaces (aka trisurf plots). For a nice tutorial on creating trisurf plots in R via plot_ly(), I recommend visiting this tutorial. Creating 3D surfaces with add_surface() is a lot like creating heatmaps with add_heatmap(). In fact, you can even create 3D surfaces over categorical x/y (try changing add_heatmap() to add_surface() in Figure 8.3)! That being said, there should be a sensible ordering to the x/y axes in a surface plot since plotly.js interpolates z values. Usually the 3D surface is over a continuous region, as is done in Figure 9.4 to display the height of a volcano. If a numeric matrix is provided to z as in Figure 9.4, the x and y attributes do not have to be provided, but if they are, the length of x should match the number of columns in the matrix and y should match the number of rows. x &lt;- seq_len(nrow(volcano)) + 100 y &lt;- seq_len(ncol(volcano)) + 500 plot_ly() %&gt;% add_surface(x = ~x, y = ~y, z = ~volcano) FIGURE 9.4: A 3D surface of volcano height. "],
["introduction-1.html", "10 Introduction", " 10 Introduction This chapter shows you how to save and embed your plotly graphs within larger HTML documents, interactively edit (i.e., post-process) them, and export to static file formats ‚Äì all of which can be useful tools for creating ‚Äòpublication-quality‚Äô graphics. Static images can be created either from the command line (via the orca() function) or from the interactive graphic itself. The former is great if you need to export many images at once and the latter is convenient if you need to export a manually edited version of the default view (e.g., Figure 13.1). All the R code in this chapter runs entirely locally using 100% free and open source software with no calls to external services. "],
["saving-and-embedding-html.html", "11 Saving and embedding HTML", " 11 Saving and embedding HTML Any widget made from any htmlwidgets package (e.g., plotly, leaflet, DT, etc) can be saved as a standalone HTML file via the htmlwidgets::saveWidget() function. By default, it produces a completely self-contained HTML file, meaning that all the necessary JavaScript and CSS dependency files are bundled inside the HTML file. This makes it very easy to share a widget as a single HTML file. In this case, consider using the partial_bundle() function to reduce the size of the bundled files. By default, it automatically determines a reduced version of plotly.js that is sufficient for rendering your graphic. This can lead to a substantial reduction in the overall file size, especially if you‚Äôre using basic chart types: p &lt;- plot_ly(x = 1:10, y = 1:10) %&gt;% add_markers() widget_file_size &lt;- function(p) { d &lt;- tempdir() withr::with_dir(d, htmlwidgets::saveWidget(p, &quot;index.html&quot;)) f &lt;- file.path(d, &quot;index.html&quot;) mb &lt;- round(file.info(f)$size / 1e6, 3) message(&quot;File is: &quot;, mb,&quot; MB&quot;) } widget_file_size(p) #&gt; File is: 3.078 MB widget_file_size(partial_bundle(p)) #&gt; File is: 1.01 MB If you want to embed numerous widgets in a larger HTML document (e.g., via HTML &lt;iframe&gt;s), self-contained HTML is not recommended. That‚Äôs because, if you embed numerous self-contained widgets inside a larger document, your browser has to repeatedly parse the same dependencies over and over. Instead, if you save all the dependency files externally into a single directory, the browser will only have to parse those dependencies once, which can dramatically improve responsiveness. You can do this by setting selfcontained = FALSE and specifying a fixed libdir in saveWidget(). It‚Äôs also worth noting that using htmlwidgets::saveWidget() with selfcontained = FALSE is essentially the same as using htmltools::save_html() which saves arbitrary HTML content to a file. The htmltools::save_html() function is useful for saving numerous htmlwidgets (e.g., Figure 14.1) and/or other custom HTML markup (e.g., Figure 27.1) in a single HTML page. htmlwidgets::saveWidget(plot_ly(x = rnorm(100)), &quot;p1.html&quot;, selfcontained = FALSE, libdir = &quot;lib&quot;) htmlwidgets::saveWidget(plot_ly(x = rnorm(100)), &quot;p2.html&quot;, selfcontained = FALSE, libdir = &quot;lib&quot;) In this case, if you wanted to share \"p1.html\" and/or \"p2.html\" with someone else, make sure to include the libdir folder, perhaps via a zip file: zip(&quot;p1.zip&quot;, c(&quot;p1.html&quot;, &quot;lib&quot;)) zip(&quot;p2.zip&quot;, c(&quot;p2.html&quot;, &quot;lib&quot;)) Embedding these HTML files via an HTML &lt;iframe&gt; is convenient not only for re-using a widget in various parent documents, but also for preventing any JavaScript and CSS in the parent document from negatively impacting how the widget renders. Rather than writing the HTML &lt;iframe&gt; tag directly, I recommend using htmltools::tags$iframe() ‚Äì this will allow you to leverage bookdown‚Äôs figure captioning, numbering, and automatic snapshots for non-HTML output: ` ``{r} htmltools::tags$iframe( src = &quot;p1.html&quot;, scrolling = &quot;no&quot;, seamless = &quot;seamless&quot;, frameBorder = &quot;0&quot; ) ``` A great tool that helps automate this sort of workflow with responsive iframes is the widgetframe package (Karambelkar 2017). See the ‚Äòwidgetframe and knitr‚Äô vignette for documentation of options for controling where, how, and if external dependencies are stored on the file system when using it inside a knitr/rmarkdown document. browseVignettes(&quot;widgetframe&quot;) References "],
["exporting-static-images.html", "12 Exporting static images 12.1 With code 12.2 From a browser 12.3 Sizing exports", " 12 Exporting static images 12.1 With code Any plotly object can be saved as a static image via the orca() function. To use it, you‚Äôll need the orca command-line utility (CLI). This CLI can be installed via node.js, conda, or a standalone binary from https://github.com/plotly/orca/releases. Figure 12.1 demonstrates how orca() can generate a svg (or pdf) that can then be imported into Adobe Illustrator for post-processing. Although it‚Äôs a nice option to have, importing into Adobe Illustrator might not enable as nice of a workflow as using plotly‚Äôs native support for editable layout components in the browser, then exporting to svg/pdf (as shown in Figure 13.1). FIGURE 12.1: Using the orca() function to export a WebGL/Canvas based plotly graphic to a static pdf file. That pdf file can then be imported into Adobe Illustrator for post-processing. 12.2 From a browser Exporting an image from a browser is a nice option if you need to perform edits before exporting or if you‚Äôd like others to share your work. By default, the ‚Äòdownload plot‚Äô icon in the modebar will download to png and use the height and width of the plot, but these defaults can be altered via the plot‚Äôs configuration: plot_ly() %&gt;% config( toImageButtonOptions = list( format = &quot;svg&quot;, filename = &quot;myplot&quot;, width = 600, height = 700 ) ) FIGURE 12.2: Specifying options for static image exporting via the modebar. Clicking on the ‚Äòdownload plot‚Äô icon should prompt your browser to download a static svg file named ‚Äòmyplot.svg‚Äô 12.3 Sizing exports It‚Äôs worth noting that the height and width of a static image must be specified in pixels, which is intuitive for most file formats (png, jpeg, svg, etc) but when exporting to pdf, you might want to specify the size in inches. If you multiply the DPI of your machine‚Äôs display by the number of inches you want, you‚Äôll get the desired result. So, if you want a 8x11 pdf, and are on a typical 96 DPI display, you can do: orca(plot_ly(), width = 8 * 96, height = 11 * 96) On the other hand, if you‚Äôre performing interactive editing and exporting, you may want to set a fixed size for the plot: plot_ly(width = 8 * 96, height = 11 * 96) %&gt;% config(toImageButtonOptions = list(format = &quot;svg&quot;)) "],
["editing-views.html", "13 Editing views for publishing", " 13 Editing views for publishing Numerous layout components of a plotly graph can be directly manipulated, including annotation text and placement (more on this in section 18.2.3). In addition, the download (aka, toImage) button can be customized to export a static version to different file types including: svg, png, jpeg, and webp. Since svg can be easily converted to pdf, this effectively means we can edit a graph in a browser to perform touch-ups, then export to a high-quality pdf. At least currently, this workflow is recommended over first exporting to pdf (via orca()) then using Adobe Illustrator to manipulate the vectors, especially for adjusting the placement of annotations. Figure 13.1 demonstrates this workflow on a choropleth map of estimated income in Minnesota by county where the top 10 counties by total income are labeled.19 For visuals like this, automated algorithms for placing the labels may not yield polished results, so it can be nice to have the option to adjust the placement manually. Although pressing ‚Äòdownload plot‚Äô exports a static version of the current state of the plot, there currently isn‚Äôt an official way to save the state of these manual edits in the HTML version. You could, however, create a shiny app that listens to the 'plotly_relayout' event to obtain the new annotation positions (see, for example, Figure 18.5) and translate that information into code. Click to show code library(dplyr) library(sf) library(purrr) library(tidycensus) library(USAboundaries) # obtain geographical information for each county in MN mn_sf &lt;- us_counties(states = &quot;MN&quot;) # get income information for each county in MN mn_income &lt;- get_acs(geography = &quot;county&quot;, variables = &quot;B19013_001&quot;, state = &quot;MN&quot;) %&gt;% mutate( NAME = sub(&quot;County, Minnesota&quot;, &quot;&quot;, NAME), county = reorder(NAME, estimate), color = scales::col_numeric(&quot;viridis&quot;, NULL)(estimate) ) # find center of each county (for placing annotations) mn_center &lt;- mn_sf %&gt;% st_centroid() %&gt;% mutate( x = map_dbl(geometry, 1), y = map_dbl(geometry, 2) ) # get top 10 counties by income with their x/y center location top10labels &lt;- mn_income %&gt;% top_n(10, estimate) %&gt;% left_join(mn_center, by = c(&quot;GEOID&quot; = &quot;geoid&quot;)) # the map and top 10 county labels map &lt;- plot_ly() %&gt;% add_sf( data = left_join(mn_sf, mn_income, by = c(&quot;geoid&quot; = &quot;GEOID&quot;)), color = ~I(color), split = ~NAME, stroke = I(&quot;black&quot;), span = I(1), hoverinfo = &quot;none&quot; ) %&gt;% add_annotations( data = select(top10labels, NAME, x, y), text = ~NAME, x = ~x, y = ~y ) # the dot-plot bars &lt;- ggplot(mn_income, aes(x = estimate, y = county)) + geom_errorbarh(aes(xmin = estimate - moe, xmax = estimate + moe)) + geom_point(aes(color = color), size = 2) + scale_color_identity() # make manual edits in the browser, then click the # &#39;toImage&#39; button to export an svg file ggplotly(bars, dynamicTicks = TRUE, tooltip = &quot;y&quot;, height = 8 * 96, width = 11 * 96) %&gt;% subplot(map, nrows = 1, widths = c(0.3, 0.7)) %&gt;% layout(showlegend = FALSE) %&gt;% config( edits = list( annotationPosition = TRUE, annotationTail = TRUE, annotationText = TRUE ), toImageButtonOptions = list(format = &quot;svg&quot;) ) FIGURE 13.1: Estimated total income by county in Minnesota. The top 10 counties are labeled with editable annotations. After manually adjusting the placement of county labels in a web browser, and zooming in on the top 10 counties in the dot plot, the ‚Äòdownload plot‚Äô button is used to export to svg. After pressing the ‚Äúdownload plot‚Äù button to export svg, then the rsvg package can be used to convert the svg to pdf (Ooms 2018). # This is the directory that my browser places downloads... # you may have to change this to your download directory download_dir &lt;- &quot;~/Downloads/&quot; withr::with_dir(download_dir, rsvg::rsvg_pdf(&quot;newplot.svg&quot;, &quot;mn.pdf&quot;)) References "],
["arranging-views.html", "14 Arranging views 14.1 Arranging htmlwidgets 14.2 Merging plotly objects 14.3 Creating facets with subplot() 14.4 Scatterplot matrices with GGally 14.5 Navigating many views", " 14 Arranging views One technique essential to high-dimensional data visualization is the ability to arrange multiple views. As discussed latyer, ideally, these views are linked through an underlying data source to foster comparisons and enable posing of data queries (Cook, Buja, and Swayne 2007). The next section, Arranging htmlwidgets describes techniques for arranging htmlwidget objects, which many R packages for creating web-based data visualizations build upon, including plotly. Typically interactivity is isolated within an htmlwidget object, but Linking views without shiny explores some more recent work on enabling interactivity across htmlwidget objects. The following section, Subplots describes the subplot() function, which is useful for merging multiple plotly objects into a single htmlwidget object. The main benefit of merging (rather than arranging) plotly objects is that it gives us the ability to synchronize zoom and pan events across multiple axes. The last section, Navigating many views discusses some useful tools for restricting focus on interesting views when there are more views than you can possibly digest visually. 14.1 Arranging htmlwidgets Since plotly objects inherit properties from an htmlwidget object, any method that works for arranging htmlwidgets also works for plotly objects. In some sense, an htmlwidget object is just a collection of HTML tags, and the htmltools package provides some useful functions for working with HTML tags (RStudio and Inc. 2016). The tagList() function gathers multiple HTML tags into a tag list, and when printing a tag list inside of a knitr/rmarkdown document (Xie 2016a); (Allaire et al. 2016), it knows to render as HTML. However, when printing via the R/RStudio console, you must use browsable() to render and open the tag list as a web page (otherwise, it prints the HTML tags to your R console). Those familiar with shiny might already be familiar with using uiOutput() and/or renderUI() to dynamically render tag lists server-side. library(htmltools) library(plotly) p &lt;- plot_ly(x = rnorm(100)) # NOTE: you don&#39;t need browsable() in rmarkdown, but you do at the R prompt browsable(tagList(p, p)) FIGURE 14.1: Printing multiple htmlwidget objects with tagList(). To render tag lists at the command line, wrap them in browsable() Figure 14.1 renders two plots, each in its own row spanning the width of the page, because each htmlwidget object is an HTML &lt;div&gt; tag. More often than not, it is desirable to arrange multiple plots in a given row, and there are a few ways to do that. A very flexible approach is to wrap all of your plots in a flexbox (i.e., an HTML &lt;div&gt; with display: flex Cascading Style Sheets (CSS) property). The tags$div() function from htmltools provides a way to wrap a &lt;div&gt; around both tag lists and htmlwidget objects, and set attributes, such as style. As Figure 14.2 demonstrates, this approach also provides a nice way to add custom styling to the page, such as borders around each panel. tags$div( style = &quot;display: flex; flex-wrap: wrap&quot;, tags$div(p, style = &quot;width: 50%; padding: 1em; border: solid;&quot;), tags$div(p, style = &quot;width: 50%; padding: 1em; border: solid;&quot;), tags$div(p, style = &quot;width: 100%; padding: 1em; border: solid;&quot;) ) FIGURE 14.2: Arranging multiple htmlwidgets with flexbox Another way to arrange multiple htmlwidget objects on a single page is to leverage the fluidPage(), fluidRow(), and column() functions from the shiny package. library(shiny) fluidPage( fluidRow(p), fluidRow( column(6, p), column(6, p) ) ) FIGURE 14.3: Arranging multiple htmlwidgets with fluidPage() from the shiny package. All the arrangement approaches discussed thus far are agnostic to output format, meaning that they can be used to arrange htmlwidgets within any knitr/rmarkdown document.20 If the htmlwidgets do not need to be embedded within a larger document that requires an opinionated output format, the flexdashboard package provides a rmarkdown template for generating dashboards, with a convenient syntax for arranging views (Allaire 2016). 14.2 Merging plotly objects The subplot() function provides a flexible interface for merging multiple plotly objects into a single object (i.e., view). It is more flexible than most trellis display frameworks (e.g., ggplot2‚Äôs facet_wrap()) as you don‚Äôt have to condition on a value of common variable in each display (Richard A. Becker 1996). Its capabilities and interface is similar to the grid.arrange() function from the gridExtra package, which allows you to arrange multiple grid grobs in a single view, effectively providing a way to arrange (possibly unrelated) ggplot2 and/or lattice plots in a single view (R Core Team 2016); (Auguie 2016); (Sarkar 2008). Figure 14.4 shows the most simple way to use subplot() which is to directly supply plotly objects. library(plotly) p1 &lt;- plot_ly(economics, x = ~date, y = ~unemploy) %&gt;% add_lines(name = &quot;unemploy&quot;) p2 &lt;- plot_ly(economics, x = ~date, y = ~uempmed) %&gt;% add_lines(name = &quot;uempmed&quot;) subplot(p1, p2) FIGURE 14.4: The most basic use of subplot() to merge multiple plotly objects into a single plotly object. Although subplot() accepts an arbitrary number of plot objects, passing a list of plots can save typing and redundant code when dealing with a large number of plots. Figure 14.5 shows one time series for each variable in the economics dataset and share the x-axis so that zoom/pan events are synchronized across each series: vars &lt;- setdiff(names(economics), &quot;date&quot;) plots &lt;- lapply(vars, function(var) { plot_ly(economics, x = ~date, y = as.formula(paste0(&quot;~&quot;, var))) %&gt;% add_lines(name = var) }) subplot(plots, nrows = length(plots), shareX = TRUE, titleX = FALSE) FIGURE 14.5: Five different economic variables on different y scales and a common x scale. Zoom and pan events in the x-direction are synchronized across plots. A plotly subplot is a single plotly graph with multiple traces anchored on different axes. If you pre-specify an axis ID for each trace, subplot() will respect that ID. Figure 14.6 uses this fact in correspondence with the fact that mapping a discrete variable to color creates one trace per value. In addition to providing more control over trace placement, this provides a convenient way to control coloring (we could have symbol/linetype to achieve the same effect). economics %&gt;% tidyr::gather(variable, value, -date) %&gt;% transform(id = as.integer(factor(variable))) %&gt;% plot_ly(x = ~date, y = ~value, color = ~variable, colors = &quot;Dark2&quot;, yaxis = ~paste0(&quot;y&quot;, id)) %&gt;% add_lines() %&gt;% subplot(nrows = 5, shareX = TRUE) FIGURE 14.6: Pre-populating y axis IDs. Conceptually, subplot() provides a way to place a collection of plots into a table with a given number of rows and columns. The number of rows (and, by consequence, the number of columns) is specified via the nrows argument. By default each row/column shares an equal proportion of the overall height/width, but as shown in Figure 14.7 the default can be changed via the heights and widths arguments. FIGURE 14.7: A visual diagram of controling the heights of rows and widths of columns. This flexibility is quite useful for a number of visualizations, for example, as shown in Figure 14.8, a joint density plot is really of subplot of joint and marginal densities. The heatmaply package is great example of leveraging subplot() in a similar way to create interactive dendrograms (Galili 2016). x &lt;- rnorm(100) y &lt;- rnorm(100) s &lt;- subplot( plot_ly(x = x, color = I(&quot;black&quot;)), plotly_empty(), plot_ly(x = x, y = y, color = I(&quot;black&quot;)), plot_ly(y = y, color = I(&quot;black&quot;)), nrows = 2, heights = c(0.2, 0.8), widths = c(0.8, 0.2), shareX = TRUE, shareY = TRUE, titleX = FALSE, titleY = FALSE ) layout(s, showlegend = FALSE) FIGURE 14.8: A joint density plot with synchronized axes. 14.2.1 Recursive subplots The subplot() function returns a plotly object so it can be modified like any other plotly object. This effectively means that subplots work recursively (i.e., you can have subplots within subplots). This idea is useful when your desired layout doesn‚Äôt conform to the table structure described in the previous section. In fact, you can think of a subplot of subplots like a spreadsheet with merged cells. Figure 14.9 gives a basic example where each row of the outer-most subplot contains a different number of columns. plotList &lt;- function(nplots) { lapply(seq_len(nplots), function(x) plot_ly()) } s1 &lt;- subplot(plotList(6), nrows = 2, shareX = TRUE, shareY = TRUE) s2 &lt;- subplot(plotList(2), shareY = TRUE) subplot( s1, s2, plot_ly(), nrows = 3, margin = 0.04, heights = c(0.6, 0.3, 0.1) ) FIGURE 14.9: Recursive subplots. The concept is particularly useful when you want plot(s) in a given row to have different widths from plot(s) in another row. Figure 14.10 uses this recursive behavior to place many bar charts in the first row, and a single choropleth in the second row. # specify some map projection/options g &lt;- list( scope = &#39;usa&#39;, projection = list(type = &#39;albers usa&#39;), lakecolor = toRGB(&#39;white&#39;) ) # create a map of population density density &lt;- state.x77[, &quot;Population&quot;] / state.x77[, &quot;Area&quot;] map &lt;- plot_geo(z = ~density, text = state.name, locations = state.abb, locationmode = &#39;USA-states&#39;) %&gt;% layout(geo = g) # create a bunch of horizontal bar charts vars &lt;- colnames(state.x77) barcharts &lt;- lapply(vars, function(var) { plot_ly(x = state.x77[, var], y = state.name) %&gt;% add_bars(orientation = &quot;h&quot;, name = var) %&gt;% layout(showlegend = FALSE, hovermode = &quot;y&quot;, yaxis = list(showticklabels = FALSE)) }) subplot( subplot(barcharts, margin = 0.01), map, nrows = 2, heights = c(0.3, 0.7), margin = 0.1 ) FIGURE 14.10: Multiple bar charts of US statistics by state in a subplot with a choropleth of population density 14.2.2 ggplot2 subplots Underneath the hood, ggplot2 facets are implemented as subplots, which enables the synchronized zoom events on shared axes. Since subplots work recursively, it is also possible to have a subplot of ggplot2 faceted plots, as Figure 14.11 shows. Moreover, subplot() can understand ggplot objects, so there is no need to translate them to plotly object via ggplotly() (unless you want to leverage some of the ggplotly() arguments, such as tooltip for customizing information displayed on hover). e &lt;- tidyr::gather(economics, variable, value, -date) gg1 &lt;- ggplot(e, aes(date, value)) + geom_line() + facet_wrap(~variable, scales = &quot;free_y&quot;, ncol = 1) gg2 &lt;- ggplot(e, aes(factor(1), value)) + geom_violin() + facet_wrap(~variable, scales = &quot;free_y&quot;, ncol = 1) + theme(axis.text = element_blank(), axis.ticks = element_blank()) subplot(gg1, gg2) %&gt;% layout(margin = list(l = 50)) FIGURE 14.11: Arranging multiple faceted ggplot2 plots into a plotly subplot. 14.3 Creating facets with subplot() library(plotly) library(dplyr) my_plot &lt;- . %&gt;% plot_ly(x = ~date, y = ~value) %&gt;% add_annotations( text = ~unique(variable), x = 0.5, y = 1, yref = &quot;paper&quot;, xref = &quot;paper&quot;, xanchor = &quot;middle&quot;, yanchor = &quot;top&quot;, showarrow = FALSE, font = list(size = 15) ) %&gt;% layout( shapes = list( type = &quot;rect&quot;, x = 0, x = 1 ) ) economics_long %&gt;% group_by(variable) %&gt;% do(p = my_plot(.)) %&gt;% subplot(nrows = NROW(.), shareX = TRUE) 14.4 Scatterplot matrices with GGally Scatterplot matrices can be made via plot_ly() and subplot(), but ggplotly() has a special method for translating ggmatrix objects from the GGally package to plotly objects (Schloerke et al. 2016). These objects are essentially a matrix of ggplot objects and are the underlying data structure which powers higher level functions in GGally, such as ggpairs() ‚Äì a function for creating a generalized pairs plot (Emerson et al. 2013). The generalized pairs plot can be motivated as a generalization of the scatterplot matrix with support for categorical variables and different visual representations of the data powered by the grammar of graphics. Figure 14.12 shows an interactive version of the generalized pairs plot made via ggpairs() and ggplotly(). pm &lt;- GGally::ggpairs(iris) ggplotly(pm) FIGURE 14.12: An interactive version of the generalized pairs plot made via the ggpairs() function from the GGally package Sections 17.4.6 and 17.4.7 domenstrates how to link the views generated by Gally functions ggpairs() and ggnostic() (model diagnostic plots). 14.5 Navigating many views Sometimes you have to consider way more views than you can possibly digest visually. In Multiple linked views, we explore some useful techniques for implementing the popular visualization mantra from Shneiderman (1996): ‚ÄúOverview first, zoom and filter, then details-on-demand.‚Äù In fact, Figure 18.11 from section 18.2.5 provides an example of this mantra put into practice. The correlation matrix provides an overview of the correlation structure between all the variables, and by clicking a cell, it populates a scatterplot between those two specific variables. This works fine with tens or hundreds or variables, but once you have thousands or tens-of-thousands of variables, this technique begins to fall apart. At that point, you may be better off defining a range of correlations that you‚Äôre interested in exploring, or better yet, incorporating another measure (e.g., a test statistic), then focusing on views that match a certain criteria. Tukey and Tukey (n.d.) first described the idea of using quantitative measurements of scatterplot characteristics (e.g. correlation) to help guide exploratory analysis of many variables. This idea, coined scagnostics (short for scatterplot diagnostics), has since been made explicit, and many measures have been explored, even measures specifically useful for time-series have been proposed (Wilkinson, Anand, and Grossman 2005); (Wilkinson and Wills 2008); (Dang and Wilkinson 2012). Probably the most universally useful scagnostic is the outlying measure which helps identify projections of the data space that contain outlying observations. Of course, the idea of associating quantitative measures with a graphical display of data can be generalized to include more that just scatterplots, and in this more general case, these measures are sometimes referred to as cognostics. The same problems and principles that inspired scagnostics has inspired work on more general divide &amp; recombine technique(s) for working with navigating through many statistical artifacts (Cleveland and Hafen 2014); (Saptarshi Guha and Cleveland 2012), including visualizations (Hafen et al. 2013). The trelliscope package provides a system for computing arbitrary cognostics on each panel of a trellis display as well as an interactive graphical user interface for defining (and navigating through) interesting panels based on those cognostics (Hafen 2016). This system also allows users to define the graphical method for displaying each panel, so plotly graphs can easily be embedded. The trelliscope package is currently built upon shiny, but as Figure 14.13 demonstrates, the trelliscopejs package provides lower-level tools that allow one to create trelliscope displays without shiny (Hafen and Schloerke, n.d.). library(trelliscopejs) qplot(cty, hwy, data = mpg) + xlim(7, 37) + ylim(9, 47) + theme_bw() + facet_trelliscope( ~ manufacturer + class, nrow = 2, ncol = 4, as_plotly = TRUE, plotly_args = list(dynamicTicks = T) ) FIGURE 14.13: Using plotly within a trelliscope References "],
["animating-views.html", "15 Animating views 15.1 Animation API 15.2 Animation support", " 15 Animating views 15.1 Animation API Both plot_ly() and ggplotly() support key frame animations through the frame argument/aesthetic. They also support an ids argument/aesthetic to ensure smooth transitions between objects with the same id (which helps facilitate object constancy). Figure 15.1 recreates the famous gapminder animation of the evolution in the relationship between GDP per capita and life expectancy evolved over time (Bryan 2015). The data is recorded on a yearly basis, so the year is assigned to frame, and each point in the scatterplot represents a country, so the country is assigned to ids, ensuring a smooth transition from year to year for a given country. data(gapminder, package = &quot;gapminder&quot;) gg &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) + geom_point(aes(size = pop, frame = year, ids = country)) + scale_x_log10() ggplotly(gg) FIGURE 15.1: Animation of the evolution in the relationship between GDP per capita and life expectancy in numerous countries. As long as a frame variable is provided, an animation is produced with play/pause button(s) and a slider component for controlling the animation. These components can be removed or customized via the animation_button() and animation_slider() functions. Moreover, various animation options, like the amount of time between frames, the smooth transition duration, and the type of transition easing may be altered via the animation_opts() function. Figure 15.2 shows the same data as Figure 15.1, but doubles the amount of time between frames, uses linear transition easing, places the animation buttons closer to the slider, and modifies the default currentvalue.prefix settings for the slider. base &lt;- gapminder %&gt;% plot_ly(x = ~gdpPercap, y = ~lifeExp, size = ~pop, text = ~country, hoverinfo = &quot;text&quot;) %&gt;% layout(xaxis = list(type = &quot;log&quot;)) base %&gt;% add_markers(color = ~continent, frame = ~year, ids = ~country) %&gt;% animation_opts(1000, easing = &quot;elastic&quot;, redraw = FALSE) %&gt;% animation_button( x = 1, xanchor = &quot;right&quot;, y = 0, yanchor = &quot;bottom&quot; ) %&gt;% animation_slider( currentvalue = list(prefix = &quot;YEAR &quot;, font = list(color=&quot;red&quot;)) ) FIGURE 15.2: Modifying animation defaults with animation_opts(), animation_button(), and animation_slider(). If frame is a numeric variable (or a character string), frames are always ordered in increasing (alphabetical) order; but for factors, the ordering reflects the ordering of the levels. Consequently, factors provide the most control over the ordering of frames. In Figure 15.3, the continents (i.e., frames) are ordered according their average life expectancy across countries within the continent. Furthermore, since there is no meaningful relationship between objects in different frames of Figure 15.3, the smooth transition duration is set to 0. This helps avoid any confusion that there is a meaningful connection between the smooth transitions. Note that these options control both animations triggered by the play button or via the slider. meanLife &lt;- with(gapminder, tapply(lifeExp, INDEX = continent, mean)) gapminder$continent &lt;- factor( gapminder$continent, levels = names(sort(meanLife)) ) base %&gt;% add_markers(data = gapminder, frame = ~continent) %&gt;% hide_legend() %&gt;% animation_opts(frame = 1000, transition = 0, redraw = FALSE) FIGURE 15.3: Animation of GDP per capita versus life expectancy by continent. The ordering of the contintents goes from lowest average (across countries) life expectancy to highest. Both the frame and ids attributes operate on the trace level ‚Äì meaning that we can target specific layers of the graph to be animated. One obvious use case for this is to provide a background which displays every possible frame (which is not animated) and overlay the animated frames onto that background. Figure 15.4 shows the same information as Figure 15.2, but layers animated frames on top of a background of all the frames. As a result, it is easier to put a specific year into a global context. base %&gt;% add_markers(color = ~continent, alpha = 0.2, showlegend = F) %&gt;% add_markers(color = ~continent, frame = ~year, ids = ~country) %&gt;% animation_opts(1000, redraw = FALSE) FIGURE 15.4: Overlaying animated frames on top of a background of all possible frames. 15.2 Animation support At the time of writing, the scatter plotly.js trace type is really the only trace type with full support for animation. That means, we need to get a little imaginative to animate certain things, like a population pyramid chart (essentially a bar chart) using add_segments() (a scatter-based layer) instead of add_bars() (a non-scatter layer). Figure 15.5 shows projections for male &amp; female population by age from 2018 to 2050 using data obtained via the idbr package (Walker 2018). library(idbr) library(dplyr) us &lt;- bind_rows( idb1( country = &quot;US&quot;, year = 2018:2050, variables = c(&quot;AGE&quot;, &quot;NAME&quot;, &quot;POP&quot;), sex = &quot;male&quot; ), idb1( country = &quot;US&quot;, year = 2018:2050, variables = c(&quot;AGE&quot;, &quot;NAME&quot;, &quot;POP&quot;), sex = &quot;female&quot; ) ) us &lt;- us %&gt;% mutate( POP = if_else(SEX == 1, POP, -POP), SEX = if_else(SEX == 1, &quot;Male&quot;, &quot;Female&quot;) ) plot_ly(us, size = I(5), alpha = 0.5) %&gt;% add_segments( x = ~POP, xend = 0, y = ~AGE, yend = ~AGE, frame = ~time, color = ~factor(SEX) ) FIGURE 15.5: US population projections by age and gender from 2018 to 2050. This population pyramid is implemented with thick line segments to give the appearance of bars. Although population pyramids are quite popular, they aren‚Äôt necessarily the best way to visualize this information, especially if the goal is to compare the population profiles over time. It‚Äôs much easier to compare them along a common scale, as done in Figure 15.6. Note that, when animating lines in this fashion, it can help to set line.simplify to FALSE so that the number of points along the path are left unaffected. plot_ly(us, alpha = 0.5) %&gt;% add_lines( x = ~AGE, y = ~abs(POP), frame = ~time, color = ~factor(SEX), line = list(simplify = FALSE) ) %&gt;% layout(yaxis = list(title = &quot;US population&quot;)) FIGURE 15.6: Visualizing the same information in Figure 15.5 using lines rather than segments. References "],
["introduction-2.html", "16 Introduction", " 16 Introduction Motivate linked views, perhaps through an example? Discuss the pros/cons between client-side/server-side linking "],
["client-side-linking.html", "17 Client-side linking 17.1 Graphical queries 17.2 Highlight versus filter events 17.3 Linking animated views 17.4 Examples 17.5 Limitations", " 17 Client-side linking Linking of multiple data views offers a powerful approach to visualization as well as communication of structure in high-dimensional data. In particular, linking of multiple 1-2 dimensional statistical graphics can often lead to insight that a single view could not possibly reveal. For decades, statisticians and computer scientists have been using and authoring systems for multiple linked views, many of which can be found in the ASA‚Äôs video library. Some noteworthy videos include focusing and linking, missing values, and exploring Tour De France data (Swayne, Cook, and Buja 1998); (Theus and Urbanek 2008). These early systems were incredibly sophisticated, but the interactive graphics they produce are not easily shared, replicated, or incorporated in a larger document. Web technologies offer the infrastructure to address these issues, which is a big reason why many modern interactive graphics systems are web based. When talking about interactive web-based graphics, it‚Äôs important to recognize the difference between a web application and a purely client-side webpage, especially when it comes to saving, sharing, and hosting the result. A web application relies on a client-server relationship where the client‚Äôs (i.e., end user) web browser requests content from a remote server. This model is necessary whenever the webpage needs to execute computer code that is not natively supported by the client‚Äôs web browser. As Section 18 details, the flexibility that a web application framework, like shiny, offers is an incredibly productive and powerful way to link multiple data views; but when it comes to distributing a web application, it introduces a lot of complexity and computational infrastructure that may or may not be necessary. Figure 17.1 is a basic illustration of the difference between a web application and a purely client-side web page. Thanks to JavaScript and HTML5, purely client-side web pages can still be dynamic without any software dependencies besides a modern web browser. In fact, Section (graphical-queries) outlines plotly‚Äôs graphical querying framework for linking multiple plots entirely client-side, which makes the result very easy to distribute (see Section (saving)). There are, of course, many useful examples of linked and dynamic views that can not be easily expressed as a database query, but a suprising amount actually can, and the remainder can likely be quickly implemented as a shiny web application. FIGURE 17.1: A diagram of the graphical querying framework underlying Figure 17.7. The graphical querying framework implemented by plotly is inspired by Buja et al. (1991), where direct manipulation of graphical elements in multiple linked plots is used to perform data base queries and visually reveal high-dimensional structure in real-time. Cook, Buja, and Swayne (2007) goes on to argue this framework is preferable to posing data base queries dynamically via a menus, as described by Ahlberg, Williamson, and Shneiderman (1991), and goes on to state that ‚ÄúMultiple linked views are the optimal framework for posing queries about data‚Äù. The next section shows you how to implement similar graphical queries in a standalone webpage using R code. 17.1 Graphical queries This section focuses on a particular approach to linking views known as graphical (database) queries using the R package plotly. With plotly, one can write R code to pose graphical queries that operate entirely client-side in a web browser (i.e., no special web server or callback to R is required). In addition to teaching you how to pose queries with the highlight_key() function, this section shows you how to control how queries are triggered and visually rendered via the highlight() function. Figure 17.2 shows a scatterplot of the relationship between weight and miles per gallon of 32 cars. It also uses highlight_key() to assign the number of cylinders to each point so that when a particular point is ‚Äòqueried‚Äô all points with the same number of cylinders are highlighted (the number of cylinders is displayed with text just for demonstration purposes). By default, a mouse click triggers a query, and a double-click clears the query, but both of these events can be customized through the highlight() function. By typing help(highlight) in your R console, you can learn more about what events are supported for turning graphical queries on and off. library(plotly) mtcars %&gt;% highlight_key(~cyl) %&gt;% plot_ly(x = ~wt, y = ~mpg, text = ~cyl, mode = &quot;markers+text&quot;, textposition = &quot;top&quot;, hoverinfo = &quot;x+y&quot;) %&gt;% highlight(on = &quot;plotly_hover&quot;, off = &quot;plotly_doubleclick&quot;) FIGURE 17.2: A visual depiction of how highlight_key() attaches metadata to graphical elements to enable graphical database queries. Each point represents a different car and the number of cylinders (cyl) is assigned as metadata so that when a particular point is queried all points with the same number of cylinders are highlighted. Generally speaking, highlight_key() assigns data values to graphical marks so that when graphical mark(s) are directly manipulated through the on event, it uses the corresponding data values (call it $SELECTION_VALUE) to perform an SQL query of the following form. SELECT * FROM mtcars WHERE cyl IN $SELECTION_VALUE For a more useful example, lets use graphical querying to pose interactive queries of the txhousing dataset. This data contains monthly housing sales in Texan cities acquired from the TAMU real estate center and made available via the ggplot2 package. Figure 17.3 shows the median house price in each city over time which produces a rather busy (spaghetti) plot. To help combat the overplotting, we could add the ability to click a particular a given point on a line to highlight that particular city. This interactive ability is enabled by simply using highlight_key() to declare that the city variable be used as the querying criteria within the graphical querying framework. One subtlety to be aware of in terms of what makes Figure 17.3 possible is that every point along a line may have a different data value assigned to it. In this case, since the city column is used as both the visual grouping and querying variable, we effectively get the ability to highlight a group by clicking on any point along that line. Section 17.4.1 has examples of using different grouping and querying variables to query multiple related groups of visual geometries at once, which can be a powerful technique.21 # load the `txhousing` dataset data(txhousing, package = &quot;ggplot2&quot;) # declare `city` as the SQL &#39;query by&#39; column tx &lt;- highlight_key(txhousing, ~city) # initiate a plotly object base &lt;- plot_ly(tx, color = I(&quot;black&quot;)) %&gt;% group_by(city) # create a time series of median house price base %&gt;% group_by(city) %&gt;% add_lines(x = ~date, y = ~median) FIGURE 17.3: Graphical query of housing prices in various Texas cities. The query in this particular example must be triggered through clicking directly on a time series. Querying a city via direct manipulation is somewhat helpful for focusing on a particular time series, but it‚Äôs not so helpful for querying a city by name and/or comparing multiple cities at once. As it turns out, plotly makes it easy to add a selectize.js powered dropdown widget for querying by name (aka indirect manipulation) by setting selectize = TRUE.22 When it comes to comparing multiple cities, we want to be able to both retain previous selections (persistent = TRUE) as well as control the highlighting color (dynamic = TRUE). This videos explains how to use these features in Figure 17.4 to compare pricing across different cities. highlight(time_series, on = &quot;plotly_click&quot;, selectize = TRUE, dynamic = TRUE, persistent = TRUE) FIGURE 17.4: Using a selectize dropdown widget to search for cities by name and comparing multiple cities through persistent selection with a dynamic highlighting color. See this video for a demo and audio explanation. By querying a few different cities in Figure 17.4, one obvious thing we can learn is that not every city has complete pricing information (e.g., South Padre Island, San Marcos, etc). To learn more about what cities are missing information as well as how that missingness is structured, Figure 17.5 links a view of the raw time series to a dot-plot of the corresponding number of missing values per city. In addition to making it easy to see how cities rank in terms of missing house prices, it also provides a way to query the corresponding time series (i.e., reveal the structure of those missing values) by brushing cities in the dot-plot. This general pattern of linking aggregated views of the data to more detailed views fits the famous and practical information visualization advice from Shneiderman (1996): ‚ÄúOverview first, zoom and filter, then details on demand‚Äù. # remember, `base` is a plotly object, but we can use dplyr verbs to # manipulate the input data # (`txhousing` with `city` as a grouping and querying variable) dot_plot &lt;- base %&gt;% summarise(miss = sum(is.na(median))) %&gt;% filter(miss &gt; 0) %&gt;% add_markers(x = ~miss, y = ~forcats::fct_reorder(city, miss), hoverinfo = &quot;x+y&quot;) %&gt;% layout( xaxis = list(title = &quot;Number of months missing&quot;), yaxis = list(title = &quot;&quot;) ) subplot(dot_plot, time_series, widths = c(0.2, 0.8), titleX = TRUE) %&gt;% layout(showlegend = FALSE) %&gt;% highlight(on = &quot;plotly_selected&quot;, dynamic = TRUE, selectize = TRUE) FIGURE 17.5: Linking a dot-plot of the number of missing housing prices with the raw time series. By brushing markers on the dot-plot, their raw time series is highlighted on the right hand side. How does plotly know to highlight the time series when markers in the dot-plot are selected? The answer lies in what data values are embedded in the graphical markers via highlight_key(). When ‚ÄòSouth Padre Island‚Äô is selected, like in Figure 17.6, it seems as though the logic says to simply change the color of any graphical elements that match that value, but the logic behind plotly‚Äôs graphical queries is a bit more subtle and powerful. Another, more accurate, framing of the logic is to first imagine a linked database query being performed behind the scenes (as in Figure 17.6). When ‚ÄòSouth Padre Island‚Äô is selected, it first filters the aggregated dot-plot data down to just that one row, then it filters down the raw time-series data down to every row with ‚ÄòSouth Padre Island‚Äô as a city. The drawing logic will then call Plotly.addTrace() with the newly filtered data which adds a new graphical layer representing the selection, allowing us to have finely-tuned control over the visual encoding of the data query. FIGURE 17.6: A diagram of the graphical querying framework underlying Figure 17.5. The biggest advantage of drawing an entirely new graphical layer with the filtered data is that it becomes easy to leverage statistical trace types for producing summaries that are conditional on the query. Figure 17.7 leverages this functionality to dynamically produce probability densities of house price in response to a query events. Section 17.4.2 has more examples of leveraging statistical trace types with graphical queries. hist &lt;- base %&gt;% add_histogram(x = ~median, histnorm = &quot;probability density&quot;) subplot(time_series, hist, nrows = 2) %&gt;% layout(barmode = &quot;overlay&quot;, showlegend = FALSE) %&gt;% highlight(dynamic = TRUE, selectize = TRUE, selected = attrs_selected(opacity = 0.3)) FIGURE 17.7: Linking house prices as a function of time with their probability density estimates. Another neat consequence of drawing a completely new layer is that we can control the plotly.js attributes in that layer through the selected argument of the highlight() function. In Figure 17.7 we use it to ensure the new highlighting layer has some transparency to more easily compare the city specific distribution to the overall distribution. This section is designed to help give you a foundation for leveraging graphical queries in your own work. Hopefully by now you have a rough idea what graphical queries are, how they can be useful, and how to create them with highlight_key() and highlight(). Understanding the basic idea is one thing, but applying it effectively to new problems is another thing entirely. To help spark your imagination and demonstrate what‚Äôs possible, Section 17.4 has numerous subsections each with numerous examples of graphical queries in action. 17.2 Highlight versus filter events Section 17.1 provides an overview of plotly‚Äôs framework for highlight events, but it also supports filter events. These events trigger slightly different logic: A highlight event dims the opacity of existing marks, then adds an additional graphical layer representing the selection. A filter event completely remove existing marks and rescales axes to the remaining data.23 Figure 17.8 provides a quick visual depiction in the difference between filter and highlight events. At least currently, filter events must be fired from filter widgets from the crosstalk package, and these widgets expect an object of class SharedData as input. As it turns out, the highlight_key() function, introduced in section 17.1, creates a SharedData instance and is essentially a wrapper for crosstalk::SharedData$new(). class(highlight_key(mtcars)) #&gt; [1] &quot;SharedData&quot; &quot;R6&quot; Figure 17.8 demonstrates the main difference in logic between filter and highlight events. Notice how, in the code implementation, the ‚Äòquerying variable‚Äô definition for filter events is part of the filter widget. That is, city is defined as the variable of interest in filter_select(), not in the creation of tx. That is (intentionally) different from the approach for highlight events, where the ‚Äòquerying variable‚Äô is a property of the dataset behind the graphical elements. library(crosstalk) # generally speaking, use a &quot;unique&quot; key for filter, # especially when you have multiple filters! tx &lt;- highlight_key(txhousing) gg &lt;- ggplot(tx) + geom_line(aes(date, median, group = city)) filter &lt;- bscols( filter_select(&quot;id&quot;, &quot;Select a city&quot;, tx, ~city), ggplotly(gg, dynamicTicks = TRUE), widths = c(12, 12) ) tx2 &lt;- highlight_key(txhousing, ~city, &quot;Select a city&quot;) gg &lt;- ggplot(tx2) + geom_line(aes(date, median, group = city)) select &lt;- highlight( ggplotly(gg, tooltip = &quot;city&quot;), selectize = TRUE, persistent = TRUE ) bscols(filter, select) FIGURE 17.8: Comparing filter to highlight events. Filter events completely remove existing marks and rescales axes to the remaining data. When using multiple filter widgets to filter the same dataset, as done in Figure 17.9, you should avoid referencing a non-unique querying variable (i.e., key-column) in the SharedData object used to populate the filter widgets. Remember that the default behavior of highlight_key() and SharedData$new() is to use the row-index (which is unique). This ensures the intersection of multiple filtering widgets queries the correct subset of data. library(crosstalk) tx &lt;- highlight_key(txhousing) widgets &lt;- bscols( widths = c(12, 12, 12), filter_select(&quot;city&quot;, &quot;Cities&quot;, tx, ~city), filter_slider(&quot;sales&quot;, &quot;Sales&quot;, tx, ~sales), filter_checkbox(&quot;year&quot;, &quot;Years&quot;, tx, ~year, inline = TRUE) ) bscols( widths = c(4, 8), widgets, plot_ly(tx, x = ~date, y = ~median, showlegend = FALSE) %&gt;% add_lines(color = ~city, colors = &quot;black&quot;) ) FIGURE 17.9: Filtering on multiple variables. As Figure 17.10 demonstrates, filter and highlight events can work in conjunction with various htmlwidgets. In fact, since the semantics of filter are more well-defined than highlight, linking filter events across htmlwidgets via crosstalk should generally be more well-supported.24 library(leaflet) eqs &lt;- highlight_key(quakes) stations &lt;- filter_slider(&quot;station&quot;, &quot;Number of Stations&quot;, eqs, ~stations) p &lt;- plot_ly(eqs, x = ~depth, y = ~mag) %&gt;% add_markers(alpha = 0.5) %&gt;% highlight(&quot;plotly_selected&quot;) map &lt;- leaflet(eqs) %&gt;% addTiles() %&gt;% addCircles() bscols( widths = c(6, 6, 3), p, map, stations ) FIGURE 17.10: Linking plotly and leaflet through both filter and highlight events. When combining filter and highlight events, one (current) limitation to be aware of is that the highlighting variable has to be nested inside filter variable(s). For example, in Figure 17.11, we can filter by continent and highlight by country, but there is currently no way to highlight by contintent and filter by country. library(gapminder) g &lt;- highlight_key(gapminder, ~country) continent_filter &lt;- filter_select(&quot;filter&quot;, &quot;Select a country&quot;, g, ~continent) p &lt;- plot_ly(g) %&gt;% group_by(country) %&gt;% add_lines(x = ~year, y = ~lifeExp, color = ~continent) %&gt;% layout(xaxis = list(title = &quot;&quot;)) %&gt;% highlight(selected = attrs_selected(showlegend = FALSE)) bscols(continent_filter, p, widths = 12) FIGURE 17.11: Combining filtering and highlighting with non-unique querying variables 17.3 Linking animated views The graphical querying framework (Section 17.1) works in tandem with key-frame animations Section (15). Figure 17.12 extends Figure 15.1 by layering on linear models specific to each frame and specifying continent as a key variable. As a result, one may interactively highlight any continent they wish, and track the relationship through the animation. In the animated version of Figure 15.1, the user highlights the Americas, which makes it much easier to see that the relationship between GDP per capita and life expectancy was very strong starting in the 1950s, but progressively weakened throughout the years. g &lt;- highlight_key(gapminder, ~continent) gg &lt;- ggplot(g, aes(gdpPercap, lifeExp, color = continent, frame = year)) + geom_point(aes(size = pop, ids = country)) + geom_smooth(se = FALSE, method = &quot;lm&quot;) + scale_x_log10() highlight(ggplotly(gg), &quot;plotly_hover&quot;) FIGURE 17.12: Highlighting the relationship between GDP per capita and life expectancy in the Americas and tracking that relationship through several decades. In addition to highlighting objects within an animation, objects may also be linked between animations. Figure 17.13 links two animated views: on the left-hand side is population density by country and on the right-hand side is GDP per capita versus life expectancy. By default, all of the years are shown in black and the current year is shown in red. By pressing play to animate through the years, we can see that all three of these variables have increased (on average) fairly consistently over time. By linking the animated layers, we may condition on an interesting region of this data space to make comparisons in the overall relationship over time. For example, in Figure 17.13, countries below the 50th percentile in terms of population density are highlighted in blue, then the animation is played again to reveal a fairly interesting difference in these groups. From 1952 to 1977, countries with a low population density seem to enjoy large increases in GDP per capita and moderate increases in life expectancy, then in the early 80s, their GPD seems to decrease while the life expectancy greatly increases. In comparison, the high density countries seems to enjoy a more consistent and steady increase in both GDP and life expectancy. Of course, there are a handful of exceptions to the overall trend, such as the noticeable drop in life expectancy for a handful of countries during the nineties, which are mostly African countries feeling the affects of war. The gapminder data does not include a measure of population density, but the gap dataset (included with the plotlyBook R package) adds a column containing the population per square kilometer (popDen), which helps implement Figure 17.13. In order to link the animated layers (i.e., red points), we need another version of gap that marks the country variable as the link between the plots (gapKey). data(gap, package = &quot;plotlyBook&quot;) gapKey &lt;- highlight_key(gap, ~country) p1 &lt;- plot_ly(gap, y = ~country, x = ~popDen, hoverinfo = &quot;x&quot;) %&gt;% add_markers(alpha = 0.1, color = I(&quot;black&quot;)) %&gt;% add_markers(data = gapKey, frame = ~year, ids = ~country, color = I(&quot;red&quot;)) %&gt;% layout(xaxis = list(type = &quot;log&quot;)) p2 &lt;- plot_ly(gap, x = ~gdpPercap, y = ~lifeExp, size = ~popDen, text = ~country, hoverinfo = &quot;text&quot;) %&gt;% add_markers(color = I(&quot;black&quot;), alpha = 0.1) %&gt;% add_markers(data = gapKey, frame = ~year, ids = ~country, color = I(&quot;red&quot;)) %&gt;% layout(xaxis = list(type = &quot;log&quot;)) subplot(p1, p2, nrows = 1, widths = c(0.3, 0.7), titleX = TRUE) %&gt;% hide_legend() %&gt;% animation_opts(1000, redraw = FALSE) %&gt;% layout(hovermode = &quot;y&quot;, margin = list(l = 100)) %&gt;% highlight(&quot;plotly_selected&quot;, color = &quot;blue&quot;, opacityDim = 1, hoverinfo = &quot;none&quot;) FIGURE 17.13: Comparing the evolution in the relationship between per capita GDP and life expectancy in countries with large populations (red) and small populations (blue). 17.4 Examples 17.4.1 Querying facetted charts A facetted chart, also known as a trellis or small multiples display, is an effective way to observe how a certain relationship or visual pattern changes with a discrete variable (Richard A. Becker 1996) (Tufte 2001b). The implementation of a facetted chart partitions a data set into groups, then produces a graphical panel for each group using a fixed visual encoding (e.g. a scatterplot). When these groups are related in some way, it can be useful to consider linking the panels through graphical queries to reveal greater insight, especially when it comes to making comparisons both within and across multiple groups. Figure 17.14 is an example of making comparisons both within and across panels via graphical querying in a facetted chart. Each panel represents one year of English Premier League standings across time and each line represents a team (the querying variable). Since the x-axis represents the number of games within season and y-axis tracks cumulative points relative to the league average, lines with a positive slope represent above average performance and a negative slope represents below average performance. This design makes it easy to query a good (or bad) team for a particular year (via direct manipulation) to see who the team is as well as how they‚Äôve compared to the competition in other years. In addition, the dynamic and persistent color brush allows us to query other teams to compare both within and across years. This example is shipped as a demo with the plotly package and uses data from the engsoccerdata package (Curley 2016). Thanks to Antony Unwin for providing the initial idea and inspiration for Figure 17.14 (Unwin 2016). # By entering this demo in your R console it will print out the actual source code necessary to recreate the graphic # Also, `demo(package = &quot;plotly&quot;)` will list of all demos shipped with plotly demo(&quot;crosstalk-highlight-epl-2&quot;, package = &quot;plotly&quot;) FIGURE 17.14: Graphical querying in a facetted display of English Premier League standings over time. The combination of direct and indirect manipulation with the dynamic color brush makes it easy to make comparisons between good and/or bad teams relative to their known rivals. The demo above requires some fairly advanced data pre-processing, so to learn how to implement graphical queries in trellis displays, let‚Äôs work with more minimal examples. Figure 17.15 gives us yet another look at the txhousing dataset. This time we focus on just four cities and give each city it‚Äôs own panel in the trellis display by leveraging facet_wrap() from ggplot2. Within each panel, we‚Äôll wrap the house price time series by year by putting the month on the x-axis and grouping by year. Then, to link these panels, we can ulitize year as a querying variable. As a result, not only do we have the ability to analyze annual trends within city, but we can also query specific years to compare unusual or interesting years both within and across cities. library(dplyr) txsmall &lt;- txhousing %&gt;% select(city, year, month, median) %&gt;% filter(city %in% c(&quot;Galveston&quot;, &quot;Midland&quot;, &quot;Odessa&quot;, &quot;South Padre Island&quot;)) txsmall %&gt;% highlight_key(~year) %&gt;% { ggplot(., aes(month, median, group = year)) + geom_line() + facet_wrap(~city, ncol = 2) } %&gt;% ggplotly(tooltip = &quot;year&quot;) FIGURE 17.15: Monthly median house prices in four Texan cities. Querying by year allows one to compare unusual or interesting years both within and across cities. Figure 17.16 displays the same information as 17.15, but shows a way to implement a linked trellis display via plot_ly() instead of ggplotly(). This approach leverages dplyr::do() to create plotly object for each city/panel, then routes that list of plots into subplot(). One nuance here is that the querying variable has to be defined within the do() statement, but everytime highlight_key() is called, it creates a crosstalk::SharedData object belonging to a new unique group, so to link these panels together the group must be set to a constant value (here we‚Äôve set group = \"txhousing-trellis\"). txsmall %&gt;% group_by(city) %&gt;% do( p = highlight_key(., ~year, group = &quot;txhousing-trellis&quot;) %&gt;% plot_ly(showlegend = FALSE) %&gt;% group_by(year) %&gt;% add_lines( x = ~month, y = ~median, text = ~year, hoverinfo = &quot;text&quot; ) %&gt;% add_annotations( text = ~unique(city), x = 0.5, y = 1, xref = &quot;paper&quot;, yref = &quot;paper&quot;, xanchor = &quot;center&quot;, yanchor = &quot;bottom&quot;, showarrow = FALSE ) ) %&gt;% subplot(nrows = 2, margin = 0.05, shareY = TRUE, shareX = TRUE, titleY = FALSE) FIGURE 17.16: Using plot_ly() instead of ggplotly() to implement a linked trellis display. 17.4.2 Statistical queries 17.4.2.1 Statistical queries with plot_ly() Figure 17.7 introduced the concept of leveraging statistical trace types inside the graphical querying framework. This section gives some more examples of leveraging these trace types to dynamically produce statistical summaries of graphical queries. But first, to help understand what makes a trace ‚Äústatistical‚Äù, consider the difference between add_bars() and add_histogram() (described in detail in Section 6). The important difference here is that add_bars() requires the bar heights to be pre-specified, whereas plotly.js does the relevant computations in add_histogram(). More generally, with a statistical trace, you provide a collection of ‚Äúraw‚Äù values and plotly.js performs the statistical summaries necessary to render the graphic. As Figure 17.24 shows, sometimes you‚Äôll want to fix certain parameters of the summary (e.g., number of bins in a histogram) to ensure the selection layer is comparable to original layer. Figure 17.17 demonstrates routing of a scatterplot brushing event to two different statistical trace types: add_boxplot() and add_histogram(). Here we‚Äôve selected all cars with 4 cylinders to show that cylinders appears to have a significant impact on miles per gallon for pickups and sport utility vehicles, but the interactive graphic allows us to query any subset of cars. Often times, with scatterplot brushing, it‚Äôs desirable to have the row index inform the SQL query (i.e., have a 1-to-1 mapping between a row of data and the marker encoding that row). This happens to be the default behavior of highlight_key() ‚Äì if no data variable is specified, then it automatically uses the row index as the querying variable. demo(&quot;crosstalk-highlight-binned-target-a&quot;, package = &quot;plotly&quot;) FIGURE 17.17: Linking a (jittered) dotplot of engine displacement by number of cylinders with boxplots of miles per gallon split by class and a bar chart of Dynamic 2-way ANOVA. When using a statistical trace type with graphical queries, it‚Äôs often desirable to set the querying variable as the row index. That‚Äôs because, with a statistical trace, numerous data values are attached to each graphical mark; and in that case, it‚Äôs most intuitive if each value queries just one observation. Figure 17.18 gives a simple example of linking a (dynamic) bar chart with a scatterplot in this way to allow us to query interesting regions of the data space defined by engine displacement (disp), miles per gallon highway (hwy), and the class of car (class). Notice how selections can derive from either view, and since we‚Äôve specified \"plotly_selected\" as the on event, either rectangular or lasso selections can be used to trigger the query. d &lt;- highlight_key(mpg) base &lt;- plot_ly(d, color = I(&quot;black&quot;), showlegend = FALSE) subplot( add_histogram(base, x = ~class), add_markers(base, x = ~displ, y = ~hwy) ) %&gt;% # Selections are actually additional traces, and, by default, # plotly.js will try to dodge bars placed under the same category layout(barmode = &quot;overlay&quot;, dragmode = &quot;lasso&quot;) %&gt;% highlight(&quot;plotly_selected&quot;) FIGURE 17.18: Linking a bar chart with a scatterplot to query interesting regions of the data space defined by engine displacement (disp), miles per gallon highway (hwy), and the class of car (class). Notice how, by using add_histogram(), the number of cars within each class is dynamically computed by plotly.js. Figure 17.19 adds two more statistical trace types to Figure 17.18 to further explore how miles per gallon highway is related to fuel type (fl) and front/rear/4 wheel drive (drv). In particular, one can effectively condition on these discrete variables to see how the other distributions respond by brushing and dragging over markers. For example, in Figure 17.19, front-wheel drive cars are highlighted in red, then 4-wheel drive cars in blue, and as a result, we can see that the main effect of going from 4 to front wheel-drive is are also large interaction effect sizes with regular and diesel fuel types. d &lt;- highlight_key(mpg) base &lt;- plot_ly(d, color = I(&quot;black&quot;), showlegend = FALSE) subplot( add_markers(base, x = ~displ, y = ~hwy), add_boxplot(base, x = ~fl, y = ~hwy) %&gt;% add_markers(x = ~fl, y = ~hwy, alpha = 0.1), add_trace(base, x = ~drv, y = ~hwy, type = &quot;violin&quot;) %&gt;% add_markers(x = ~drv, y = ~hwy, alpha = 0.1), shareY = TRUE ) %&gt;% subplot(add_histogram(base, x = ~class), nrows = 2) %&gt;% # Selections are actually additional traces, and, by default, # plotly.js will try to dodge bars placed under the same category layout(barmode = &quot;overlay&quot;) %&gt;% highlight(&quot;plotly_selected&quot;, dynamic = TRUE) FIGURE 17.19: Using statistical queries to perform a 2-way ANOVA on the mpg dataset. Cars with front-wheel drive are highlighted in red and 4-wheel drive highlighted in blue. The dynamically rendered boxplots by fuel type indicate significant interaction effects. 17.4.3 Statistical queries with ggplotly() Compared to plot_ly(), statistical queries (client-side) with ggplotly() are fundamentally limited. That‚Äôs because, the statistical R functions that ggplot2 relies on to generate the graphical layers can‚Äôt necessarily be recomputed with different input data in your web browser. That being said, this is really only an issue when attempting to target a ggplot2 layer with a non-identity statistic (e.g., geom_smooth(), stat_summary(), etc). In that case, one should consider linking views server-side, as covered in section 18. As Figure 17.20 demonstrates, you can still have a ggplot2 layer with a non-identity statistic serve as the source of a selection. In that case, ggplotly() will automatically attach all the input values of the querying variable into the creation of the relevant graphical object (e.g. the fitted line). That is why, in the example below, when a fitted line is hovered upon, all the points belonging to that particular group are highlighted, even when the querying variable is the row index. m &lt;- highlight_key(mpg) p &lt;- ggplot(m, aes(displ, hwy, colour = class)) + geom_point() + geom_smooth(se = FALSE, method = &quot;lm&quot;) ggplotly(p) %&gt;% highlight(&quot;plotly_hover&quot;) FIGURE 17.20: Engine displacement versus highway miles per gallon by class of car. The linear model for each class, as well as the individual observations, can be selected by hovering over the line of fitted values. An individual observation can also be selected by hovering over the relevant point. Figure 17.20 demonstrates highlighting in a single view when the querying variable is the row index, but the linking could also be done by matching the querying variable with the ggplot2 group of interest, as is done in Figure 17.21. This way, when a user highlights an individual point, it highlights the entire group instead of just that point. m &lt;- highlight_key(mpg, ~class) p1 &lt;- ggplot(m, aes(displ, fill = class)) + geom_density() p2 &lt;- ggplot(m, aes(displ, hwy, fill = class)) + geom_point() subplot(p1, p2) %&gt;% hide_legend() %&gt;% highlight(&quot;plotly_hover&quot;) FIGURE 17.21: Clicking on a density estimate to highlight all the raw observations that went into that estimate. In summary, we‚Äôve learned numerous things about statistical queries: A statistical trace (e.g., add_histogram(), add_boxplot(), etc) can be used as both the source and target of a graphical query. When a statistical trace is the target of a graphical query, it‚Äôs often desirable to have the row index assigned as the querying variable. A ggplot2 layer can be used as the source of a graphical query, but when it is the target, non-trivial statistical functions can not be recomputed client-side. In that case, one should consider linking views server side, as covered in section 18. 17.4.4 Geo-spatial queries Section 5 covers several different approaches25 for rendering geo-spatial information, and each approach supports graphical querying. One clever approach is to render a 3D globe as a surface, then layer on geo-spatial data on top of that globe with a scatter3d trace. Not only is 3D a nice way to visualize geospatial data that has altitude (in addition to latitude and longitude), but it also grants the ability to interpolate color along a path. Figure 17.22 renders tropical storms paths on a 3D globe and uses color to encode the altitude of the storm at that point. Below the 3D view is a 2D view of altitude versus distance traveled. These views are linked by a graphical query where the querying variable is the storm ID. demo(&quot;sf-plotly-3D-globe&quot;, package = &quot;plotly&quot;) FIGURE 17.22: Linking a 3D globe with tropical storm paths to a 2D view of the storm altitude versus distance traveled. A more widely used approach to geo-spatial data visualization is to render lat/lon data on a basemap layer that updates in response to zoom events. The plot_mapbox() function from plotly does this via integration with mapbox. Figure 17.23 uses plot_mapbox() highlighting earthquakes west of Fiji to compare the relative frequency of their magnitude and number of reporting stations (to the overall relative frequency). eqs &lt;- highlight_key(quakes) # you need a mapbox API key to use plot_mapbox() # https://www.mapbox.com/signup/?route-to=https://www.mapbox.com/studio/account/tokens/ map &lt;- plot_mapbox(eqs, x = ~long, y = ~lat) %&gt;% add_markers(color = ~depth) %&gt;% layout( mapbox = list( zoom = 2, center = list(lon = ~mean(long), lat = ~mean(lat)) ) ) %&gt;% highlight(&quot;plotly_selected&quot;) # shared properties of the two histograms hist_base &lt;- plot_ly(eqs, color = I(&quot;black&quot;), histnorm = &quot;probability density&quot;) %&gt;% layout(barmode = &quot;overlay&quot;, showlegend = FALSE) %&gt;% highlight(selected = attrs_selected(opacity = 0.5)) histograms &lt;- subplot( add_histogram(hist_base, x = ~mag), add_histogram(hist_base, x = ~stations), nrows = 2, titleX = TRUE ) crosstalk::bscols(histograms, map) FIGURE 17.23: Querying earthquakes by location and displaying their a histogram of their magnitude and number of stations. Every 2D mapping approach in plotly (e.g., plot_mapbox(), plot_ly(), geom_sf()) has a special understanding of the simple features data structure provided by the sf package. Sievert (2018b) and Sievert (2018c) goes more in depth about simple features support in plotly and provides more examples of graphical queries and animation with simple features, but Figure 17.24 demonstrates a clever ‚Äòtrick‚Äô to get bi-directional brushing between polygon centroids and a histogram showing a numerical summary of the polygons. The main idea is to leverage the st_centroid() function from sf to get the polygons centroids, then link those points to the histogram via highlight_key(). library(sf) nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;), quiet = TRUE) nc_query &lt;- highlight_key(nc, group = &quot;sf-rocks&quot;) nc_centroid &lt;- highlight_key(st_centroid(nc), group = &quot;sf-rocks&quot;) map &lt;- plot_mapbox(color = I(&quot;black&quot;)) %&gt;% add_sf(data = nc) %&gt;% add_sf(data = nc_centroid) %&gt;% layout(showlegend = FALSE) %&gt;% highlight(&quot;plotly_selected&quot;, dynamic = TRUE) hist &lt;- plot_ly(color = I(&quot;black&quot;)) %&gt;% add_histogram( data = nc_query, x = ~AREA, xbins = list(start = 0, end = 0.3, size = 0.01) ) %&gt;% layout(barmode = &quot;overlay&quot;) %&gt;% highlight(&quot;plotly_selected&quot;) crosstalk::bscols(widths = 12, map, hist) FIGURE 17.24: Graphically querying North Carolina by location and area 17.4.5 Linking with other htmlwidgets The plotly package is able to share graphical queries with a limited set of other R packages that build upon the htmlwidgets standard. At the moment, graphical queries work best with leaflet and DT. Figure 17.25 links plotly with DT, and since the data set linked bewteen the two is an sf data frame, each row of the table is linked to a polygon on the map through the row index of the same dataset. demo(&quot;sf-dt&quot;, package = &quot;plotly&quot;) FIGURE 17.25: Linking a plot_ly()-based map with a datatable() from the DT package. As already shown in section 17.2, plotly can share graphical queries with leaflet. Some of the more advanced features (e.g., persistent selection with dynamic color brush) are not yet officially supported, but you can still leverage these experimental features by installing the experimental versions of leaflet referenced in the code below. For example, in Figure 17.26, persistent selection with dynamic colors allows one to first highlight earthquakes with a magnitude of 5 or higher in red, then earthquakes with a magnitude of 4.5 or lower, and the corresponding earthquakes are highlighted in the leaflet map. This reveals an interesting relationship in magnitude and geographic location, and leaflet provides the ability to zoom and pan on the map to investigate regions that have a high density of quakes. # requires an experimental version of leaflet # devtools::install_github(&quot;rstudio/leaflet#346&quot;) library(leaflet) qquery &lt;- highlight_key(quakes) p &lt;- plot_ly(qquery, x = ~depth, y = ~mag) %&gt;% add_markers(alpha = 0.5) %&gt;% highlight(&quot;plotly_selected&quot;, dynamic = TRUE) map &lt;- leaflet(qquery) %&gt;% addTiles() %&gt;% addCircles() # persistent selection can be specified via options() withr::with_options( list(persistent = TRUE), crosstalk::bscols(widths = c(6, 6), p, map) ) FIGURE 17.26: Linking views between plotly and leaflet to explore the relation between magnitude and geographic location of earthquakes around Fiji. Figure 17.27 uses another experimental feature of querying leaflet polygons in response to direct manipulation of a plotly graph. # requires an experimental version of leaflet # devtools::install_github(&quot;rstudio/leaflet#391&quot;) library(leaflet) library(sf) nc &lt;- system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;) %&gt;% st_read() %&gt;% st_transform(4326) %&gt;% highlight_key() map &lt;- leaflet(nc) %&gt;% addTiles() %&gt;% addPolygons( opacity = 1, color = &#39;white&#39;, weight = .25, fillOpacity = .5, fillColor = &#39;blue&#39;, smoothFactor = 0 ) p &lt;- plot_ly(nc) %&gt;% add_markers(x = ~BIR74, y = ~SID79) %&gt;% layout(dragmode = &quot;lasso&quot;) %&gt;% highlight(&quot;plotly_selected&quot;) crosstalk::bscols(map, p) FIGURE 17.27: Querying polygons on a leaflet map in response to direct manipulation of a plotly graph. 17.4.6 Generalized pairs plots Section ?? introduced the generalized pairs plot made via GGally::ggpairs() which, like ggplot(), partially supports graphical queries. The brushing in Figure 17.28 demonstrates how the scatterplots can respond to a graphical queries (allowing us to see how these relationships behave in specific subsections of the data space), but for the same reasons outlined in 17.4.3, the statistical summaries (e.g., the density plots and correlations) don‚Äôt respond to the graphical query. highlight_key(iris) %&gt;% GGally::ggpairs(aes(color = Species), columns = 1:4) %&gt;% ggplotly() %&gt;% highlight(&quot;plotly_selected&quot;) FIGURE 17.28: Brushing a scatterplot matrix via the ggpairs() function in the GGally package. A video demonstrating the graphical queries can be viewed here 17.4.7 Querying diagnostic plots In addition to the ggpairs() function for generalized pairs plots, the GGally packages also has a ggnostic() function which generates a matrix of diagnostic plots from a model object using ggplot2. Each column of this matrix represents a different explanatory variable and each row represents a different diagnostic measure. Figure 17.29 shows the default display for a linear model, which includes residuals (resid), estimates of residual standard deviation when a particular observation is excluded (sigma), diagonals from the projection matrix (hat), and cooks distance (cooksd). library(dplyr) library(GGally) mtcars %&gt;% # for better tick labels mutate(am = recode(am, `0` = &quot;automatic&quot;, `1` = &quot;manual&quot;)) %&gt;% lm(mpg ~ wt + qsec + am, data = .) %&gt;% ggnostic(mapping = aes(color = am)) %&gt;% ggplotly() FIGURE 17.29: Graphical queries applied to multiple diagnostic plots of a linear model. The ggplotly() function has a special method for ggnostic() that adds graphical queries automatically with support for both individual observations (e.g. points) as well as meaningful groups (e.g., automatic vs manual). Injecting interactivity into ggnostic() via ggplotly() enhances the diagnostic plot in at least two ways. Coloring by a factor variable in the model allows us to highlight that region of the design matrix by selecting a relevant statistical summary, which can help avoid overplotting when dealing with numerous factor levels. For example, in Figure 17.29, the user first highlights diagnostics for cars with manual transmission (in blue), then cars with automatic transmission (in red). Perhaps more widely useful is the ability to highlight individual observations since most of these diagnostics are designed to identify highly influential or unusual observations. In Figure 17.29, there is one observation with a noticeably high value of cooksd, which suggests the observation has a large influence on the fitted model. Clicking on that point highlights its corresponding diagnostic measures, plotted against each explanatory variable. Doing so makes it obvious that this observation is influential since it has a unusually high response/residual in a fairly sparse region of the design space (i.e., it has a pretty high value of wt) and removing it would significantly reduce the estimated standard deviation (sigma). By comparison, the other two observations with similar values of wt have a response value very close to the overall mean, so even though their value of hat is high, their value of sigma is low. 17.4.7.1 Subset queries via list-columns All the graphical querying examples thus far use highlight_key() to attach values from atomic vector of a data frame to graphical marker(s), but what non-atomic vectors (i.e., list-columns)? When it comes to emitting events, there is no real difference ‚Äì plotly will ‚Äúinform the world‚Äù of a set of selection values, which is the union of all data values in the graphical query. However, as Figure 17.30 demonstrates, when plotly receives a list-column query, it will highlight graphical markers with data value(s) that are a subset of the selected values. For example, when the point [3, 3] is queried, plotly will highlight all markers that represent a subset of {A, B, C}, which is why both [1, 1] (representing the set {A}) and (2, 2) (representing the set {A, B}) are highlighted. d &lt;- tibble::tibble( x = 1:4, y = 1:4, key = lapply(1:4, function(x) LETTERS[seq_len(x)]), txt = sapply(key, function(x) sprintf(&quot;{%s}&quot;, paste(x, collapse = &quot;, &quot;))) ) highlight_key(d, ~key) %&gt;% plot_ly(x = ~x, y = ~y, text = ~txt, hoverinfo = &quot;text&quot;) %&gt;% highlight(&quot;plotly_selected&quot;) %&gt;% layout(dragmode = &quot;lasso&quot;) FIGURE 17.30: A simple example of subset queries via a list-column One compelling use case for subset queries is dendograms. In fact, plotly provides a plot_dendro() function for making dendrograms with support for subset queries. Figure 17.31 gives an example of brushing a branch of a dendrogram to query leafs that are similar in some sense. Any dendrogram object can be provided to plot_dendro(), but this particular example visualizes the similarity of US states in terms of their arrest statistics via a hierarchical clustering model on the USArrests dataset. hc &lt;- hclust(dist(USArrests), &quot;ave&quot;) dend1 &lt;- as.dendrogram(hc) plot_dendro(dend1, height = 600) %&gt;% hide_legend() %&gt;% highlight(&quot;plotly_selected&quot;, persistent = TRUE, dynamic = TRUE) FIGURE 17.31: Leveraging hierarchical selection and persistent brushing to paint branches of a dendrogram. Figure 17.32 links the dendrogram from Figure 17.31 to a map of the US and a grand tour of the arrest statistics to better understand and diagnose a hierarchical clustering methodology. By highlighting branches of the dendrogram, we can effectively choose a partitioning of the states into similar groups, and see how that model choice projects to the data space26 through a grand tour. The grand tour is a special kind of animation that interpolates between random 2D projections of numeric data allowing the viewer to perceive the shape of a high-dimensional point cloud (Asimov 1985). Note how the grouping portrayed in Figure 17.32 does a fairly good job of staying separated in the grand tour. demo(&quot;animation-tour-USArrests&quot;, package = &quot;plotly&quot;) FIGURE 17.32: Linking a dendrogram to a grand tour and map of the USArrests data to visualize a classification in 5 dimensions. 17.5 Limitations Linking of data views, as defined in Section ??, has a much larger scope than the graphical querying framework covered in this chapter. For serious statistical analysis, one often needs to link views in a way that can not be easily compiled down to client-side web technologies. For these use cases, the R package shiny makes it very easy to build on concepts we‚Äôve already covered to build more powerful client-server applications entirely in R, without having to learn any HTML, CSS, or JavaScript. The next chapter 18 gives a brief introduction to shiny, then dives right into concepts related to linking plotly graphics to other arbitrary views. References "],
["linking-server-side.html", "18 Server-side linking with shiny 18.1 Embedding plotly in shiny 18.2 Leveraging plotly input events 18.3 Improving performance 18.4 Advanced applications 18.5 Discussion", " 18 Server-side linking with shiny Section 17.1 covers an approach to linking views client-side with graphical database queries, but not every linked data view can be reasonably framed as a database query. If you need more control, you have at least two more options: add custom JavaScript (covered in section 23) and/or link views server-side via a web application. Some concepts useful for the former approach are covered in 23, but this chapter is all about the latter approach. There are several different frameworks for creating web applications via R, but we‚Äôll focus our attention on linking plotly graphs with shiny ‚Äì an R package for creating reactive web applications entirely in R. Shiny‚Äôs reactive programming model allows R programmers to build upon their existing R knowledge and create data-driven web applications without any prior web programming experience. Shiny itself is largely agnostic to the engine used to render data views (that is, you can incorporate any sort of R output), but shiny itself also adds some special support for interacting with static R graphics and images (Chang 2017). When linking graphics in a web application, there are tradeoffs to consider when using static R plots over web-based graphics. As it turns out, those tradeoffs complement nicely with the relative strengths and weaknesses of linking views with plotly, making their combination a powerful toolkit for linking views on the web from R. Shiny itself provides a way to access events with static graphics made with any of the following R packages: graphics, ggplot2, and lattice. These packages are very mature, fully-featured, well-tested, and support a incredibly wide range of graphics, but since they must be regenerated on the server, they are fundamentally limited from an interactive graphics perspective. Comparatively speaking, plotly does not have the same range and history, but it does provide more options and control over interactivity. More specifically, because plotly is inherently web-based, it allows for more control over how the graphics update in response to user input (e.g., change the color of a few points instead of redrawing the entire image). This idea is explored in more depth in section 18.3.1. This chapter teaches you how to use plotly graphs inside shiny, how to get those graphics communicating with other types of data views, and how to do it all efficiently. Section 18.1 provides an introduction to shiny it‚Äôs reactive programming model, Section 18.2 shows how to leverage plotly inputs in shiny to coordinate multiple views, Section 18.3.1 shows how to respond to input changes efficiently, and Section 18.4 demonstrates some advanced applications. 18.1 Embedding plotly in shiny Before linking views with plotly inside shiny, let‚Äôs first talk about how to embed plotly inside a basic shiny app! Through a couple basic examples, you‚Äôll learn the basic components of a shiny and get a feel for shiny‚Äôs reactive programming model, as well as pointers to more learning materials. 18.1.1 Your first shiny app The most common plotly+shiny pattern uses a shiny input to control a plotly output. Figure 18.1 gives a simple example of using shiny‚Äôs selectizeInput() function to create a dropdown that controls a plotly graph. This example, as well as every other shiny app, has two main parts: The user interface, ui, defines how inputs and output widgets are displayed on the page. The fluidPage() function offers a nice and quick way get a grid-based responsive layout27, but it‚Äôs also worth noting the UI is completely customizable28, and packages such as shinydashboard make it easy to leverage more sophisticated layout frameworks (Chang and Borges Ribeiro 2018). The server function, server, defines a mapping from input values to output widgets. More specifically, the shiny server is an R function() between input values on the client and outputs generated on the web server. Every input widget, including the selectizeInput() in Figure 18.1, is tied to a input value that can be accesssed on the server inside a reactive expression. Shiny‚Äôs reactive expressions build a dependency graph between outputs (aka, reactive endpoints) and inputs (aka, reactive sources). The true power of reactive expressions lies in their ability to chain together and cache computations, but let‚Äôs first focus on generating outputs. In order to generate an output, you have to choose a suitable function for rendering the result of a reactive expression. Figure 18.1 uses the renderPlotly() function to render a reactive expression that generates a plotly graph. This expression depends in the input value input$cities (i.e., the input value tied to the input widget with an inputId of \"cities\") and stores the output as output$p. This instructs shiny to insert the reactive graph into the plotlyOutput(outputId = \"p\") container defined in the user interface. Click to show/hide the code library(shiny) library(plotly) ui &lt;- fluidPage( selectizeInput( inputId = &quot;cities&quot;, label = &quot;Select a city&quot;, choices = unique(txhousing$city), selected = &quot;Abilene&quot;, multiple = TRUE ), plotlyOutput(outputId = &quot;p&quot;) ) server &lt;- function(input, output, ...) { output$p &lt;- renderPlotly({ plot_ly(txhousing, x = ~date, y = ~median) %&gt;% filter(city %in% input$cities) %&gt;% group_by(city) %&gt;% add_lines() }) } shinyApp(ui, server) FIGURE 18.1: Using a shiny input widget to control which time series are shown on a plotly graph. If, instead of a plotly graph, a reactive expression generates a static R graphic, simply use renderPlot() (instead of renderPlotly()) to render it and plotOutput() (instead of plotlyOutput()) to position it. Other shiny output widgets also use this naming convention: renderDataTable()/datatableOutput(), renderPrint()/verbatimTextOutput(), renderText()/textOutput(), renderImage()/imageOutput(), etc. Packages that are built on the htmlwidgets standard (e.g. plotly and leaflet) are, in some sense, also shiny output widgets that are encouraged to follow this same naming convention (e.g. renderPlotly()/plotlyOutput() and renderLeaflet()/leafletOutput()). Shiny also comes pre-packaged with a handful of other useful input widgets. Although many shiny apps use them straight ‚Äúout-of-the-box‚Äù, input widgets can easily be stylized with CSS and/or SASS, and even custom input widgets can be integrated (Mastny 2018, @shiny-custom-inputs). selectInput()/selectizeInput() for dropdown menus. numericInput() for a single number. sliderInput() for a numeric range. textInput() for a character string. dateInput() for a single date. dateRangeInput() for a range of dates. fileInput() for uploading files. checkboxInput()/checkboxGroupInput()/radioButtons() for choosing a list of options. Going forward our focus is to link multiple graphs in shiny through direct manipulation, so we focus less on using these input widgets, and more on using plotly and static R graphics as inputs to other output widgets. Section 18.2 provides an introduction to this idea, but before we learn how to access these input events, you may want to know a bit more about rendering plotly inside shiny. 18.1.2 Hiding and redrawing on resize The renderPlotly() function renders anything that the plotly_build() function understands, including plot_ly(), ggplotly(), and ggplot2 objects.29 It also renders NULL as an empty HTML div, which is handy for certain cases where it doesn‚Äôt make sense to render a graph. Figure 18.2 leverages these features to render an empty div while selectizeInput()‚Äôs placeholder is shown, but then render a plotly graph via ggplotly() once cities have been selected. Figure 18.2 also shows how to make the plotly output depend on the size of the container that holds the plotly graph. By default, when a browser is resized, the graph size is changed purely client-side, but this reactive expression will re-execute when the browser window is resized. Due to technical reasons this can improve ggplotly() resizing behavior30, but should be used with caution when handling large data and long render times. Click to show/hide the code library(shiny) library(plotly) cities &lt;- unique(txhousing$city) ui &lt;- fluidPage( selectizeInput( inputId = &quot;cities&quot;, label = NULL, # placeholder prompt is triggered when first choice is an empty string choices = c(&quot;Please choose a city&quot; = &quot;&quot;, cities), multiple = TRUE ), plotlyOutput(outputId = &quot;p&quot;) ) server &lt;- function(input, output, session, ...) { output$p &lt;- renderPlotly({ req(input$cities) if (identical(input$cities, &quot;&quot;)) return(NULL) p &lt;- ggplot(data = filter(txhousing, city %in% input$cities)) + geom_line(aes(date, median, group = city)) ggplotly(p, height = session$clientData$output_p_height, width = session$clientData$output_p_width) }) } shinyApp(ui, server) FIGURE 18.2: Rendering a plotly graph in shiny if and only if the selectizeInput()‚Äôs dropdown is non-empty. When the graph is present, and the window is resized, then the reactive expression is re-evaluated. When a reactive expression inside renderPlotly() is re-executes, it triggers a full redraw of the plotly graph on the client. Generally speaking, this makes your shiny app logic easy to reason about, but it‚Äôs not always performant enough. For example, say you have a scatterplot with 10s of thousands of points, and you just want to add a fitted line to those points (in respond to input event)? Instead of redrawing the whole plot from scratch, it can be way more performant to partially update specific components of the visual. Section 18.3.1 covers this idea through a handful of examples. 18.2 Leveraging plotly input events Section 18.1 covered how to render shiny output widgets (e.g., plotlyOutput()) that depend on a input widget, but what about having an output act like an input to another output? For example, say we‚Äôd like to dynamically generate a bar chart (i.e., an output) based on a point clicked on a scatter-plot (i.e., an input event tied to an output widget). In addition to shiny‚Äôs static graph and image rendering functions (e.g., plotOutput()/imageOutput()), there are a handful of other R packages that expose user interaction with ‚Äúoutput‚Äù widget(s) as input value(s). Cheng (2018c) and Xie (2018) describe the interface for the leaflet and DT packages. This section outlines the interface for plotlyOutput(). This sort of functionality plays a vital role in linking of views through direct manipulation, similar to what we‚Äôve already seen in section 17.1, but having access to plotly events on a shiny server allows for much more flexibility than linking views purely client-side. The event_data() function is the most straight-forward way to access a plotly input events in shiny. Although event_data() is function, it references and returns a shiny input value, so event_data() needs to be used inside a reactive context. Most of these available events are data-specific traces (e.g., \"plotly_hover\", \"plotly_click\", \"plotly_selected\", etc), but there are also some that are layout-specific (e.g., \"plotly_relayout\"). Most plotly.js events31 are accessible through this interface ‚Äì for a complete list see the help(event_data) documentation page. Numerous Figures in the following sections show how to access common plotly events in shiny and do something with the result. When using these events to inform another view of the data, it‚Äôs often necessary to know what portion of data was queried in the event (i.e., the x/y positions alone may not be enough to uniquely identify the information of interest). For this reason, it‚Äôs often a good idea to supply a key (or customdata) attribute, so that you can map the event data back to the original data. The key attribute is only supported in shiny, but customdata is officially supported by plotly.js, and thus can also be used to attach meta-information to event ‚Äì see section 23 for more details. 18.2.1 Dragging events There are currently four different modes for mouse click+drag behavior (i.e., dragmode) in plotly.js: zoom, pan, rectangular selection, and lasso selection. This mode may be changed interactively via the modebar that appears above a plotly graph, but the default mode can also be set from the command-line. The default dragmode in Figure 18.3 is set to 'select', so that dragging draws a rectangular box which highlights markers. When in this mode, or in the lasso selection mode, information about the drag event can be accessed in four different ways: \"plotly_selecting\", \"plotly_selected\", \"plotly_brushing\", and \"plotly_brushed\". Both the \"plotly_selecting\" and \"plotly_selected\" events emit information about trace(s) appearing within the interior of the brush ‚Äì the only difference is that \"plotly_selecting\" fires repeatedly during drag events, whereas \"plotly_selected\" fires after drag events (i.e., after the mouse has been released). The semantics behind \"plotly_brushing\" and \"plotly_brushed\" are similar, but these emit the x/y limits of the selection brush. As for the other two dragging modes (zoom and pan), since they modify the range of the x/y axes, information about these events can be accessed through \"plotly_relayout\". Sections 18.3.1 and 18.4 both have advanced applications of these dragging events. Click to show/hide the code library(shiny) ui &lt;- fluidPage( radioButtons(&quot;plotType&quot;, &quot;Plot Type:&quot;, choices = c(&quot;ggplotly&quot;, &quot;plotly&quot;)), plotlyOutput(&quot;plot&quot;), verbatimTextOutput(&quot;selecting&quot;), verbatimTextOutput(&quot;brushing&quot;), verbatimTextOutput(&quot;relayout&quot;) ) server &lt;- function(input, output, session) { nms &lt;- row.names(mtcars) output$plot &lt;- renderPlotly({ p &lt;- if (identical(input$plotType, &quot;ggplotly&quot;)) { ggplotly(ggplot(mtcars, aes(x = mpg, y = wt, key = nms)) + geom_point()) } else { plot_ly(mtcars, x = ~mpg, y = ~wt, key = nms) } layout(p, dragmode = &quot;select&quot;) }) output$selecting &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_selecting&quot;) if (is.null(d)) &quot;Selected data appears here&quot; else d }) output$brushing &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_brushing&quot;) if (is.null(d)) &quot;Selection brush limits appear here&quot; else d }) output$relayout &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_relayout&quot;) if (is.null(d)) &quot;Zoom and pan info appears here&quot; else d }) } shinyApp(ui, server) FIGURE 18.3: Accessing event data from click and drag events. 18.2.2 3D events Drag selection events (i.e., \"plotly_selecting\") are currently only available for 2D charts, but other common events are generally supported for any type of graph, including 3D charts. Figure 18.4 accesses various events in 3D including: \"plotly_hover\", \"plotly_click\", \"plotly_legendclick\", \"plotly_legenddoubleclick\", and \"plotly_relayout\". The data emitted via \"plotly_hover\" and \"plotly_click\" is structured similarly to data emitted from \"plotly_selecting\"/\"plotly_selected\". Figure 18.4 also demonstrates how one can react to particular components of a conflated event like \"plotly_relayout\". That is, \"plotly_relayout\" will fire whenever any part of the layout has changed, so if we want to trigger behavior if and only if there are changes to the camera eye, one could first check if the information emitted contains information about the camera eye. Click to show/hide the code library(shiny) ui &lt;- fluidPage( plotlyOutput(&quot;plot&quot;), verbatimTextOutput(&quot;hover&quot;), verbatimTextOutput(&quot;click&quot;), verbatimTextOutput(&quot;legendclick&quot;), verbatimTextOutput(&quot;legend2click&quot;), verbatimTextOutput(&quot;relayout&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlotly({ plot_ly(mtcars, x = ~wt, y = ~mpg, z = ~disp, color = ~factor(cyl)) }) output$hover &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_hover&quot;) if (is.null(d)) &quot;Hover events appear here&quot; else d }) output$click &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_click&quot;) if (is.null(d)) &quot;Click events appear here&quot; else d }) output$legendclick &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_legendclick&quot;)$name if (is.null(d)) &quot;Legend click&quot; else d }) output$legend2click &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_legenddoubleclick&quot;)$name if (is.null(d)) &quot;Legend double-click&quot; else d }) output$relayout &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_relayout&quot;)$scene.camera$eye if (is.null(d)) &quot;Camera eye info&quot; else d }) } shinyApp(ui, server) FIGURE 18.4: Accessing 3D events. 18.2.3 Edit events A little known fact about plotly is that you can directly manipulate annotations, title, shapes (e.g., circle, lines, rectangles), legends, and more by simply adding config(p, editable = TRUE) to a plot p. Moreover, since these are all layout components, we can access and respond to these ‚Äòedit events‚Äô by listening to the \"plotly_relayout\" events. Figure 18.5 demonstrates how display access information about changes in annotation positioning and content. Click to show/hide the code library(shiny) ui &lt;- fluidPage( plotlyOutput(&quot;p&quot;), verbatimTextOutput(&quot;info&quot;) ) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ plot_ly() %&gt;% layout( annotations = list( list( text = emo::ji(&quot;fire&quot;), x = 0.5, y = 0.5, xref = &quot;paper&quot;, yref = &quot;paper&quot;, showarrow = FALSE ), list( text = &quot;fire&quot;, x = 0.5, y = 0.5, xref = &quot;paper&quot;, yref = &quot;paper&quot; ) )) %&gt;% config(editable = TRUE) }) output$info &lt;- renderPrint({ event_data(&quot;plotly_relayout&quot;) }) } shinyApp(ui, server) FIGURE 18.5: Accessing information about direct manipulation of annotations. Figure 18.6 demonstrates directly manipulating a circle shape and accessing the new positions of the circle. In constrast to Figure 18.5, which made everything (e.g. the plot and axis titles) editable via config(p, editable = TRUE), note how Figure 18.6 makes use of the edits argument to make only the shapes editable. Click to show/hide the code library(shiny) library(plotly) ui &lt;- fluidPage( plotlyOutput(&quot;p&quot;), verbatimTextOutput(&quot;event&quot;) ) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ plot_ly() %&gt;% layout( xaxis = list(range = c(-10, 10)), yaxis = list(range = c(-10, 10)), shapes = list( type = &quot;circle&quot;, fillcolor = &quot;gray&quot;, line = list(color = &quot;gray&quot;), x0 = -10, x1 = 10, y0 = -10, y1 = 10, xsizemode = &quot;pixel&quot;, ysizemode = &quot;pixel&quot;, xanchor = 0, yanchor = 0 ) ) %&gt;% config(edits = list(shapePosition = TRUE)) }) output$event &lt;- renderPrint({ event_data(&quot;plotly_relayout&quot;) }) } shinyApp(ui, server) FIGURE 18.6: Accessing information about direct manipulation of circle shapes. Figure 18.7 demonstrates a linear model that reacts to edited circle shape positions using the \"plotly_relayout\" event in shiny. This interactive tool is an effective way to visualize the impact of high leverage points on a linear model fit. The main idea is to have the model fit (as well as it‚Äôs summary and predicted values) depend on the current state of x and y values, which here is stored and updated via reactiveValues(). Section 18.2.8 has more examples of using reactive values to maintain state within a shiny application. plotly_example(&quot;shiny&quot;, &quot;drag_marker&quot;) FIGURE 18.7: Editing circle shape positions to dynamically alter a linear model summary and fitted line. This is useful mainly as a teaching device to visually demonstrate the effect of high leverage points on a simple linear model. Figure 18.8 uses an editable vertical line and the plotly_relayout event data to ‚Äòsnap‚Äô the line to the closest point in a sequence of x values. It also places a marker on the intersection between the vertical line shape and the line chart of y values. Notice how, by accessing event_data() in this way (i.e., the source and target view of the event is the same), the chart is actually fully redrawn every time the line shape moves. If performance were an issue (i.e., we were dealing with lots of lines), this type of interaction likely won‚Äôt be very responsive. In that case, you can use event_data() to trigger side-effects (i.e., partially modify the plot) which is covered in 18.3.1. Click to show/hide the code library(shiny) library(plotly) ui &lt;- fluidPage( plotlyOutput(&quot;p&quot;), verbatimTextOutput(&quot;event&quot;) ) x &lt;- seq(-10, 10) y &lt;- rnorm(length(x)) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ d &lt;- event_data(&quot;plotly_relayout&quot;) selected_point &lt;- if (!is.null(d[[&quot;shapes[0].x0&quot;]])) { # &#39;snap&#39; the x-position from the event to the closest `x` value xint &lt;- d[[&quot;shapes[0].x0&quot;]] xpt &lt;- x[which.min(abs(x - xint))] list(x = xpt, y = y[which(x == xpt)]) } else { # default to list(x = 1, y = y[which(x == 1)]) } plot_ly(color = I(&quot;red&quot;)) %&gt;% add_lines(x = x, y = y) %&gt;% add_markers(x = selected_point$x, y = selected_point$y) %&gt;% layout( shapes = list( type = &quot;line&quot;, line = list(color = &quot;gray&quot;, dash = &quot;dot&quot;), x0 = selected_point$x, x1 = selected_point$x, y0 = 0, y1 = 1, yref = &quot;paper&quot; ) ) %&gt;% config(editable = TRUE) }) } shinyApp(ui, server) FIGURE 18.8: Dragging a vertical line shape and ‚Äòsnapping‚Äô the line to match the closest provided x value. 18.2.4 Relayout vs restyle events Remember every graph has two critical components: data (i.e., traces) and layout. Similar to how \"plotly_relayout\" reports partial modifications to the layout, the \"plotly_restyle\" event reports partial modification to traces. Compared to \"plotly_relayout\", there aren‚Äôt very many native direct manipulation events that would trigger a \"plotly_restyle\" event. For example, zoom/pan events, camera changes, editing annotations/shapes/etc all trigger a \"plotly_relayout\" event, but not many traces allow you to directly manipulate their properties. One notable exception is the \"parcoords\" trace type which has native support for brushing lines along an axis dimension(s). As Figure 18.9 demonstrates, these brush events emit a \"plotly_restyle\" event with the range(s) of the highlighted dimension. Click to show/hide the code library(plotly) library(shiny) ui &lt;- fluidPage( plotlyOutput(&quot;parcoords&quot;), verbatimTextOutput(&quot;info&quot;) ) server &lt;- function(input, output, session) { output$parcoords &lt;- renderPlotly({ plot_ly(iris) %&gt;% add_parcoords() }) output$info &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_restyle&quot;) if (is.null(d)) &quot;Brush along a dimension&quot; else d }) } shinyApp(ui, server) FIGURE 18.9: Using the \"plotly_restyle\" event to access brushed dimensions of a parallel coordinates plot. As Figure 18.10 shows, it‚Äôs possible to use this information to infer which data points are highlighted. The logic to do so is fairly sophisticated, and requires accumulation of the event data, as discussed in section 18.2.8. plotly_example(&quot;shiny&quot;, &quot;event_data_parcoords&quot;) FIGURE 18.10: Displaying the highlighted observations of a parcoords trace. 18.2.5 Scoping events This section leverages the interface for accessing plotly input events introduced in section 18.2 to inform other data views about those events. When managing multiple views that communicate with one another, you‚Äôll need to be aware of which views are a source of interaction and which are a target (a view can be both, at once!). The event_data() function provides a source argument to help refine which view(s) serve as the source of an event. The source argument takes a string ID, and when that ID matches the source of a plot_ly()/ggplotly() graph, then the event_data() is ‚Äúscoped‚Äù to that view. To get a better idea of how this works, consider Figure 18.11 Figure 18.11 allows one to click on a cell of correlation heatmap to generate a scatterplot of the two corresponding variables ‚Äì allowing for a closer look at their relationship. In the case of a heatmap, the event data tied to a plotly_click event contains the relevant x and y categories (e.g., the names of the data variables of interest) and the z value (e.g., the pearson correlation between those variables). In order to obtain click data from the heatmap, and only the heatmap, it‚Äôs important that the source argument of the event_data() function matches the source argument of plot_ly(). Otherwise, if the source argument was not specified event_data(\"plotly_click\") would also fire if and when the user clicked on the scatterplot, likely causing an error. Click to show/hide the code library(shiny) # cache computation of the correlation matrix correlation &lt;- round(cor(mtcars), 3) ui &lt;- fluidPage( plotlyOutput(&quot;heat&quot;), plotlyOutput(&quot;scatterplot&quot;) ) server &lt;- function(input, output, session) { output$heat &lt;- renderPlotly({ plot_ly(source = &quot;heat_plot&quot;) %&gt;% add_heatmap( x = names(mtcars), y = names(mtcars), z = correlation ) }) output$scatterplot &lt;- renderPlotly({ # if there is no click data, render nothing! clickData &lt;- event_data(&quot;plotly_click&quot;, source = &quot;heat_plot&quot;) if (is.null(clickData)) return(NULL) # Obtain the clicked x/y variables and fit linear model to those 2 vars vars &lt;- c(clickData[[&quot;x&quot;]], clickData[[&quot;y&quot;]]) d &lt;- setNames(mtcars[vars], c(&quot;x&quot;, &quot;y&quot;)) yhat &lt;- fitted(lm(y ~ x, data = d)) # scatterplot with fitted line plot_ly(d, x = ~x) %&gt;% add_markers(y = ~y) %&gt;% add_lines(y = ~yhat) %&gt;% layout( xaxis = list(title = clickData[[&quot;x&quot;]]), yaxis = list(title = clickData[[&quot;y&quot;]]), showlegend = FALSE ) }) } shinyApp(ui, server) FIGURE 18.11: Linking each cell of a correlation heatmap to their corresponding scatterplots. 18.2.6 Event priority By default, event_data() only invalidates a reactive expression when the value of it‚Äôs corresponding shiny input changes. Sometimes, you might want a particular event, say \"plotly_click\", to always invalidate a reactive expression. Figure 18.12 shows the difference between this default behavior versus setting priority = 'event'. By default, repeatedly clicking the same marker won‚Äôt update the clock, but when setting the priority argument to event, repeatedly clicking the same marker will update the clock (i.e., it will invalidate the reactive expression). Click to show/hide the code library(shiny) ui &lt;- fluidPage( plotlyOutput(&quot;p&quot;), textOutput(&quot;time1&quot;), textOutput(&quot;time2&quot;) ) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ plot_ly(x = 1:2, y = 1:2, size = I(c(100, 150))) %&gt;% add_markers() }) output$time1 &lt;- renderText({ event_data(&quot;plotly_click&quot;) paste(&quot;Input priority: &quot;, Sys.time()) }) output$time2 &lt;- renderText({ event_data(&quot;plotly_click&quot;, priority = &quot;event&quot;) paste(&quot;Event priority: &quot;, Sys.time()) }) } shinyApp(ui, server) FIGURE 18.12: A demo of input priority versus event priority. Clicking on the same marker repeatedly, by default, won‚Äôt invalidate a reactive expression that depends on ‚Äòplotly_click‚Äô, but it will invalidate when given event priority. There are numerous events accessible through event_data() that don‚Äôt contain any information (e.g., \"plotly_doublelick\", \"plotly_deselect\", \"plotly_afterplot\", etc). These events are automatically given an event priority since their corresponding shiny input value never changes. One common use case for events like \"plotly_doublelick\" (fired when double-clicking in a zoom or pan dragmode) and \"plotly_deselect\" (fired when double-clicking in a selection mode) is to clear or reset accumulating event data. 18.2.7 Handling discrete axes For events that are trace-specific (e.g. \"plotly_click\", \"plotly_hover\", \"plotly_selecting\", etc), the positional data (e.g., x/y/z) is always numeric, so if you have a plot with discrete axes, you might want to know how to map that numeric value back to the relevant input data category. In some cases, you can avoid the problem by assigning the discrete variable of interest to the key/customdata attribute, but you might also want to reserve that attribute to encode other information, like a fill aesthetic. Figure 18.13 shows how to map the numerical x value emitted in a click event back to the discrete variable that it corresponds to (mpg$class) and leverages customdata to encode the fill mapping allowing us to display the data records a clicked bar corresponds to. In both ggplotly() and plot_ly(), categories associated with a character vector are always alphabetized, so if you sort() the unique() character values, then the vector indices will match the x event data values. On the other hand, if x were a factor variable, the x event data would match the ordering of the levels() attribute. Click to show/hide the code library(shiny) library(dplyr) ui &lt;- fluidPage( plotlyOutput(&quot;bars&quot;), verbatimTextOutput(&quot;click&quot;) ) classes &lt;- sort(unique(mpg$class)) server &lt;- function(input, output, session) { output$bars &lt;- renderPlotly({ ggplot(mpg, aes(class, fill = drv, customdata = drv)) + geom_bar() }) output$click &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_click&quot;) if (is.null(d)) return(&quot;Click a bar&quot;) mpg %&gt;% filter(drv %in% d$key) %&gt;% filter(class %in% classes[d$x]) }) } shinyApp(ui, server) FIGURE 18.13: Retrieving the data observations that correspond to a particular bar in a stacked bar chart. 18.2.8 Accumulating and managing event data Currently all the events accessible through event_data() are transient. This means that, given an event like \"plotly_click\", the value of event_data() will only reflect the most recent click information. However, in order to implement complex linked graphics with persistent qualities, like Figure 17.4 or 18.25, you‚Äôll need someway to accumulate and manage event data. The general mechanism that shiny provides to achieve this kind of task is reactiveVal() (or, the plural version, reactiveValues()), which essentially provides a way to create and manage input values entirely server-side. Figure 18.14 demonstrates a shiny app that accumulates hover information and paints the hovered points in red. Every time a hover event is triggered, the corresponding car name is added to the set of selected cars, and everytime the plot is double-clicked that set is cleared. This general pattern of initializing a reactive value (i.e., cars &lt;- reactiveVal()), updating that value upon a suitable observeEvent() event with relevant customdata, and clearing that reactive value (i.e., cars(NULL)) in response to another event is a very useful pattern to can support essentially any sort of linked views paradigm because the logic behind the resolution of selection sequences is under your complete control in R. For example, 18.14 simply adds accumulates the event data from \"plotly_hover\" (which is like a logical OR operations), but for other applications, you may need different logic, like the AND, XOR, etc. plotly_example(&quot;shiny&quot;, &quot;event_data_persist&quot;) FIGURE 18.14: Using reactiveVals() to enable a persistent brush via mouse hover. In this example, the brush can be cleared through a double-click event. Figure 18.15 demonstrates a shiny gadget for interactively removing/adding points from a linear model via a scatterplot. A shiny gadget is similar to a normal shiny app except that it allows you to return object(s) from the application back to into your R session. In this case, Figure 18.15 returns the fitted model with the outliers removed and the choosen polynomial degree. The logic behind this app does more than simply accumulate event data everytime a point is clicked. Instead, it adds points to the ‚Äòoutlier‚Äô set only if it isn‚Äôt already an outlier, and removes points that are already in the ‚Äúoutlier‚Äù set (so, it‚Äôs essentially XOR logic). plotly_example(&quot;shiny&quot;, &quot;lmGadget&quot;) FIGURE 18.15: Interactively removing observations from a linear model. Credit to Winston Chang for the initial implementation of this shiny gadget using shiny::plotOutput() instead of plotly::plotlyOutput() As you can already see, the ability to accumulate and manage event data is a critical skill to have in order to implement shiny applications with complex interactive capabilities. The pattern demonstrates here is known more generally as ‚Äúmaintaining state‚Äù of a shiny app based on user interactions and has a variety of applications. So far, we‚Äôve really only see how to maintain state of a single view, but as we‚Äôll see later in section 18.4, the ability to maintain state is required to implement many advanced applications of multiple linked views. Also, it should be noted that Figure 18.14 and 18.15 perform a full redraw when updated ‚Äì these apps would feel a bit more responsive if they leveraged strategies from section 18.3.1. 18.3 Improving performance Multiple linked views are known to help facilitate data exploration, but latency in the user interface is also known to reduce exploratory findings (Heer 2014). In addition to the advice and techniques offered in section 18.3.1 for improving plotly‚Äôs performance in general, there are also techniques specifically for shiny apps that you can leverage to help improve the user experience. When trying to speed-up any slow code, the first step is always to identify the main contributor(s) to the poor performance. In some cases, your intuition may serve as a helpful guide, but in order to really see what‚Äôs going on, consider using a code profiling tool like profvis (Chang and Luraschi 2018). The profvis package provides a really nice way to visualize and isolate slow running R code in general, but it also works well for profiling shiny apps (RStudio 2014b). A lot of different factors can contribute to poor performance in a shiny app, but thankfully, the shiny ecosystem provides an extensive toolbox for diagnosing and improving performance. The profvis package is great for identifying ‚Äúuniversal‚Äù performance issues, but when deploying shiny apps into production, there may be other potential bottlenecks that surface. This is largely due to R‚Äôs single-threaded nature ‚Äì a single R server has difficulty scaling to many users because, by default, it can only handle one job at a time. The shinyloadtest package helps to identify those bottlenecks and shiny‚Äôs support for asynchronous programming with promises is one way to address them without increasing computational infrastructure (e.g. multiple servers) (Dipert, Schloerke, and Borges 2018); (Cheng 2018b). To reiterate the section on ‚ÄúImproving performance and scalability‚Äù in shiny from Cheng (2018a), you have a number of tools available to address performance: The profvis package for profiling code. Cache computations ahead-of-time. Cache computations at run time. Cache computations through chaining reactive expressions. Leverage multiple R processes and/or servers. Async programming with promises We won‚Äôt directly cover these topics, but it‚Äôs worth noting that all these tools are primarily designed for improving server-side performance of a shiny app. It could be that sluggish plots in your shiny app are due to sluggish server-side code, but it could also be that some of the sluggishness is due to redundant work being done client-side by plotly. Avoiding this redundancy, as covered in section 18.3.1, can be difficult, and it doesn‚Äôt always lead to noticable improvements. However, when you need to put lots of graphical elements on a plot, then update just a portion of the plot in response to user event(s), the added complexity can be worth the effort. 18.3.1 Partial plotly updates By default, when renderPlotly() renders a new plotly graph it‚Äôs essentially equivalent to executing a block of R code from your R prompt and generating a new plotly graph from scratch. That means, not only does the R code need to re-execute to generate a new R object, but it also has to re-serialize that object as JSON, and your browser has to re-render the graph from the new JSON object (more on this in section ??). In cases where your plotly graph does not need to serialize a lot data and/or render lots of graphical elements, as in Figure 18.1, you can likely perform a full redraw without noticable glitches, especially if you use canvas-based rendering rather than SVG (i.e., toWebGL()). Generally speaking, you should try very hard to make your app responsive before adopting partial plotly updates in shiny. It makes your app logic easy to reason about because you don‚Äôt have to worry about maintaining the state of the graph, but sometimes you have no other choice. On initial page load, plotly graphs must be drawn from stratch, but when responding to certain user events, often times a partial update to an existing plot is sufficient and more responsive. Take, for instance, the difference between Figure 18.16, which does a full redraw on every update, and Figure 18.17, which does a partial update after initial load. Both of these shiny apps display a scatterplot with 100,000 points and allow a user to overlay a fitted line through a checkbox. The key difference is that in Figure 18.16, the plotly graph is regenerated from scratch everytime the value of input$smooth changes, whereas in Figure 18.17 only the fitted line is added/removed from the plotly. Since the main bottleneck lies in redrawing the points, Figure 18.17 can add/remove the fitted line is a much more responsive fashion. Click to show/hide the code library(shiny) library(plotly) # Generate 100,000 observations from 2 correlated random variables d &lt;- MASS::mvrnorm(1e6, mu = c(0, 0), Sigma = matrix(c(1, 0.5, 0.5, 1), 2, 2)) d &lt;- setNames(as.data.frame(d), c(&quot;x&quot;, &quot;y&quot;)) # fit a simple linear model m &lt;- lm(y ~ x, data = d) # generate y predictions over a grid of 10 x values dpred &lt;- data.frame( x = seq(min(d$x), max(d$x), length.out = 10) ) dpred$yhat &lt;- predict(m, newdata = dpred) ui &lt;- fluidPage( plotlyOutput(&quot;scatterplot&quot;), checkboxInput(&quot;smooth&quot;, label = &quot;Overlay fitted line?&quot;, value = FALSE) ) server &lt;- function(input, output, session) { output$scatterplot &lt;- renderPlotly({ p &lt;- plot_ly(d, x = ~x, y = ~y) %&gt;% add_markers(color = I(&quot;black&quot;), alpha = 0.05) %&gt;% toWebGL() %&gt;% layout(showlegend = FALSE) if (!input$smooth) return(p) add_lines(p, data = dpred, x = ~x, y = ~yhat, color = I(&quot;red&quot;)) }) } shinyApp(ui, server) FIGURE 18.16: Naive implementation of a shiny app that optionally overlays a fitted line to a scatterplot. A full redraw of the plot is performed everytime the checkbox is clicked, leading to an unnecessarily slow plot. In terms of the implementation behind Figure 18.16 and 18.17, the only difference resides in the server definition. In Figure 18.17, the renderPlotly() statement no longer has a dependency on input values, so that code is only executed once (on page load) to generate the initial view of the scatterplot. The logic behind adding and removing the fitted line is handled through an observe() block ‚Äì this reactive expression watches the input$smooth input value and modifies the output$scatterplot widget whenever it changes. To trigger a modification of a plotly output widget, you must create a proxy object with plotlyProxy() that references the relevant output ID. Once a proxy object is created, you can invoke any sequence of plotly.js function(s) on it with plotlyProxyInvoke(). Invoking a method with the correct arguments can be tricky and requires knowledge of plotly.js because plotlyProxyInvoke() will send these arguments directly to the plotly.js method and therefore doesn‚Äôt support the same ‚Äòhigh-level‚Äô semantics that plot_ly() does. Click to show/hide the code server &lt;- function(input, output, session) { output$scatterplot &lt;- renderPlotly({ plot_ly(d, x = ~x, y = ~y) %&gt;% add_markers(color = I(&quot;black&quot;), alpha = 0.05) %&gt;% toWebGL() }) observe({ if (input$smooth) { # this is essentially the plotly.js way of doing # `p %&gt;% add_lines(x = ~x, y = ~yhat) %&gt;% toWebGL()` # without having to redraw the entire plot plotlyProxy(&quot;scatterplot&quot;, session) %&gt;% plotlyProxyInvoke( &quot;addTraces&quot;, list( x = dpred$x, y = dpred$yhat, type = &quot;scattergl&quot;, mode = &quot;lines&quot;, line = list(color = &quot;red&quot;) ) ) } else { # JavaScript index starts at 0, so the &#39;1&#39; here really means # &quot;delete the second traces (i.e., the fitted line)&quot; plotlyProxy(&quot;scatterplot&quot;, session) %&gt;% plotlyProxyInvoke(&quot;deleteTraces&quot;, 1) } }) } FIGURE 18.17: A more responsive version of Figure 18.16. Figure 18.16 demonstrates a common use case where partial updates can be helpful, but there are other not-so-obvious cases. The next section covers a range of examples where you‚Äôll see how to leverage partial updates to implement smooth ‚Äòstreaming‚Äô visuals, avoid resetting axis ranges, avoid flickering basemap layers, and more. 18.3.2 Partial update examples The last section explains why you may want to leverage partial plotly updates in shiny to get more responsive updates through an example. That example leveraged the plotly.js functions Plotly.addTraces() and Plotly.deleteTraces() to add/remove a layer to a plot after it‚Äôs initial draw. There are numerous other plotly.js functions that can be handy for a variety of use cases, some of the most widely used ones are: Plotly.restyle() for updating data visuals (section 18.3.2.1), Plotly.relayout() for updating the layout (section 18.3.2.2), and Plotly.extendTraces() for streaming data (section 18.3.2.3). 18.3.2.1 Modifying traces All plotly figures have two main components: traces (i.e., mapping from data to visuals) and layout. The plotly.js function Plotly.restyle() is for modifying any existing traces. In addition to being a performant way to modify existing data and/or visual properties, it also has the added benefit of not affecting the current layout of the graph. Notice how, in Figure 18.18 for example, when the size of the marker/path changes, it doesn‚Äôt change the camera‚Äôs view of the 3D plot that the user altered after initial draw. If these input widgets triggered a full redraw of the plot, the camera would be reset to it‚Äôs initial state. Click to show/hide the code library(shiny) library(plotly) ui &lt;- fluidPage( sliderInput(&quot;marker&quot;, &quot;Marker size&quot;, min = 0, max = 20, value = 8), sliderInput(&quot;path&quot;, &quot;Path size&quot;, min = 0, max = 30, value = 2), plotlyOutput(&quot;p&quot;) ) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ plot_ly( economics, x = ~pce, y = ~psavert, z = ~unemploy, color = ~as.numeric(date), mode = &quot;markers+lines&quot; ) }) observeEvent(input$marker, { plotlyProxy(&quot;p&quot;, session) %&gt;% plotlyProxyInvoke( &quot;restyle&quot;, # could also do list(marker = list(size = input$marker)) # but that overwrites the existing marker definition # https://github.com/plotly/plotly.js/issues/1866#issuecomment-314115744 list(marker.size = input$marker) ) }) observeEvent(input$path, { plotlyProxy(&quot;p&quot;, session) %&gt;% plotlyProxyInvoke( &quot;restyle&quot;, list(line.width = input$path) ) }) } shinyApp(ui, server) FIGURE 18.18: Using Plotly.restyle() to change just the width of a path and markers along that path in response to changes to shiny input sliders. One un-intuitive thing about Plotly.restyle() is that it fully replaces object (i.e., attributes that contain attributes) definitions like marker by default. To modify just a particular attribute of an object, like the size of a marker, you must replace that attribute directly (hence marker.size). As mentioned in the official documentation, by default, modifications are applied to all traces, but specific traces can be targeted through their trace index (which starts at 0, because JavaScript)! 18.3.2.2 Updating the layout All plotly figures have two main components: traces (i.e., mapping from data to visuals) and layout. The plotly.js function Plotly.relayout() modifies the layout component, so it can control a wide variety of things such titles, axis definitions, annotations, shapes, and many other things. It can even be used to change the basemap layer of a Mapbox-powered layout, as in Figure 18.19. Note how this example uses schema() to grab all the pre-packaged basemap layers and create a dropdown of those options, but you can also provide a URL to a custom basemap style. Click to show/hide the code library(shiny) library(plotly) # get all the available mapbox styles mapStyles &lt;- schema()$layout$layoutAttributes$mapbox$style$values ui &lt;- fluidPage( selectInput(&quot;style&quot;, &quot;Select a mapbox style&quot;, mapStyles), plotlyOutput(&quot;map&quot;) ) server &lt;- function(input, output, session) { output$map &lt;- renderPlotly({ plot_mapbox() }) observeEvent(input$style, { plotlyProxy(&quot;map&quot;, session) %&gt;% plotlyProxyInvoke( &quot;relayout&quot;, list(mapbox = list(style = input$style)) ) }) } shinyApp(ui, server) FIGURE 18.19: Using Plotly.relayout() to ‚Äòauto-range‚Äô the y-axis in response to changes in the x-axis range. Figure 18.20 demonstrates a clever use of Plotly.relayout() to set the y-axis range in response to changes in the x-axis range. Click to show/hide the code library(shiny) library(plotly) ui &lt;- fluidPage( plotlyOutput(&quot;plot&quot;) ) server &lt;- function(input, output, session) { p &lt;- ggplot(txhousing) + geom_line(aes(date, median, group = city)) output$plot &lt;- renderPlotly({ ggplotly(p, dynamicTicks = TRUE) %&gt;% rangeslider() }) observeEvent(event_data(&quot;plotly_relayout&quot;), { d &lt;- event_data(&quot;plotly_relayout&quot;) xmin &lt;- if (length(d[[&quot;xaxis.range[0]&quot;]])) d[[&quot;xaxis.range[0]&quot;]] else d[[&quot;xaxis.range&quot;]][1] xmax &lt;- if (length(d[[&quot;xaxis.range[1]&quot;]])) d[[&quot;xaxis.range[1]&quot;]] else d[[&quot;xaxis.range&quot;]][2] if (is.null(xmin) || is.null(xmax)) return(NULL) # compute the y-range based on the new x-range idx &lt;- with(txhousing, xmin &lt;= date &amp; date &lt;= xmax) yrng &lt;- extendrange(txhousing$median[idx]) plotlyProxy(&quot;plot&quot;, session) %&gt;% plotlyProxyInvoke(&quot;relayout&quot;, list(yaxis = list(range = yrng))) }) yRange &lt;- range(txhousing$median, na.rm = TRUE) observeEvent(event_data(&quot;plotly_doubleclick&quot;), { plotlyProxy(&quot;plot&quot;, session) %&gt;% plotlyProxyInvoke(&quot;relayout&quot;, list(yaxis = list(range = yRange))) }) } shinyApp(ui, server) FIGURE 18.20: Using Plotly.relayout() to ‚Äòauto-range‚Äô the y-axis in response to changes in the x-axis range. 18.3.2.3 Streaming data At this point, we‚Äôve seen how to add/remove traces (e.g., add/remove a fitted line, as in Figure 18.17), and how to edit specific trace properties (e.g., change marker size or path width, as in Figure 18.18), but what about adding more data to existing trace(s)? This is a job for the plotly.js function Plotly.extendTraces() and/or Plotly.prependTraces() which can used to efficiently ‚Äòstream‚Äô data into an existing plot, as done in Figure 18.21. The implementation behind Figure 18.21, an elementary example of a random walk, makes use of some fairly sophisicated reactive programming tools from shiny. Similar to most examples from this section, the renderPlotly() statement is executed once on initial load to draw the initial line with just two data points. By default, the plot is not streaming, but streaming can be turned on or off through the click of a button, which will require the app to know (at all times) whether or not we are in a streaming state. One way to do this is to leverage shiny‚Äôs reactiveValues(), which act like input values, but can be created and modified entirely server-side, making them quite useful for maintaining state of an application. In this case, the reactive value rv$stream is used to store the streaming state, which is turned on/off whenever the actionButton() is clicked (via the observeEvent() logic). Even if the app is not streaming, there is still constant client/server communication because of the use of invalidateLater() inside the observe(). This effectively tells shiny to re-evaluate the observe() block every 100 milliseconds. If the app isn‚Äôt in streaming mode, then it exits early without doing anything. If the app is streaming, then we first use sample() to randomly draw either -1 or 1 (with equal probability) and use the result to update the most recent (x, y) state. This is done by assigning a new value to the reactive values rv$y and rv$n within an isolate()d context ‚Äì if this assignment happened outside of an isolate()d context it would cause the reactive expression to be invalidated and cause an infinite loop! Once we have the new (x, y) point stored away, Plotly.extendTraces() can be used to add the new point to the plotly graph. Click to show/hide the code library(shiny) library(plotly) ui &lt;- fluidPage( actionButton(&quot;stream&quot;, &quot;Turn stream on/off&quot;), plotlyOutput(&quot;plot&quot;) ) server &lt;- function(input, output, session) { # initial values yint &lt;- c(0, 1) # initiate graph with initial values output$plot &lt;- renderPlotly({ plot_ly(y = yint, x = seq_along(yint)) %&gt;% add_lines() }) # reactiveValues() act very much like input values, but may be used to # maintain state (e.g., are we currently streaming?) rv &lt;- reactiveValues( stream = FALSE, yend = sum(yint), n = length(yint) ) # turn streaming on/off when the button is pressed observeEvent(input$stream, { rv$stream &lt;- if (rv$stream) FALSE else TRUE }) observe({ # if we&#39;re not streaming, don&#39;t do anything if (!rv$stream) return() # re-execute this code block to every 100 milliseconds invalidateLater(100, session) # changing a reactive value &quot;invalidates&quot; it, so isolate() is needed # to avoid recursion isolate({ rv$n &lt;- rv$n + 1 rv$yend &lt;- rv$yend + sample(c(-1, 1), 1) }) # add the new value to the plot plotlyProxy(&quot;plot&quot;, session) %&gt;% plotlyProxyInvoke( &quot;extendTraces&quot;, list( y = list(list(rv$yend)), x = list(list(rv$n)) ), list(0) ) }) } shinyApp(ui, server) FIGURE 18.21: Using Plotly.extendTraces() to efficiently stream data into a plotly chart. This specific example implements a random walk (using R‚Äôs random number generator) which updates every 100 milliseconds. To see more examples that leverage partial updating, see section 18.4.2. 18.4 Advanced applications This section combines concepts from prior sections in linking views with shiny and applies them towards some popular use cases. 18.4.1 Drill-down The so-called ‚Äòdrill-down‚Äô chart tends to include a vague grouping of interactive graphics that allow one to generate new views based on interesting subset(s) of the data. In Figure 18.22, the first bar chart shows store sales broked down by their main categories. By clicking on a bar, one can drill-down into that category to see the breakdown of sub-categories within that category. From there, one may pick a sub-category to populate a time series of the corresponding sales; and futhermore, click on a particular date to see the actual sales records for that day. In a drill-down chart, a change in the top-level category should trigger changes to sub-categories, so to handle this logic correctly, you‚Äôll want to store selections in reactive values and update those values accordingly when relevant events occur. For example, note how in Figure 18.22, a click of a category clears the sub-category and order-date. Moreover, a change in a sub-category will clear the order-date, but doesn‚Äôt change the category. Click to show/hide the code library(shiny) library(plotly) library(dplyr) # CSV available from https://github.com/cpsievert/plotly_book sales &lt;- readr::read_csv(&quot;data/sales.csv&quot;) ui &lt;- fluidPage( plotlyOutput(&quot;category&quot;, height = 200), plotlyOutput(&quot;sub_category&quot;, height = 200), plotlyOutput(&quot;sales&quot;, height = 300), dataTableOutput(&quot;datatable&quot;) ) # avoid repeating this code axis_titles &lt;- . %&gt;% layout( xaxis = list(title = &quot;&quot;), yaxis = list(title = &quot;Sales&quot;) ) server &lt;- function(input, output, session) { # for maintaining the state of drill-down variables category &lt;- reactiveVal() sub_category &lt;- reactiveVal() order_date &lt;- reactiveVal() # when clicking on a category, observeEvent(event_data(&quot;plotly_click&quot;, source = &quot;category&quot;), { category(event_data(&quot;plotly_click&quot;, source = &quot;category&quot;)$x) sub_category(NULL) order_date(NULL) }) observeEvent(event_data(&quot;plotly_click&quot;, source = &quot;sub_category&quot;), { sub_category(event_data(&quot;plotly_click&quot;, source = &quot;sub_category&quot;)$x) order_date(NULL) }) observeEvent(event_data(&quot;plotly_click&quot;, source = &quot;order_date&quot;), { order_date(event_data(&quot;plotly_click&quot;, source = &quot;order_date&quot;)$x) }) output$category &lt;- renderPlotly({ sales %&gt;% count(category, wt = sales) %&gt;% plot_ly(x = ~category, y = ~n, source = &quot;category&quot;) %&gt;% axis_titles() %&gt;% layout(title = &quot;Sales by category&quot;) }) output$sub_category &lt;- renderPlotly({ if (is.null(category())) return(NULL) sales %&gt;% filter(category %in% category()) %&gt;% count(sub_category, wt = sales) %&gt;% plot_ly(x = ~sub_category, y = ~n, source = &quot;sub_category&quot;) %&gt;% axis_titles() %&gt;% layout(title = category()) }) output$sales &lt;- renderPlotly({ if (is.null(sub_category())) return(NULL) sales %&gt;% filter(sub_category %in% sub_category()) %&gt;% count(order_date, wt = sales) %&gt;% plot_ly(x = ~order_date, y = ~n, source = &quot;order_date&quot;) %&gt;% add_lines() %&gt;% axis_titles() %&gt;% layout(title = paste(sub_category(), &quot;sales over time&quot;)) }) output$datatable &lt;- renderDataTable({ if (is.null(order_date())) return(NULL) sales %&gt;% filter( sub_category %in% sub_category(), as.Date(order_date) %in% as.Date(order_date()) ) }) } shinyApp(ui, server) FIGURE 18.22: Using a drill-down approach to navigating through sales data by category, sub-category, and order date. 18.4.2 Cross-filter Somewhat related to the drill-down idea is so-called ‚Äòcross-filter‚Äô chart. The main difference between drill-down and cross-filter is that, with cross-filter, interactions don‚Äôt generate new charts ‚Äì interactions impose a filter on the data shown in a fixed set of multiple views. The typical cross-filter implementation allows for multiple brushes (i.e., filters) and uses the intersection of those filters to the dataset displayed in those views. Implementing a scalable and responsive crossfilter with 3 or more views can get quite complicated ‚Äì we‚Äôll walk through some simple examples first for learning purposes, then progress to more sophicated and complex applications. Figure 18.23 demonstrates the simplest way to implement a cross-filter between two histograms. It uses the arrival (arr_time) and departure (dep_time) from the flights dataset via the nycflights13 package (Wickham 2018). Notice how, in the implementation, the dep_time view is re-drawn from stratch everytime the arr_time brush changes (and vice-versa). Not only is it completely redrawn (i.e., it relies on renderPlotly() to perform the update), but it also uses add_histogram() which performs binning client-side (in the web browser). That means, every time a brush changes, the shiny server sends all the raw data to the browser and plotly.js redraws the histogram from scratch. Click to show code library(shiny) library(dplyr) library(nycflights13) ui &lt;- fluidPage( plotlyOutput(&quot;arr_time&quot;), plotlyOutput(&quot;dep_time&quot;) ) server &lt;- function(input, output, session) { output$arr_time &lt;- renderPlotly({ p &lt;- plot_ly(flights, x = ~arr_time, source = &quot;arr_time&quot;) brush &lt;- event_data(&quot;plotly_brushing&quot;, source = &quot;dep_time&quot;) if (is.null(brush)) return(p) p %&gt;% filter(between(dep_time, brush$x[1], brush$x[2])) %&gt;% add_histogram() }) output$dep_time &lt;- renderPlotly({ p &lt;- plot_ly(flights, x = ~dep_time, source = &quot;dep_time&quot;) brush &lt;- event_data(&quot;plotly_brushing&quot;, source = &quot;arr_time&quot;) if (is.null(brush)) return(p) p %&gt;% filter(between(arr_time, brush$x[1], brush$x[2])) %&gt;% add_histogram() }) } shinyApp(ui, server) FIGURE 18.23: A ‚Äònaive‚Äô crossfilter implementation linking arrival time with departure time of about 350,000 flights from the nycflights13 package. Although the video behind Figure 18.23 demonstrates the app is fairly responsive at 350,000 observations, this implementation won‚Äôt scale to much larger data, especially if being viewed a poor internet connection. I call this a ‚Äònaive‚Äô implementation because the reactive logic is easy to reason about, but it illustrates two common issues that we can address to gain speed improvements: More data than necessary being sent ‚Äòover-the-wire‚Äô (i.e., between the server and the client). This idea is not unique to shiny applications ‚Äì with any web application framework it‚Äôs important to minimize the amount of data you‚Äôre requesting from a server if you want a responsive website. More client-side rendering work than necessary to achieve the request update. The implementation behind Figure 18.23 could improve in these areas by doing the following: Perform the binning server-side instead of client-side. This will reduce the amount of data needed to be sent from server to client so that responsiveness is less dependent on a good internet connection. Here we propose using ggstat for the server-side binning since it‚Äôs fairly fast and simple if you‚Äôre data can fit into memory (Wickham 2016). If your data does not fit into memory you could use something like dbplot to perform the binning in a database (Ruiz 2018). Perform less rendering work client-side. That is, instead of relying on renderPlotly() to re-render the chart from scratch everytime the charts need an update, we could instead modify just the bar heights (using the techniques from Section 18.3.1). Click to below to see the responsive implementation library(shiny) library(dplyr) library(nycflights13) library(ggstat) arr_time &lt;- flights$arr_time dep_time &lt;- flights$dep_time arr_bins &lt;- bin_fixed(arr_time, bins = 250) dep_bins &lt;- bin_fixed(dep_time, bins = 250) arr_stats &lt;- compute_stat(arr_bins, arr_time) %&gt;% filter(!is.na(xmin_)) dep_stats &lt;- compute_stat(dep_bins, dep_time) %&gt;% filter(!is.na(xmin_)) ui &lt;- fluidPage( plotlyOutput(&quot;arr_time&quot;, height = 250), plotlyOutput(&quot;dep_time&quot;, height = 250) ) server &lt;- function(input, output, session) { output$arr_time &lt;- renderPlotly({ plot_ly(arr_stats, source = &quot;arr_time&quot;) %&gt;% add_bars(x = ~xmin_, y = ~count_) }) output$dep_time &lt;- renderPlotly({ plot_ly(dep_stats, source = &quot;dep_time&quot;) %&gt;% add_bars(x = ~xmin_, y = ~count_) }) # arr_time brush updates dep_time view observe({ brush &lt;- event_data(&quot;plotly_brushing&quot;, source = &quot;arr_time&quot;) p &lt;- plotlyProxy(&quot;dep_time&quot;, session) # if brush is empty, restore default if (is.null(brush)) { plotlyProxyInvoke(p, &quot;restyle&quot;, &quot;y&quot;, list(dep_stats$count_), 0) } else { dep_time_filter &lt;- dep_time[between(dep_time, brush$x[1], brush$x[2])] dep_count &lt;- dep_bins %&gt;% compute_stat(dep_time_filter) %&gt;% filter(!is.na(xmin_)) %&gt;% pull(count_) plotlyProxyInvoke(p, &quot;restyle&quot;, &quot;y&quot;, list(dep_count), 0) } }) observe({ brush &lt;- event_data(&quot;plotly_brushing&quot;, source = &quot;dep_time&quot;) p &lt;- plotlyProxy(&quot;arr_time&quot;, session) # if brush is empty, restore default if (is.null(brush)) { plotlyProxyInvoke(p, &quot;restyle&quot;, &quot;y&quot;, list(arr_stats$count_), 0) } else { arr_time_filter &lt;- arr_time[between(arr_time, brush$x[1], brush$x[2])] arr_count &lt;- arr_bins %&gt;% compute_stat(arr_time_filter) %&gt;% filter(!is.na(xmin_)) %&gt;% pull(count_) plotlyProxyInvoke(p, &quot;restyle&quot;, &quot;y&quot;, list(arr_count), 0) } }) } shinyApp(ui, server) Before we address the additional complexity that comes with linking 3 or more views, let‚Äôs consider targetting a 2D distribution in the cross-filter, as in Figure 18.24. This approach uses kde2d() from the MASS package to summarize the 2D distribution server-side rather than attempting to show all the raw data in a scatterplot.32 plotly_example(&quot;shiny&quot;, &quot;crossfilter_kde&quot;) FIGURE 18.24: Using kernel density estimation to responsively crossfilter a 2D distribution. This particular example shows how the relationship between diamond carat and price is dependent upon it‚Äôs depth. When linking 3 or more views in a crossfilter, it‚Äôs important to have a mechanism to maintain the state of all the active brushes. This is because, when updating a given view, it needs to know about all of the active brushes. The implementation behind Figure 18.25 maintains the range of every active brush through a reactiveValues() variable named brush_ranges. Everytime a brush changes, the state of brush_ranges is updated, then used to filter the data down to the relevant observations. That filtered data is then binned and used to modify the bar heights of every view (except for the one being brushed). plotly_example(&quot;shiny&quot;, &quot;crossfilter&quot;) FIGURE 18.25: Crossfiltering 6 variables in the flights data from the nycflights13 package (Wickham 2018). The filtering and binning logic occurs server-side resulting in a very minimal amount of data being sent between server and client (just the brush range and bar heights). Moreover, to perform the UI update, the client only has to tweak existing bar heights, so the overall user experience is quite responsive. One weakness of a typical crossfilter interface like Figure 18.25 is that it‚Äôs difficult to make visual comparisons. That is, when a filter is applied, you lose a visual reference to the overall distribution and/or prior filter, making difficult to make meaningful comparisons. Figure 18.25 modifies the logic of Figure 18.26 to enable filter comparisons by adding the ability to change the color of the brush. Moreover, for sake of demonstration and simplicity, it also allows for only one active filter per color (i.e., brushing within color is transient). One could borrow logic from Figure 18.25 to allow multiple filters for each color, but this would require multiple brush_ranges. Since brushing within color is transient, in constrast to Figure 18.25, Figure 18.26 doesn‚Äôt have to track the state of all the active brushes. It does, however, need to display relative rather than absolute frequencies to facilitate comparison of small filter range(s) to the overall distribution. This particular implementation takes the overall distribution as a ‚Äúbase layer‚Äù that remains fixed and overlays a handful of ‚Äúselection layers‚Äù ‚Äì one for each possible brush color. These selection layers begin with a height of 0, but when the relevant brush fires the heights of the bars for the relevant layer is modified. This approach may seem like a hack, but it leads to a fluid user experience because it‚Äôs not much work to adjust the height of a bar that already exists. plotly_example(&quot;shiny&quot;, &quot;crossfilter_compare&quot;) FIGURE 18.26: Comparing filters with a dynamic color brush. This particular example compares ‚Äòred eye‚Äô flights (in green) to early morning flights (in orange). This makes it easier to see that delays occur more often for ‚Äòred eye‚Äô flights. 18.4.3 A draggable brush A draggable linked brush is great for conditioning via a moving window. For example, in a cross-filtering example like Figure 18.25, it would be nice to condition on a certain hour of day, then drag that hour interval along the axis to explore how the hourly distribution changes throughout the day. At the time of writing, plotly.js does not support a draggable brush, but we could implement one with a clever use of a editable rectangle shape. Figure @ref(fig:drag_brush) demonstrates this idea in a shiny application by drawing a rectangle shape that mimics the plotly.js brush, then uses the \"plotly_relayout\" event to determine the limits of the brush (instead of the \"plotly_brushed\" or \"plotly_brushing\"). plotly_example(&quot;shiny&quot;, &quot;drag_brush&quot;) (#fig:drag_brush)A draggable brush with both a transient and persistent mode. The dragging ability is done by mimicing the native plotly.js brush with an editable rectangle shape and listening to changes in that brush. The implementation of transient vs persistent mode is a matter of forgetting or remembering previous state(s) of the brush. 18.5 Discussion Compared to the linking framework covered in section 17.1, the ability to link views server-side with shiny opens the door to many new possibilities. This chapter focuses mostly on using just plotly within shiny, but the shiny ecosystem is vast and these techniques can of course be used to inform other views, such as static plots, other htmlwidgets packages (e.g., leaflet, DT, network3D, etc), and other custom shiny bindings. In fact, I have a numerous shiny apps publically available via an R package that use numerous tools to provide exploratory interfaces to a variety of domain-specific problems, including zikar::explore() for exploring Zika virus reports, eechidna::launch() for exploring Australian election and census data, and bcviz::launch() for exploring housing and census information in British Colombia (Sievert 2018d); (Cook et al. 2017); (Sievert 2018a). These complex applications also serve as a reference as to how can use the client-side linking framework (i.e., crosstalk) inside a larger shiny application. See this video for an example: FIGURE 18.27: Example of a shiny app that has crosstalk functionality embedded. Sometimes shiny gets a bad rap for being too slow or unresponsive, but as we learned in sections 18.3.1 and 18.4, we can still have very advanced functionality as well as a good user experience ‚Äì it just takes a bit more effort to optimize performance in some cases. In fact, one could argue that a server-client approach to crossfiltering, as done in Figure 18.25 is more scalable than a purely client-side approach since the client wouldn‚Äôt need to know about the raw data ‚Äì just the summary statistics. Nevertheless, sometimes linking views server side simply isn‚Äôt an option for you or your organization. Maybe your IT administrator simply won‚Äôt allow you to distribute your work outside of a standalone HTML file. Figure 18.11 is just one example of a linked graphic that could be replicated using the graphical querying framework from section 17.1, but it would require pre-computing every possible view (which becomes un-manageable when there are many possible selections) and posing the update logic as a database query. When users are only allowed to select (e.g. click/hover) a single element at a time, the number of possible selections increases linearly with the number of elements, but when users are allowed to select any subset of elements (e.g., scatterplot brushing), the number of possible selection explodes (increases at a factorial rate). For example, adding a cell to Figure 18.11 only adds one possible selection, but if we added more states to Figure 18.11, the number of possible states goes from 50! to 51!. Even in the case that you need a standalone HTML file and the R API that plotly provides doesn‚Äôt support the type of interactivity that you desire, you can always layer on additional JavaScript to hopefully achieve the functionality you desire. This can be useful for something as simple as opening a hyperlink when clicking on marker of a plotly graph ‚Äì this topic is covered introduced in Chapter 23. References "],
["scaling.html", "19 Introduction", " 19 Introduction Scaling visualization to large amounts of information requires a combination of engineering, statistics, creativity, and critical thinking. All too often, people decide they want to look at all the raw data before having any look at any statistical summaries. Unfortunately, this can lead to wasted time on interesting engineering problems that generate un-satistifying analytical results. That being said, even if you‚Äôve thought carefully about leveraging summaries, having a good grasp on the technical landscape for doing large-scale visualization on the web can still be useful. Part 19 covered linked views and demonstrated some techniques which can help put the famous infovis mantra into practice: ‚ÄúOverview first, then zoom and filter, then details on demand‚Äù. In other words, don‚Äôt try to show all the raw data in a single ‚Äì show interesting summaries, then provide interactive tools to extract more information. From a statistical perspective, this mantra tends to work well, because, as Hadley Wickham says: ‚ÄúVisualization surprise, but don‚Äôt scale well. Models (i.e. summaries) scale well, but don‚Äôt surprise‚Äù. In other words, a model helps to reduce the amount of information to display, but it can not point out what important information it does not capture. By providing interactive tools that can reveal the information behind a particular summary, you provide a better framework for questioning the assumption inherent in your summarized overview of the data. Of course, when dealing with non-trivial models (i.e. summaries), it can be quite useful to leverage a statistical computing environment. These are helpful concepts to keep in mind when designing an exploratory interface to large scale data, and you‚Äôll see several figures re-inforce these concepts, but for now we focus on the limitations in terms of rendering lots of graphical elements on a page. Whether you‚Äôre printing the result of ggplotly(), plot_ly(), or more generally any R htmlwidget, there are two classes of efficiency to be aware of: print-time (i.e. build) and run-time (i.e. render) efficiency. Roughly speaking, the bulk of the time translates R code to an R list. That list is then serialized as JSON (via jsonlite::toJSON()) and should match a JSON specification (i.e. schema) defined by the JavaScript library (which uses the JSON to render the widget). "],
["run-time-efficiency.html", "20 Run-time efficiency", " 20 Run-time efficiency SVG vs Web-GL Draw comparison to pdf/png Borrow examples from workshop A quick and easy way to try and improve render performance is to use canvas-based rendering (instead of vector-based SVG) with toWebGL(p). Switching from vector to canvas is generally a good idea when dealing with &gt;30,000 vectors, but in this case, we‚Äôre only dealing with a couple hundred vector paths, so switching from vector to canvas for our map won‚Äôt significantly improve rendering performance, and in fact, we‚Äôll lose some nice SVG exclusive features (the plotly.js team is getting close to eliminating these limitations!). Instead, what we could (and should!) do is reduce the amount of points along to each path (technically speaking, we‚Äôll reduce the complexity of the SVG d attribute). "],
["print-time-efficiency.html", "21 Print-time efficiency", " 21 Print-time efficiency profvis Data summary/simplification What‚Äôs in a plotly object? What happens at print-time? Build-time versus render time Build time profvis Render time SVG vs Web-GL rendering Data summary/simplification If you‚Äôve ever found ggplotly() slow to print, chances are, the bulk of the time is spent building the R list and sending the JSON to plotly.js. For many htmlwidgets, the build time is negligible, but for more complex widgets like plotly, a lot of things need to happen, especially for ggplotly() since we call ggplot2::ggplot_build(), then crawl and map that data structure to plotly.js. In a shiny app, both the build and render stages are required on initial load, but the new plotlyProxy() interface provides a way to ‚Äòcache‚Äô expensive build (and render!) operation and update a graph by modifying just specific components of the figure (via plotly.js functions). Outside of a ‚Äòreactive context‚Äô like shiny, you could use htmlwidgets::saveWidget() to ‚Äòcache‚Äô the results of the build step to disk, send the file to someone else (or host it online somewhere), then only the render step is required to view the graph. "],
["a-case-study-with-cranlogs.html", "22 A case study with cranlogs", " 22 A case study with cranlogs "],
["javascript.html", "23 Introduction", " 23 Introduction The same plotly.js events that we accessed in shiny through event_data() in section 18.2 can also be leveraged purely client-side with some custom JavaScript (JS). That means, by knowing a little bit about JS and the plotly.js library, we can extend graphs created with the R package to have custom behavior without requiring a client-server application. This portion of the book focuses on writing custom responses to commonly used plotly.js events, but a lot of the same tools and techniques could be used to extend these graphs in other ways as well. To add a custom JS event handler to a plotly graph, you can leverage the onRender() function from the htmlwidgets package. This R function accepts a JS function as a string and calls that function when the widget is done rendering in the browser. The JS function needs (at least) one argument, el, which is the Document Object Model (DOM) element containing the plotly graph. Figure 23.1 shows how you could use onRender() to log (and inspect) the DOM element to your browser‚Äôs JS console. You can open the console of any browser (including RStudio!) with right-click -&gt; ‚ÄúInspect Element‚Äù -&gt; ‚ÄúConsole‚Äù tab (or similar). To demonstrate some useful DOM element‚Äôs properties, Figure 23.1 uses Firefox to inspect the element as a global variable, but as Figure 25.1 shows, Chrome currently offers better tools for code debugging the JS function provided to onRender() (e.g., setting breakpoints in virtual memory). library(htmlwidgets) plot_ly(z = ~volcano) %&gt;% onRender(&quot;function(el) { console.log(el); }&quot;) FIGURE 23.1: Using htmlwidgets::onRender() to inspect the relevant DOM instance containing the plotly graph and information related to it‚Äôs current display. The _fullData and _fullLayout attributes bound to the element are ‚Äòinternal‚Äô (meaning relying on this information in production code is discouraged), but do provide a useful description of the chart‚Äôs current state, especially if you need access to computations done by plotly.js (e.g., axis tick placement). If you‚Äôre completely new to JavaScript and JSON, section 24 provides a foundation for understanding the subsequent sections, but those already familiar can skip ahead to section 25. "],
["json.html", "24 Working with JSON 24.1 Assignment, subsetting, and iteration 24.2 Mapping R to JSON", " 24 Working with JSON JavaScript and other web technologies are intimidating and time-consuming to learn, but by borrowing some knowledge of R‚Äôs data structures33, we can get up and running with useful examples fairly quickly. JavaScript Object Notation (JSON) is a popular data-interchange format that JavaScript uses to work with data. As turns out, working with JSON in JS is somewhat similar to working with list()s in R ‚Äì both are recursive and heterogenous data structures that have similar semantics for accessing values. In JSON, there are three basic building blocks: objects, arrays, and primitive data types (e.g., number, string, boolean, null, undefined). Loosely speaking, a JSON array is similar to a un-named list() in R and a JSON object is similar to an un-named list(). In fact, if you‚Äôre already comfortable creating and subsetting named and un-named list()s in R, you can transfer some of that knowledge to JSON arrays and objects. 24.1 Assignment, subsetting, and iteration In R, the &lt;- operator assigns a value to a name, and the [[ operator extracts a list element by index: arr &lt;- list(&quot;hello&quot;, &quot;world&quot;, 10) arr[[1]] #&gt; &quot;hello&quot; In JS, the = assigns a value to a name. When assigning a new name, you should include the var keyword (or similar) to avoid creation of a global variable. The [ operator extracts list elements by index, but be careful, indexing in JS starts at 0 (not 1)! var arr = [&quot;hello&quot;, &quot;world&quot;, 10]; arr[0] // &quot;hello&quot; In R, the $ and [[ operator can be used to extract list elements by name. The difference is that $ does partial matching of names, while [[ requires the exact name. obj &lt;- list(x = c(&quot;hello&quot;, &quot;world&quot;), zoo = 10) obj$z #&gt; 10 obj[[&quot;zoo&quot;]] #&gt; 10 In JS, the . and [ operator can be used to extract list elements by name. In either case, the naming must be exact. var obj = { x: [&quot;hello&quot;, &quot;world&quot;], zoo: 10 } obj.zoo // 10 obj[&#39;zoo&#39;] // 10 Unlike R list()s, arrays and objects in JS come with properties and methods that can be accessed via the . operator. Arrays, in particular, have a length property and a map() method for applying a function to each array element: arr.length // 3 arr.map(function(item) { return item + 1; }); // [&quot;hello1&quot;, &quot;world1&quot;, 11] In R, both the lapply() and purrr::map() family of functions provide a similar functional interface. Also, note that operators like + in JS do even more type coercion than R, so although item + 1 works for strings in JS, it would throw an error in R (an that‚Äôs ok, most times you probably don‚Äôt want to add a string to a number)! If instead, you wanted to only add 1 to numeric values, you could use is.numeric() in R within an if else statement. purrr::map(arr, function(item) if (is.numeric(item)) item + 1 else item) #&gt; [[1]] #&gt; [1] &quot;hello&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;world&quot; #&gt; #&gt; [[3]] #&gt; [1] 11 In JS, you can use the typeof keyword to get the data type as well as the conditional ternary operator (condition ? exprT : exprF) to acheive the same task. arr.map(function(item) { return typeof item == &quot;number&quot; ? item + 1 : item; }); // [&quot;hello&quot;, &quot;world&quot;, 11] There are a handful of other useful array and object methods, but to keep things focused, we‚Äôll only cover what‚Äôs required to comprehend section 25. A couple examples in that section use the filter() method, which like map() applies a function to each array element, but expects a logical expression and returns only the elements that meet the condition. arr.filter(function(item) { return typeof item == &quot;string&quot;; }); // [&quot;hello&quot;, &quot;world&quot;] 24.2 Mapping R to JSON In R, unlike JSON, there is no distinction between scalars and vectors of length 1. That means there is ambiguity as to what a vector of length 1 in R should map to in JSON. The jsonlite package defaults to an array of length 1, but this can be avoided by setting auto_unbox = TRUE. jsonlite::toJSON(&quot;A string in R&quot;) #&gt; [&quot;A string in R&quot;] jsonlite::toJSON(&quot;A string in R&quot;, auto_unbox = TRUE) #&gt; &quot;A string in R&quot; It‚Äôs worth noting that plotly.js, which consumes JSON objects, has specific expectations and rules about scalars versus arrays of length 1. If you‚Äôre calling the plotly.js library directly in JS, as we‚Äôll see later in section 25, you‚Äôll need to be mindful of the difference between scalars and arrays of length 1. Some attributes, like text and marker.size, accept both scalars and arrays and apply different rules based on the difference. Some other attributes, like x, y, and z only accept arrays and will error out if given a scalar. To learn about these rules and expectations, you can use the schema() function from R to inspect plotly.js‚Äô specification as shown in Figure 24.1. Note that attributes with a val_type of 'data_array' require an array while attributes with an arrayOk: true field accept either scalars or arrays. schema() FIGURE 24.1: Using the plotly schema() to obtain more information about expected attribute types. In JSON, unlike R, there is no distinction between a heterogeneous and homogeneous collection of data types. In other words, in R, there is an important difference between list(1, 2, 3) and c(1, 2, 3) (the latter is an atomic vector and has a different set of rules). In JSON, there is no strict notion of a homogenous collection, so working with JSON arrays is essentially like being forced to use list() in R. This subtle fact can lead to some suprising results when trying to serialize R vectors as JSON arrays. For instance, if you wanted to create a JSON array, say [1,\"a\",true] using R objects, you may be tempted to do the following: jsonlite::toJSON(c(1, &quot;a&quot;, TRUE)) #&gt; [&quot;1&quot;,&quot;a&quot;,&quot;TRUE&quot;] But this actually creates an array of strings instead of the array with a number, string, and boolean that we desire. The problems actually lies in the fact that c() coerces the collection of values into an atomic vector. Instead, you should use list() over c(): jsonlite::toJSON(list(1, &quot;a&quot;, TRUE), auto_unbox = TRUE) #&gt; [1,&quot;a&quot;,true] If you‚Äôd like a nice succinct overview on the topic, see http://adv-r.had.co.nz/Data-structures.html‚Ü© "],
["js-event-handlers.html", "25 Adding custom event handlers", " 25 Adding custom event handlers When using onRender() to provide a JS function to be called upon static render of a plotly object, the relevant DOM element (el) has an on() method that accepts a function to be called whenever a plotly.js (or DOM) event occurs on that DOM element. Currently all plotly.js event handlers accept a function with a single argument, and that argument either contains nothing (e.g. \"plotly_afterplot\", etc) or a single object with all the relevant information about the event (e.g. \"plotly_hover\", \"plotly_selected\", etc). Figure 25.1 logs and inspects data (d) emitted during the \"plotly_hover\", \"plotly_click\", and \"plotly_selected\" events. The object emitted for these events includes a key, named points, with information tying the selection back to the input data. The points key is always an array of object(s) where each object represents a different data point. This object contains any supplied customdata, the relevant x/y location, and a reference back to the input data. library(htmlwidgets) plot_ly(mtcars, x = ~wt, y = ~mpg) %&gt;% onRender(&quot; function(el) { el.on(&#39;plotly_hover&#39;, function(d) { console.log(&#39;Hover: &#39;, d) }); el.on(&#39;plotly_click&#39;, function(d) { console.log(&#39;Click: &#39;, d) }); el.on(&#39;plotly_selected&#39;, function(d) { console.log(&#39;Select: &#39;, d) }); } &quot;) FIGURE 25.1: Inspecting event data for hover, click, and selected events. If a click or hover event does not derive from a statistical aggregation (e.g., boxplot, histogram, etc), the points array is of length 1; otherwise, the length corresponds to how many input values are represented in the selection. In Chrome, when you log an object to the console, you can click on a link to the JS source function where you can then set breakpoints. "],
["supplying-custom-data.html", "26 Supplying custom data", " 26 Supplying custom data As covered in section 18.2, it‚Äôs often useful to supply meta-information (i.e. custom data) to graphical marker(s) and use that information when responding to a event. For example, suppose we‚Äôd like each point in a scatterplot to act like a hyperlink to a different webpage. In order to do so, we can supply a url to each point (as metadata) and instruct the browser to open the relevant hyperlink on a click event. Figure 26.1 does exactly this by supplying urls to each point in R through the customdata attribute and defining a custom JS event to window.open() the relevant url upon a click event. In this case, since each point represents one row of data, the d.point is an array of length 1, so we may obtain the url of the clicked point with d.points[0].customdata. library(htmlwidgets) p &lt;- plot_ly(mtcars, x = ~wt, y = ~mpg) %&gt;% add_markers( text = rownames(mtcars), customdata = paste0(&quot;http://google.com/#q=&quot;, rownames(mtcars)) ) onRender( p, &quot; function(el) { el.on(&#39;plotly_click&#39;, function(d) { var url = d.points[0].customdata; window.open(url); }); } &quot;) FIGURE 26.1: Attaching hyperlinks to each point in a scatterplot and using a custom JS event to open that Google search query upon clicking a point. In addition to using window.open() to open the url, we could also add it to the plot as an annotation using the plotly.js function Plotly.relayout(), as done in Figure 26.2. Moreover, since plotly annotations support HTML markup, we can also treat that url as a true HTML hyperlink by wrapping it in an HTML &lt;a&gt; tag. In cases where your JS function starts to get complex, it can help to put that JS function in its own file, then use the R function readLines() to read it in as a string and pass along onRender() as done below: onRender(p, readLines(&quot;js/hover-hyperlink.js&quot;)) Click to show the ‚Äòjs/hover-hyperlink.js‚Äô file function(el) { el.on(&#39;plotly_hover&#39;, function(d) { var url = d.points[0].customdata; var ann = { text: &quot;&lt;a href=&#39;&quot; + url + &quot;&#39;&gt;&quot; + url + &quot;&lt;/a&gt;&quot;, x: 0, y: 0, xref: &quot;paper&quot;, yref: &quot;paper&quot;, yshift: -40, showarrow: false }; Plotly.relayout(el.id, {annotations: [ann]}); }); } FIGURE 26.2: Using Plotly.relayout() to add and change hyperlink in response to hover events. When using Plotly.relayout(), or any other plotly.js function to modify a plot, you‚Äôll need to know the id attribute of the relevant DOM instance that you want to manipulate. When working with a single object, you can simply use el.id to access the id attribute of that DOM instance. However, when trying to target another object, it gets trickier because id attributes are randomly generated by htmlwidgets. In that case, you likely want to pre-specify the id attribute so you can reference it client-side. You can pre-specify the id for any htmlwidgets object, say widget, by doing widget$elementId &lt;- ‚ÄúmyID‚Äù. The customdata attribute can hold any R object that can be serialized as JSON, so you could, for example, attach complex data to markers/lines/text/etc using base64 strings. This could be useful for a number of things such as displaying an image on hover or click. For security reasons, plotly.js doesn‚Äôt allow inserting images in the tooltip, but you can always define your own tooltip by hiding the tooltip (hoverinfo='none'), then populating your own tooltip with suitable manipulation of the DOM in response to \"plotly_hover\"/\"plotly_unhover\" events. Figure 26.3 demonstrates how to leverage this infrastructure to display a png image in the top-left corner of a graph whenever a text label is hovered upon.34 x &lt;- 1:3 y &lt;- 1:3 logos &lt;- c(&quot;r-logo&quot;, &quot;penguin&quot;, &quot;rstudio&quot;) # base64 encoded string of each image uris &lt;- purrr::map_chr(logos, ~ base64enc::dataURI(file = sprintf(&quot;images/%s.png&quot;, .x))) # hoverinfo = &quot;none&quot; will hide the plotly.js tooltip, but the &#39;plotly_hover&#39; event will still fire plot_ly(hoverinfo = &quot;none&quot;) %&gt;% add_text(x = x, y = y, customdata = uris, text = logos) %&gt;% htmlwidgets::onRender(readLines(&quot;js/tooltip-image.js&quot;)) Click to show the ‚Äòjs/tooltip-image.js‚Äô file // inspired, in part, by https://stackoverflow.com/a/48174836/1583084 function(el) { var tooltip = Plotly.d3.select(&#39;#&#39; + el.id + &#39; .svg-container&#39;) .append(&quot;div&quot;) .attr(&quot;class&quot;, &quot;my-custom-tooltip&quot;); el.on(&#39;plotly_hover&#39;, function(d) { var pt = d.points[0]; // Choose a location (on the data scale) to place the image // Here I&#39;m picking the top-left corner of the graph var x = pt.xaxis.range[0]; var y = pt.yaxis.range[1]; // Transform the data scale to the pixel scale var xPixel = pt.xaxis.l2p(x) + pt.xaxis._offset; var yPixel = pt.yaxis.l2p(y) + pt.yaxis._offset; // Insert the base64 encoded image var img = &quot;&lt;img src=&#39;&quot; + pt.customdata + &quot;&#39; width=100&gt;&quot;; tooltip.html(img) .style(&quot;position&quot;, &quot;absolute&quot;) .style(&quot;left&quot;, xPixel + &quot;px&quot;) .style(&quot;top&quot;, yPixel + &quot;px&quot;); // Fade in the image tooltip.transition() .duration(300) .style(&quot;opacity&quot;, 1); }); el.on(&#39;plotly_unhover&#39;, function(d) { // Fade out the image tooltip.transition() .duration(500) .style(&quot;opacity&quot;, 0); }); } FIGURE 26.3: Displaying an image on hover in a scatterplot. It‚Äôs worth noting that the JavaScript that powers Figure 26.3 works for other cartesian charts, even heatmap (as shown in Figure 26.4), but it would need to be adapted for 3D charts types. plot_ly(hoverinfo = &quot;none&quot;) %&gt;% add_heatmap(z = matrix(1:9, nrow = 3), customdata = matrix(uris, nrow = 3, ncol = 3)) %&gt;% htmlwidgets::onRender(readLines(&quot;js/tooltip-image.js&quot;)) FIGURE 26.4: Displaying an image on hover in a heatmap. On the JS side, the customdata attribute is designed to support any JS array of appropriate length, so if you need to supply numerous custom values to particular marker(s), list-columns in R provides a nice way to do so. Figure 26.5 leverages this idea to bind both the city and sales values to each point along a time series and display those values on hover. It also demonstrates how one can use the graphical querying framework from section 17.1 in tandem with a custom JS event. That is, highlight_key() and highlight() control the highlighting of the time series, while the custom JS event adds the plot annotation (all based on the same \"plotly_hover\" event). In this case, the highlighting, annotations, and circle shapes are triggered by a \"plotly_hover\" event and they all work in tandem because event handlers are cumulative. That means, if you wanted, you could register multiple custom handlers for a particular event. library(purrr) sales_hover &lt;- txhousing %&gt;% group_by(city) %&gt;% highlight_key(~city) %&gt;% plot_ly(x = ~date, y = ~median, hoverinfo = &quot;name&quot;) %&gt;% add_lines(customdata = ~map2(city, sales, ~list(.x, .y))) %&gt;% highlight(&quot;plotly_hover&quot;) onRender(sales_hover, readLines(&quot;js/tx-annotate.js&quot;)) Click to show the ‚Äòjs/tx-annotate.js‚Äô file function(el) { el.on(&quot;plotly_hover&quot;, function(d) { var pt = d.points[0]; var cd = pt.customdata; var num = cd[1] ? cd[1] : &quot;No&quot;; var ann = { text: num + &quot; homes were sold in &quot; + cd[0] + &quot;, TX in this month&quot;, x: 0.5, y: 1, xref: &quot;paper&quot;, yref: &quot;paper&quot;, xanchor: &quot;middle&quot;, showarrow: false }; var circle = { type: &quot;circle&quot;, xanchor: pt.x, yanchor: pt.y, x0: -6, x1: 6, y0: -6, y1: 6, xsizemode: &quot;pixel&quot;, ysizemode: &quot;pixel&quot; }; Plotly.relayout(el.id, {annotations: [ann], shapes: [circle]}); }); } FIGURE 26.5: Combining the graphical querying framework from 17.1 with the ability to define custom JS event handlers. This example also leverages the fact that customdata supports list-columns to effectively bind both the city name and number of houses sold on a particular day. Sometimes supplying and accessing customdata alone is not quite enough for the task at hand. For instance, what if we wish to add the average monthly sales to the annotation for the city of interest in Figure 26.5? In cases like this, we may need to use customdata to query a portion of the plot‚Äôs input data, like Figure 26.5 does to compute and display average sales for a given city. This implementation leverages the fact that each selected point (pt) contains a reference to the entire trace it derives from (pt.data). As discussion behind Figure 4.2 noted, this particular plot has a single trace and uses missing values to create separate lines for each city. As a result, pt.data.customdata contains all the customdata we supplied from the R side, so to get all the sales for a given city, we first need to filter that array down to only the elements that are belong to that city (while being careful of missing values!). onRender(sales_hover, readLines(&quot;js/tx-mean-sales.js&quot;)) Click to show the ‚Äòjs/tx-mean-sales.js‚Äô file function(el) { el.on(&quot;plotly_hover&quot;, function(d) { var pt = d.points[0]; var city = pt.customdata[0]; // get the sales for the clicked city var cityInfo = pt.data.customdata.filter(function(cd) { return cd ? cd[0] == city : false; }); var sales = cityInfo.map(function(cd) { return cd[1] }); // yes, plotly bundles d3 which you can access via Plotly.d3 var avgsales = Math.round(Plotly.d3.mean(sales)); // Display the mean sales for the clicked city var ann = { text: &quot;Mean monthly sales for &quot; + city + &quot; is &quot; + avgsales, x: 0.5, y: 1, xref: &quot;paper&quot;, yref: &quot;paper&quot;, xanchor: &quot;middle&quot;, showarrow: false }; Plotly.relayout(el.id, {annotations: [ann]}); }); } FIGURE 26.6: Displaying the average monthly sales for a city of interest on hover. This implementation supplies all the raw sales figures, then uses the hovered customdata value to query sales for the given city and display the average. Figure 26.7 uses the same customdata supplied to Figure 26.6 in order to display a histogram of monthly sales for the relevant city on hover. In addition, it displays a vertical line on the histogram to reflect the monthly sales for the point closest to the mouse cursor. To do all this efficiently, it‚Äôs best to add the histogram trace on the first hover event using Plotly.addTraces(), then supply different sales data via Plotly.restyle() (generally speaking, restyle() is way less expensive than addTraces()). That‚Äôs why the implementation leverages the fact that the DOM element (el) contains a reference to the current graph data (el.data). If the current graph has a trace with type of histogram, then it adds a histogram trace; otherwise, it supplies new x values to the histogram. sales_hover %&gt;% onRender(readLines(&quot;js/tx-annotate.js&quot;)) %&gt;% onRender(readLines(&quot;js/tx-inset-plot.js&quot;)) Click to show the ‚Äòjs/tx-inset-plot.js‚Äô file function(el) { el.on(&quot;plotly_hover&quot;, function(d) { var pt = d.points[0]; var city = pt.customdata[0]; // get the sales for the clicked city var cityInfo = pt.data.customdata.filter(function(cd) { return cd ? cd[0] == city : false; }); var sales = cityInfo.map(function(cd) { return cd[1] }); // Collect all the trace types in this plot var types = el.data.map(function(trace) { return trace.type; }); // Find the array index of the histogram trace var histogramIndex = types.indexOf(&quot;histogram&quot;); // If the histogram trace already exists, just supply new x values if (histogramIndex &gt; -1) { Plotly.restyle(el.id, &quot;x&quot;, [sales], histogramIndex); } else { // create the histogram var trace = { x: sales, type: &quot;histogram&quot;, marker: {color: &quot;#1f77b4&quot;}, xaxis: &quot;x2&quot;, yaxis: &quot;y2&quot; }; Plotly.addTraces(el.id, trace); // place it on &quot;inset&quot; axes var x = { domain: [0.05, 0.4], anchor: &quot;y2&quot; }; var y = { domain: [0.6, 0.9], anchor: &quot;x2&quot; }; Plotly.relayout(el.id, {xaxis2: x, yaxis2: y}); } // Add a title for the histogram var ann = { text: &quot;Monthly house sales in &quot; + city + &quot;, TX&quot;, x: 2003, y: 300000, xanchor: &quot;middle&quot;, showarrow: false }; Plotly.relayout(el.id, {annotations: [ann]}); // Add a vertical line reflecting sales for the hovered point var line = { type: &quot;line&quot;, x0: pt.customdata[1], x1: pt.customdata[1], y0: 0.6, y1: 0.9, xref: &quot;x2&quot;, yref: &quot;paper&quot;, line: {color: &quot;black&quot;} }; Plotly.relayout(el.id, {&#39;shapes[1]&#39;: line}); }); } FIGURE 26.7: Adding another event handler to Figure 26.5 to draw an inset plot showing the distribution of monthly house sales. As long as your not allowing down-stream users to input paths to the input files (e.g., in a shiny app), you shouldn‚Äôt need to worry about the security of this example‚Ü© "],
["client-side.html", "27 Leveraging web technologies from R", " 27 Leveraging web technologies from R Sometimes supplying customdata isn‚Äôt the best way to acheive a particular interactive feature. In those cases, you likely want to leverage other R interfaces to client-side technologies. Recall from section 14.1 that htmlwidgets objects are a special case of htmltools tags. That means, you can always complement your widget(s) with arbitrary HTML content by adding additional tags. Figure 27.1 leverages this idea to place an empty HTML &lt;div&gt; container below the correlation heatmap which is then populated with a plotly scatterplot upon clicking a cell. As it turns out, you could implement Figure 27.1 by binding x/y data to each heatmap cell via customdata, but that would require the browser to store twice the amount of data as what‚Äôs required here. Instead, this approach seralizes the input data (mtcars) into a JSON file via jsonlite so the webpage can read and parse the full dataset once and select just the two required columns when required (on click). There are a lot of ways to read JSON in JavaScript, but here we use the d3.js library‚Äôs d3.json() since plotly already comes bundled with the library (Heer 2011). Also, since the HTML file is reading the JSON from disk, most browsers won‚Äôt render the HTML file directly (at least, by default, for security reasons). To get around that, we can start up a simple web server from R using servr to serve both the HTML and JSON in way that your browser will deem safe to run (Xie 2016b). library(plotly) library(htmltools) nms &lt;- names(mtcars) p &lt;- plot_ly(d, colors = &quot;RdBu&quot;) %&gt;% add_heatmap( x = nms, y = nms, z = ~round(cor(mtcars), 3) ) %&gt;% onRender(&quot; function(el) { Plotly.d3.json(&#39;mtcars.json&#39;, function(mtcars) { el.on(&#39;plotly_click&#39;, function(d) { var x = d.points[0].x; var y = d.points[0].y; var trace = { x: mtcars[x], y: mtcars[y], mode: &#39;markers&#39; }; Plotly.newPlot(&#39;filtered-plot&#39;, [trace]); }); }); } &quot;) # In a temporary directory, save the mtcars dataset as json and # the html to an index.html file, then open via a web server withr::with_path(tempdir(), { jsonlite::write_json(as.list(mtcars), &quot;mtcars.json&quot;) html &lt;- tagList(p, tags$div(id = &#39;filtered-plot&#39;)) save_html(html, &quot;index.html&quot;) if (interactive()) servr::httd() }) FIGURE 27.1: Clicking on a correlation matrix to populate a scatterplot. All the JavaScript we‚Äôve seen thus far is natively supported by modern web browsers, but for larger projects, you may want to leverage modern versions of JS (e.g, ES6) and modern JS development tools for compiling said JS to code that all browsers can support (e.g. Babel, Webpack, etc). The current landscape of JS development tooling is large, complex, fragmented, difficult for non-experts to navigate, and mostly beyond the scope of this book. Thankfully, popular JS libraries often provide a ‚Äòstandalone‚Äô JS bundle which allows direct use their library without having to install and learn a bunch of new technology. Moreover, these bundles are likely available through a CDN service like https://unpkg.com/, https://www.cloudflare.com/cdn, etc. The R package runpkg makes it easy to download files from https://unpkg.com/ and include them in web pages generated through the htmltools package (Sievert 2019b). It does this by returning a htmltools::htmlDependency() object which encapsulates the downloaded files and includes the JS scripts (or CSS stylesheets) into any page that depends on that object. Here we use it to download a standalone bundle of a popular React library for rendering all sort of different video formats, called react-player. React is hugely popular JavaScript framework that makes it easy to bundle and re-use components, so this same general idea could be reused to leverage other components.35 library(runpkg) react_player &lt;- download_files(&quot;react-player&quot;, &quot;dist/ReactPlayer.standalone.js&quot;) This react-player library provides a function called renderReactPlayer() that requires a placeholder (i.e., a DOM element) for inserting the video as well as a url (or file path) to the video. library(htmltools) # the video placeholder video &lt;- tags$div(id = &quot;video&quot;) # upon clicking the marker, populate a video # in the DOM element with an id of &#39;video&#39; p &lt;- plot_ly(x = 1, y = 1, size = I(50)) %&gt;% add_text( text = &quot;ü§£&quot;, customdata = &quot;https://www.youtube.com/watch?v=oHg5SJYRHA0&quot;, hovertext = &quot;Click me!&quot;, hoverinfo = &quot;text&quot; ) %&gt;% onRender( &quot;function(gd) { var container = document.getElementById(&#39;video&#39;); gd.on(&#39;plotly_click&#39;, function(d) { var url = d.points[0].customdata; renderReactPlayer(container, {url: url, playing: true}); }) }&quot; ) # create the HTML page browsable(tagList(p, video, react_player)) FIGURE 27.2: Populating a video in response to a 'plotly_click' event. If you‚Äôre not lucky enough to be working with a JS library that provides a standalone library and/or if you want to leverage some of the features of modern JS (e.g., namespacing, tree-shaking, async+await, etc), then you may have to dive into node.js (i.e., server-side JavaScript) command-line tools like npm, yarn, and webpack. As it turns out, though, R packages like V8 and reactR are making it easier to leverage server-side JavaScript from R with minimal fuss. The V8 package provides a low-level interface to a JS runtime that allows you run server-side JavaScript from R (Ooms 2017). V8 provides a foundation for packages like reactR to provide functions like babel_transform() which compile modern JS (e.g., ES6, ES2017, etc) code to a version of JavaScript that all browsers support (e.g., ES5) (Inc, Russell, and Dipert 2019). For a simple example, Figure 27.3 demonstrates how one could leverage ES6, React, and JSX syntax to populate a &lt;h1&gt; title filled with a customdata message in response to a 'plotly_click' event. library(reactR) # a message placeholder msg &lt;- tags$div(id = &quot;msg&quot;) p &lt;- plot_ly(x = 1, y = 1) %&gt;% add_markers(customdata = &quot;Powered by React&quot;) %&gt;% onRender(babel_transform( &quot;gd =&gt; { gd.on(&#39;plotly_click&#39;, d =&gt; { let msg = d.points[0].customdata; ReactDOM.render( &lt;h1&gt;{msg}&lt;/h1&gt;, document.getElementById(&#39;msg&#39;) ); }); }&quot; ), validate = TRUE) # create the HTML page browsable(tagList( p, msg, html_dependency_corejs(), html_dependency_react() )) FIGURE 27.3: Using babel_transform() to leverage ES6, React, and JSX. References "],
["is-plotly-free-secure.html", "28 Is plotly free &amp; secure?", " 28 Is plotly free &amp; secure? Yes! Both the R package and the underlying JavaScript library (plotly.js) are MIT licensed. That means you are free to distribute and commericalize anything you create with plotly. Optionally, you can sign up for a https://plot.ly account and use the api_create() function to upload plotly graphs to your account, but a https://plot.ly account is not required to use plotly. Moreover, the data behind a plotly graph won‚Äôt leave the computer you‚Äôre viewing it on, unless: You sign up for a plotly cloud account and use the api_create() function to upload your graph or data. This service is free for public-facing graphs, but private hosting costs money. You add the ‚Äòsend data to cloud‚Äô modebar button. By default, this button is not included, but you can add it by doing config(p, cloud = TRUE). In other words, unless you specifically request otherwise, your graph runs entirely offline (i.e. no requests to external services are made). That means you can be confident that your data is not being shared with anyone/anything without your knowledge. "],
["controlling-tooltips.html", "29 Controlling tooltips 29.1 plot_ly() tooltips 29.2 ggplotly() tooltips 29.3 Styling", " 29 Controlling tooltips 29.1 plot_ly() tooltips There are two main approaches to controlling the tooltip: hoverinfo and hovertemplate. I suggest starting with the former approach since it‚Äôs simpler, more mature, and enjoys universal support across trace types. On the other hand, hovertemplate does offer a convenient approach for flexible control over tooltip text, so it can be useful as well. The hoverinfo attribute controls what other plot attributes are shown into the tooltip text. The default value of hoverinfo is x+y+text+name (you can verify this with schema()), meaning that plotly.js will use the relevant values of x, y, text, and name to populate the tooltip text. As in Figure 29.1 shows, you can supply custom text (without the other ‚Äòcalculated values‚Äô) by supplying a character string text and setting hoverinfo = \"text\". The character string can include Glyphs, unicode characters, a some (white-listed) HTML entities and tags.36 At least currently, plotly.js doesn‚Äôt support rendering of LaTeX or images in the tooltip, but as demonstrated in Figure 26.3, if you know some HTML/JavaScript, you can always build your own custom tooltip. library(tibble) library(forcats) tooltip_data &lt;- tibble( x = &quot; &quot;, y = 1, categories = as_factor(c(&quot;Glyphs&quot;, &quot;HTML tags&quot;, &quot;Unicode&quot;, &quot;HTML entities&quot;, &quot;A combination&quot;)), text = c( &quot;üëã glyphs ‡≤†_‡≤†&quot;, &quot;Hello &lt;span style=&#39;color:red&#39;&gt;&lt;sup&gt;1&lt;/sup&gt;‚ÅÑ&lt;sub&gt;2&lt;/sub&gt;&lt;/span&gt; fraction&quot;, &quot;\\U0001f44b unicode \\U00AE \\U00B6 \\U00BF&quot;, &quot;&amp;mu; &amp;plusmn; &amp;amp; &amp;lt; &amp;gt; &amp;nbsp; &amp;times; &amp;plusmn; &amp;deg;&quot;, paste(&quot;&lt;b&gt;Wow&lt;/b&gt; &lt;i&gt;much&lt;/i&gt; options&quot;, emo::ji(&quot;dog2&quot;), &quot;(‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ‚îª‚îª&quot;) ) ) plot_ly(tooltip_data, hoverinfo = &quot;text&quot;) %&gt;% add_bars( x = ~x, y = ~y, color = ~fct_rev(categories), text = ~text ) %&gt;% layout( barmode =&quot;stack&quot;, hovermode = &quot;x&quot; ) FIGURE 29.1: Customizing the tooltip by supplying glyphs, Unicode, HTML markup to the text attributes and restricting displayed attributes with hoverinfo='text'. Whenever a fill is relevant (e.g., add_sf(), add_polygons(), add_ribbons(), etc), you have the option of using the hoveron attribute to generate a tooltip for the supplied data points, the filled polygon that those points define, or both. As Figure 29.2 demonstrates, if you want a tooltip attached to a fill, you probably want text to be of length 1 for a given trace. On the other hand, if you want to each point along a fill to have a tooltip, you probably want text to have numerous strings. p &lt;- plot_ly( x = c(1, 2, 3), y = c(1, 2, 1), fill = &quot;toself&quot;, mode = &quot;markers+lines&quot;, hoverinfo = &quot;text&quot; ) subplot( add_trace(p, text = &quot;triangle&quot;, hoveron = &quot;fills&quot;), add_trace(p, text = paste0(&quot;point&quot;, 1:3), hoveron = &quot;points&quot;) ) FIGURE 29.2: Using the hoveron attribute to control whether a tooltip is attached to fill or each point along that fill. You can‚Äôt supply custom text in this way to a statistical aggregation, but there are ways to control the formatting of values computed and displayed by plotly.js (e.g. x, y, and z). If the value that you‚Äôd like to format corresponds to an axis, you can use *axis.hoverformat. The syntax behind hoverformat follows d3js‚Äô format conventions. For numbers, see: https://github.com/d3/d3-format/blob/master/README.md#locale_format and for dates see: https://github.com/d3/d3-time-format/blob/master/README.md#locale_format set.seed(1000) plot_ly(x = rnorm(100), name = &quot; &quot;) %&gt;% add_boxplot(hoverinfo = &quot;x&quot;) %&gt;% layout(xaxis = list(hoverformat = &quot;.2f&quot;)) FIGURE 29.3: Using xaxis.hoverformat to round aggregated values displayed in the tooltip to two decimal places. Computed values that don‚Äôt have a corresponding axis likely have a *hoverformat trace attribute. Probably the most common example is the z attribute in a heatmap or histogram2d chart. Figure 29.4 shows how to format z values to have one decimal. plot_ly(z = ~volcano) %&gt;% add_heatmap(zhoverformat = &quot;.1f&quot;) %&gt;% layout(xaxis = list(hoverformat = &quot;.2f&quot;)) FIGURE 29.4: Formatting the displayed z values in a heatmap using zhoverformat. It‚Äôs admittedly difficult to remember where to specify these hoverformat attributes, so if you want a combination of custom text and formatting of computed values you can use hovertemplate, which overrides hoverinfo and allows you to fully specify the tooltip in one consistent location. For a full description of this attribute, see https://plot.ly/r/reference/#scatter-hovertemplate. set.seed(10) plot_ly(x = rnorm(100, 0, 1e5)) %&gt;% add_histogram( histnorm = &quot;density&quot;, hovertemplate = &quot;The height is %{y:.1e} &lt;extra&gt;That&#39;s very small!&lt;/extra&gt;&quot; ) FIGURE 29.5: Using the hovertemplate attribute to reference computed variables and their display format inside a custom string. If you need really specific control over the tooltip, you might consider hiding the tooltip altogether (using hoverinfo='none') and defining your own tooltip. Defining your own tooltip, however, will require knowledge of HTML and JavaScript ‚Äì see Figure 26.3 for an example of how to display an image on hover instead of a tooltip. 29.2 ggplotly() tooltips Similar to how you can use the text attribute to supply a custom string in plot_ly() (see Section 29.1), you can supply a text aesthetic to your ggplot2 graph, as shown in 29.6: p &lt;- ggplot(mtcars, aes(wt, mpg, text = row.names(mtcars))) + geom_point() ggplotly(p) FIGURE 29.6: Using the text ggplot2 aesthetic to supply custom tooltip text to By default, ggplotly() will display all relevant aesthetic mappings (or computed values), but you can restrict what aesthetics are used to populate the tooltip, as shown in Figure 29.7: ggplotly(p, tooltip = &quot;text&quot;) FIGURE 29.7: Using the tooltip arugment in ggplotly() to only display the text aesthetic. When constructing the text to display, ggplotly() runs format() on the computed values. Since some parameters of the format() function can be controlled through global options(), you can use these options() to control the displayed text. This includes the digits option for controlling the number of significant digits used for numerical values as well as scipen for setting a penalty for deciding whether scientific or fixed notation is used for displaying. Figure 29.8 shows how you can temporarily set these options (i.e., avoid altering of your global environment) using the withr package (Hester et al. 2018). library(withr) p &lt;- ggplot(faithfuld, aes(waiting, eruptions)) + geom_raster(aes(fill = density)) subplot( with_options(list(digits = 1), ggplotly(p)), with_options(list(digits = 6, scipen = 20), ggplotly(p)) ) FIGURE 29.8: Leveraging global R options for controlling the displayed values in a ggplotly() tooltip. These global options are nice for specifying significant/scientific notation, but what about more sophisicated formatting? Sometimes a clever use of the text aesthetic provides a sufficient workaround. Specifically, as Figure 29.9 shows, if one wanted to control a displayed aesthetic value (e.g., y), one could generate a custom string from that variable and supply it to text, then essentially replace text for y in the tooltip: library(scales) p &lt;- ggplot(txhousing, aes(date, median)) + geom_line(aes(group = city, text = paste(&quot;median:&quot;, number_si(median)))) ggplotly(p, tooltip = c(&quot;text&quot;, &quot;x&quot;, &quot;city&quot;)) FIGURE 29.9: Using the text aesthetic to replace an auto-generated aesthetic (y). The approach depicted in Figure 29.9 works for computed values that pertain to raw data values, but what about sophisicated formatting of a summary statistics generated by ggplot2? In this case, you‚Äôll have to use the return value of ggplotly() which, remember, is a plotly object that conforms to the plotly.js spec. That means you can identify trace attribute(s) that contain relevant info (note: the plotly_json() function is incredibly for helping to find that information), then use that info to populate a text attribute. Figure 29.10 applies this technique to customize the text that appears when hovering over a geom_smooth() line. # Add a smooth to the previous figure and convert to plotly w &lt;- ggplotly(p + geom_smooth(se = FALSE)) # This plotly object has two traces: one for # the raw time series and one for the smooth. # Try using `plotly_json(w)` to confirm the 2nd # trace is the smooth line. length(w$x$data) # use the `y` attribute of the smooth line # to generate a custom string (to appear in tooltip) text_y &lt;- number_si( w$x$data[[2]]$y, prefix = &quot;Typical median house price: $&quot; ) # suppress the tooltip on the raw time series # and supply custom text to the smooth line w %&gt;% style(hoverinfo = &quot;skip&quot;, traces = 1) %&gt;% style(text = text_y, traces = 2) FIGURE 29.10: Using the return value of ggplotly() to populate a custom text attribute. 29.3 Styling There is currently one main attribute for controlling the style of a tooltip: hoverlabel. With this attribute you can currently set the background color (bgcolor), border color (bordercolor), and font family/size/color. Figure 29.11 demonstrates how to use it with plot_ly() (basically any chart type you use should support it): font &lt;- list( family = &quot;Roboto Condensed&quot;, size = 15, color = &quot;white&quot; ) label &lt;- list( bgcolor = &quot;#232F34&quot;, bordercolor = &quot;transparent&quot;, font = font ) plot_ly(x = iris$Petal.Length, hoverlabel = label) FIGURE 29.11: Using the hoverlabel attribute to customize the color and font of the tooltip. On the other hand, when using ggplotly(), you have to modfy the hoverlabel attribute via style() as shown in Figure 29.12 qplot(x = Petal.Length, data = iris) %&gt;% ggplotly() %&gt;% style(hoverlabel = label, marker.color = &quot;#232F34&quot;) %&gt;% layout(font = font) FIGURE 29.12: Using the hoverlabel attribute with ggplotly(). As shown in sections 29.1 and 29.2 the approach to customized the actual text of a tooltip is slightly different depending on whether you‚Äôre using ggplotly() or plot_ly(), but styling the appearance of the tooltip is more or less the same in either approach. References "],
["control-the-modebar.html", "30 Control the modebar 30.1 Remove the entire modebar 30.2 Remove the plotly logo 30.3 Remove modebar buttons by name 30.4 Add custom modebar buttons 30.5 Control image downloads", " 30 Control the modebar By default, the modebar appears in the top right-hand side of a plotly graph on mouse hover, and can lead to poor user-experience on small displays. Fortunately, the modebar can be completely customized via the config() function. The config() function can be helpful for a lot of things: language support (Section 34), enabling mathjax (Section 35), suppressing tip dialogs (e.g., showTips), when to scroll on zoom, etc. However, this topic is all about options related to the modebar. To see a complete list of config() options, as well as their description, see the config section of the plotly.js schema(). 30.1 Remove the entire modebar The displayModeBar option makes it quick and easy to remove the entire modebar. plot_ly() %&gt;% config(displayModeBar = FALSE) 30.2 Remove the plotly logo The displaylogo option makes it quick and easy to remove the entire modebar. plot_ly() %&gt;% config(displaylogo = FALSE) FIGURE 30.1: Removing the plotly logo from the modebar. 30.3 Remove modebar buttons by name Any modebar buttons can be removed by name via modeBarButtonsToRemove. The current list of modebar buttons can be found at https://github.com/plotly/plotly.js/blob/master/src/components/modebar/buttons.js plot_ly() %&gt;% config(modeBarButtonsToRemove = c(&quot;zoomIn2d&quot;, &quot;zoomOut2d&quot;)) FIGURE 30.2: Removing the ‚ÄòzoomIn2d‚Äô and ‚ÄòzoomOut2d‚Äô modebar buttons by name. 30.4 Add custom modebar buttons It is possible to supply your own modebar button icon that triggers a custom JavaScript function when clicked. You must provide a name for the icon and either a SVG path (with just the d attribute) or a full SVG element (to svg). Nowadays, there are a number of free websites that allow you to search icons and download their corresponding SVG information. When supplying path, as in Figure 30.3, you can also define an SVG transform to help size and position the icon. To define a JavaScript function to call upon clicking the icon, you can provide a string to htmlwidgets::JS(). The interactive version of Figure 30.3 adds on-graph text everytime the octocat icon is clicked. To learn more about how to leverage JavaScript from R, see Section 23. octocat &lt;- list( name = &quot;octocat&quot;, icon = list( path = &quot;M24.92 12.183c0-1.586-.604-2.864-1.585-3.83.172-.547.398-1.763-.229-3.321 0 0-1.114-.348-3.628 1.315a12.695 12.695 0 0 0-3.081-.366c-1.154 0-2.322.143-3.409.44-2.596-1.747-3.74-1.391-3.74-1.391-.748 1.847-.287 3.215-.145 3.554-.883.936-1.414 2.133-1.414 3.594 0 1.111.128 2.099.44 2.964l.325.732c.879 1.614 2.606 2.655 5.677 2.983-.434.289-.885.779-1.062 1.612-.594.28-2.475.966-3.603-.944 0 0-.633-1.148-1.842-1.235 0 0-1.174-.017-.08.722 0 0 .782.367 1.326 1.738 0 0 .705 2.342 4.114 1.593v2.417s-.076.857-.867 1.143c0 0-.469.312.034.497 0 0 2.205.174 2.205-1.604v-2.643s-.09-1.047.429-1.404v4.332s-.032 1.031-.576 1.421c0 0-.362.646.433.468 0 0 1.517-.211 1.584-1.967l.035-4.383h.363l.033 4.383c.076 1.748 1.59 1.967 1.59 1.967.793.179.429-.468.429-.468-.54-.389-.579-1.421-.579-1.421v-4.297c.52.402.436 1.369.436 1.369v2.643c0 1.777 2.2 1.604 2.2 1.604.505-.186.036-.498.036-.498-.793-.286-.867-1.143-.867-1.143v-3.461c0-1.346-.574-2.056-1.137-2.435 3.277-.318 4.845-1.368 5.572-2.99-.015.027.26-.726.26-.726.25-.859.325-1.855.325-2.963h-.002z&quot;, transform = &#39;matrix(1 0 0 1 -2 -2) scale(0.7)&#39; ), click = htmlwidgets::JS( &quot;function(gd) { var txt = {x: [1], y: [1], text: &#39;Octocat!&#39;, mode: &#39;text&#39;}; Plotly.addTraces(gd, txt); }&quot; ) ) plot_ly() %&gt;% config(modeBarButtonsToAdd = list(octocat)) FIGURE 30.3: Supplying a custom modebar button with custom behavior. Note that you can also use modeBarButtons to completely specify which buttons to include in the modebar. With this option, you can supply existing button names and/or your own custom buttons: plot_ly() %&gt;% config(modeBarButtons = list(list(&quot;zoomIn2d&quot;), list(octocat))) FIGURE 30.4: Specifying the full list of modebar buttons. 30.5 Control image downloads By default, the toImage modebar button downloads a png file using the current size and state of the graph. With toImageButtonOptions, one can specify different sizes and filetypes, which is particularly useful for obtaining a static pdf/webp/jpeg/etc image of the plot after components have been directly manipulated, as leveraged in Figure 13.1. Here‚Äôs a basic example of configuring the 'toImage' button to download an svg file that‚Äôs 200 x 100 pixels: plot_ly() %&gt;% config( toImageButtonOptions = list( format = &quot;svg&quot;, width = 200, height = 100 ) ) After downloading the svg file, you can convert it to pdf using the rsvg_pdf() function from the rsvg package (Ooms 2018). References "],
["working-with-colors.html", "31 Working with colors", " 31 Working with colors The JavaScript library underlying plotly (plotly.js) has it‚Äôs own support for specifying colors, which is different from how R specifies colors. It currently supports: hex (e.g. \"#FF0000\") rgb (e.g. \"rgb(255, 0, 0)\") rgba (e.g. \"rgba(255, 0, 0, 1)\") hsl (e.g. 'hsl(0, 100%, 50%)') hsv (e.g. 'hsv(0, 100%, 50%)') Named CSS3 colors http://www.w3.org/TR/css3-color/#svg-color If you use plot_ly() and directly specify a plotly.js color attribute (e.g. marker.color), you can use any of these formats. Figure 31.1 uses the the hsl format: plot_ly(x = iris$Petal.Length, marker = list(color = &quot;hsl(0, 100%, 50%)&quot;)) FIGURE 31.1: Specifying a color in plotly.js‚Äô supported format If you‚Äôre doing something specific to R, like using ggplotly() and/or the top-level color/stroke argument in plot_ly(), you‚Äôll need to be careful to about specifying colors in way that R and plotly can understand. For example, at least currently, you can‚Äôt specify an hsl string in this way: plot_ly(x = 1, y = 1, color = I(&quot;hsl(0, 100%, 50%)&quot;)) #&gt; Error in grDevices::col2rgb(x, alpha = TRUE): invalid color name &#39;hsl(0, 100%, 50%)&#39; Just like in ggplot2, you‚Äôll have to specify a color in one of the following ways: A hexadecimal string of the form ‚Äú#rrggbb‚Äù or ‚Äú#rrggbbaa‚Äù. Named colors (e.g. ‚Äúblue‚Äù). All supported names are listed in colors(). An NA for transparent. This doesn‚Äôt imply that you can‚Äôt work in other colorspaces though (e.g. rgb, rgba, hsl, or hsl). The colorspace package provides a nice way to create colors in any of these colorspaces and provides a hex() function that you can use to convert any color to a hexidecimal format (Ihaka et al. 2019). library(colorspace) red &lt;- hex(HLS(0, 0.5, 1)) plot_ly(x = iris$Petal.Length, color = I(red)) If you‚Äôd like to learn more about how to use the color argument as well as specify different types of color palettes, see Section 4. References "],
["working-with-symbols.html", "32 Working with symbols and glyphs", " 32 Working with symbols and glyphs The JavaScript library underlying plotly (plotly.js) has it‚Äôs own special support for specifying marker symbols by name. As Figure 32.1 shows, there are currently many acceptable marker.symbol values, and all the acceptable values can be accessed through plotly.js‚Äô schema(). s &lt;- schema() vals &lt;- grep(&quot;-&quot;, s$traces$scatter$attributes$marker$symbol$values, value = T) plot_ly() %&gt;% add_markers( x = rep(1:12, each = 11, length.out = length(vals)), y = rep(1:11, times = 12, length.out = length(vals)), text = vals, hoverinfo = &quot;text&quot;, marker = list( symbol = vals, size = 30, line = list( color = &quot;black&quot;, width = 2 ) ) ) FIGURE 32.1: All marker symbols currently supported by plotly. In addition to these marker symbols, you can also use add_text() to encode data with on-graph text. Moreover, the add_text() function (i.e. a scatter trace with mode=\"markers\") enjoys a lot of the same properties as add_markers() (i.e. a scatter trace with mode=\"text\"). As Figure 32.2 shows, similar to how we can supply typographical glyphs and/or unicode in a custom tooltip, you can supply a character vector of similar content to add_text() (i.e. a scatter trace with mode='text') which renders on-graph text. Furthermore, when using text to render on-graph text, one can leverage the hovertext attribute to display some different text on hover. plot_ly() %&gt;% add_text( x = rep(2, 2), y = 1:2, size = I(15), text = c( &quot;Glyphs: —≤, Ôºà‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØ ‚îª‚îÅ‚îª&quot;, &quot;Unicode: \\U00AE \\U00B6 \\U00BF&quot; ), hovertext = c( &quot;glyphs&quot;, &quot;unicode&quot; ), textposition = &quot;left center&quot;, hoverinfo = &quot;text&quot; ) FIGURE 32.2: Using add_text() to render on-graph text with typographical glyphs and/or unicode. Having the ability to encode data with unicode means that we have a virtually endless number of ways to encode data in symbols/glyphs. Just for fun, Figure 32.3 demonstrates how you could plot all the activity emojis using the emo package and display the name of the emoji on hover (Wickham, Fran√ßois, and D‚ÄôAgostino McGowan 2018). library(emo) set.seed(100) jis %&gt;% filter(group == &quot;Activities&quot;) %&gt;% plot_ly(x = runif(nrow(.)), y = runif(nrow(.))) %&gt;% add_text( text = ~emoji, hovertext = ~name, hoverinfo = &quot;text&quot;, size = I(20) ) FIGURE 32.3: Using add_text() to plot all the activity emojis and leveraging hovertext to place the emoji names in the tooltip text. References "],
["control-the-layout.html", "33 Control the layout 33.1 Axis titles 33.2 Axis labels 33.3 Margins 33.4 Fonts", " 33 Control the layout 33.1 Axis titles 33.2 Axis labels using factors to control ordering of axis labels specifying your own tickvals/ticktext? discuss pros and cons 33.3 Margins 33.4 Fonts "],
["locales.html", "34 Language support", " 34 Language support The locale argument of the config() function allows one to render on-graph text using another language. Figure 34.1 shows how setting locale='ja' will render text in Japanese. today &lt;- Sys.Date() x &lt;- seq.Date(today, today + 360, by = &quot;day&quot;) plot_ly(x = x, y = rnorm(length(x))) %&gt;% add_lines() %&gt;% config(locale = &quot;ja&quot;) FIGURE 34.1: Using the locale argument of the config() function to render on-graph text in another language. Table 34.1 contains a list of all the supported locale codes and the language they correspond to: TABLE 34.1: Language support in plotly. To use one of these languages, supply the locale code to the locale argument in the config() function. "],
["mathjax.html", "35 LaTeX rendering 35.1 MathJax caveats", " 35 LaTeX rendering LaTeX rendering via MathJax is possible via the TeX() function which flags a character vector as LaTeX. To load MathJaX externally (meaning an internet connection is needed for TeX rendering), set the new mathjax argument in config() to \"cdn\". Figure 35.1 demonstrates how to render LaTeX in the plot and axis titles. library(plotly) data(co2, package = &quot;datasets&quot;) plot_ly() %&gt;% add_lines(x = zoo::index(co2), y = co2) %&gt;% layout( title = TeX(&quot;CO_2 \\\\text{measured in } \\\\frac{parts}{million}&quot;), xaxis = list(title = &quot;Time&quot;), yaxis = list(title = TeX(&quot;\\\\text{Atmospheric concentraion of CO}_2&quot;)) ) %&gt;% config(mathjax = &quot;cdn&quot;) FIGURE 35.1: Rendering LaTeX in the plot and axis titles. Figure 35.2 demonstrates how to render LaTeX with on-graph text. There are two ways to draw on-graph text: add_text() which is a scatter trace with a mode of text and add_annotations() which is part of the graph‚Äôs layout. The main difference is that add_text() is able to display tooltips and add_annotations() is able to display arrows. plotly_empty(showlegend = FALSE, hoverinfo = &quot;x+y&quot;) %&gt;% add_annotations(x = 1, y = 2, text = TeX(&quot;\\\\text{The sample mean:} \\\\sum_{i=1}^n x_i \\\\text{ where}&quot;), showarrow = FALSE) %&gt;% add_text(x = 1, y = 1, text = TeX(&quot;x_i \\\\sim N(\\\\mu, \\\\sigma)&quot;), size = I(100)) %&gt;% add_annotations(x = 1, y = 0, text = TeX(&quot;E[x_i]&quot;)) %&gt;% add_text(x = 1, y = 0, text = TeX(&quot;\\\\mu&quot;), textposition = &quot;bottom&quot;) %&gt;% config(mathjax = &quot;cdn&quot;) FIGURE 35.2: Rendering LaTeX using add_text() and add_annotations(). To use a local version of MathJax (so that your graphs will render without an internet connection), you need to inform plotly where it‚Äôs located. If you don‚Äôt already have MathJax locally, I recommend downloading the official MathJax git repo. Here‚Äôs how to do that using terminal commands: $ git clone https://github.com/mathjax/MathJax.git $ cd MathJax Now set the PLOTLY_MATHJAX_PATH environment variable so that plotly knows where that MathJax folder lives. I recommend setting this variable in you .Rprofile so you don‚Äôt have to reset it everytime you restart R: $ export PLOTLY_MATHJAX_PATH=`pwd` $ echo &quot;Sys.setenv(&#39;PLOTLY_MATHJAX_PATH&#39; = &#39;$PLOTLY_MATHJAX_PATH&#39;)&quot; &gt;&gt; ~/.Rprofile Finally, once PLOTLY_MATHJAX_PATH is set, specify mathjax=\"local\" in config(): config(last_plot(), mathjax=&quot;local&quot;) 35.1 MathJax caveats MathJax rendering in tooltips currently isn‚Äôt supported. At least currently, plotly.js requires SVG-based rendering which doesn‚Äôt play nicely with HTML-based rendering (e.g. rmarkdown documents and shiny apps) . If you need both the SVG and HTML rendering, consider &lt;iframe&gt;-ing your plotly graph(s) into the larger document (see here for an example). Due to the size and nature of MathJax, using htmlwidget::saveWidget() with selfcontained = TRUE won‚Äôt work. At least for now, when you need to save a plotly graph (p) with local MathJax, do htmlwidget::saveWidget(p, selfcontained = FALSE) "],
["the-data-plot-pipeline.html", "36 The data-plot-pipeline", " 36 The data-plot-pipeline As Chapter 3.1 first introduced, we can express multi-layer plotly graphs as a sequence (or, more specifically, a directed acyclic graph) of dplyr data manipulations and mappings to visuals. For example, to create Figure 36.1, we could group txhousing by city to ensure the first layer of add_lines() draws a different line for each city, then filter() down to Houston so that the second call to add_lines() draws only Houston. allCities &lt;- txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;) allCities %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(name = &quot;Houston&quot;) FIGURE 36.1: Monthly median house prices over time for 46 Texan cities (in blue). Houston is highlighted in orange. Sometimes the directed acyclic graph property of a magrittr pipeline can be too restrictive for certain types of plots. In this example, after filtering the data down to Houston, there is no way to recover the original data inside the pipeline. The add_fun() function helps to work-around this restriction37 ‚Äì it works by applying a function to the plotly object, but does not affect the data associated with the plotly object. This effectively provides a way to isolate data transformations within the pipeline38. Figure 36.2 uses this idea to highlight both Houston and San Antonio. allCities %&gt;% add_fun(function(plot) { plot %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(name = &quot;Houston&quot;) }) %&gt;% add_fun(function(plot) { plot %&gt;% filter(city == &quot;San Antonio&quot;) %&gt;% add_lines(name = &quot;San Antonio&quot;) }) FIGURE 36.2: Monthly median house price in Houston and San Antonio in comparison to other Texan cities. It is useful to think of the function supplied to add_fun() as a ‚Äúlayer‚Äù function ‚Äì a function that accepts a plot object as input, possibly applies a transformation to the data, and maps that data to visual objects. To make layering functions more modular, flexible, and expressive, the add_fun() allows you to pass additional arguments to a layer function. Figure 36.3 makes use of this pattern, by creating a reusable function for layering both a particular city as well as the first, second, and third quartile of median monthly house sales (by city). # reusable function for highlighting a particular city layer_city &lt;- function(plot, name) { plot %&gt;% filter(city == name) %&gt;% add_lines(name = name) } # reusable function for plotting overall median &amp; IQR layer_iqr &lt;- function(plot) { plot %&gt;% group_by(date) %&gt;% summarise( q1 = quantile(median, 0.25, na.rm = TRUE), m = median(median, na.rm = TRUE), q3 = quantile(median, 0.75, na.rm = TRUE) ) %&gt;% add_lines(y = ~m, name = &quot;median&quot;, color = I(&quot;black&quot;)) %&gt;% add_ribbons(ymin = ~q1, ymax = ~q3, name = &quot;IQR&quot;, color = I(&quot;black&quot;)) } allCities %&gt;% add_fun(layer_iqr) %&gt;% add_fun(layer_city, &quot;Houston&quot;) %&gt;% add_fun(layer_city, &quot;San Antonio&quot;) FIGURE 36.3: First, second, and third quartile of median monthly house price in Texas. A layering function does not have to be a data-plot-pipeline itself. Its only requirement on a layering function is that the first argument is a plot object and it returns a plot object. This provides an opportunity to say, fit a model to the plot data, extract the model components you desire, and map those components to visuals. Furthermore, since plotly‚Äôs add_*() functions don‚Äôt require a data.frame, you can supply those components directly to attributes (as long as they are well-defined), as done in Figure 36.4 via the forecast package (Hyndman, n.d.). library(forecast) layer_forecast &lt;- function(plot) { d &lt;- plotly_data(plot) series &lt;- with(d, ts(median, frequency = 12, start = c(2000, 1), end = c(2015, 7)) ) fore &lt;- forecast(ets(series), h = 48, level = c(80, 95)) plot %&gt;% add_ribbons(x = time(fore$mean), ymin = fore$lower[, 2], ymax = fore$upper[, 2], color = I(&quot;gray95&quot;), name = &quot;95% confidence&quot;, inherit = FALSE) %&gt;% add_ribbons(x = time(fore$mean), ymin = fore$lower[, 1], ymax = fore$upper[, 1], color = I(&quot;gray80&quot;), name = &quot;80% confidence&quot;, inherit = FALSE) %&gt;% add_lines(x = time(fore$mean), y = fore$mean, color = I(&quot;blue&quot;), name = &quot;prediction&quot;) } txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;) %&gt;% add_fun(layer_iqr) %&gt;% add_fun(layer_forecast) FIGURE 36.4: Layering on a 4-year forecast from a exponential smoothing state space model. In summary, the ‚Äúdata-plot-pipeline‚Äù is desirable for a number of reasons: (1) makes your code easier to read and understand, (2) encourages you to think of both your data and plots using a single, uniform data structure, which (3) makes it easy to combine and reuse transformations. References "],
["modifying-ggplotly.html", "37 Modifying ggplotly() results 37.1 Modifying layout 37.2 Modifying data 37.3 Leveraging statistical output", " 37 Modifying ggplotly() results 37.1 Modifying layout Since the ggplotly() function returns a plotly object, we can manipulate that object in the same way that we would manipulate any other plotly object. A simple and useful application of this is to specify interaction modes, like plotly.js‚Äô layout.dragmode for specifying the mode of click+drag events. Figure 37.1 demonstrates how the default for this attribute can be modified via the layout() function. library(forecast) data(gold, package = &quot;forecast&quot;) p &lt;- ggplot(fortify(gold), aes(x, y)) + geom_line() gg &lt;- ggplotly(p) layout(gg, dragmode = &quot;pan&quot;) FIGURE 37.1: Customizing the dragmode of an interactive ggplot2 graph. Perhaps a more useful application is to add a range slider to the x-axis, which allows you to zoom on the x-axis without losing the global context. This is quite useful for quickly altering the limits of your plot to achieve an optimal aspect ratio for your data without losing the global perspective (William S. Cleveland 1988). Figure 37.2 uses the rangeslider() function to add a rangeslider to the plot. rangeslider(gg) FIGURE 37.2: Adding a rangeslider to an interactive ggplot2 graph. Since a single plotly object can only have one layout, modifying the layout of ggplotly() is fairly easy, but it‚Äôs trickier to modify the data underlying the graph. 37.2 Modifying data As mentioned previously, ggplotly() translates each ggplot2 layer into one or more plotly.js traces. In this translation, it is forced to make a number of assumptions about trace attribute values that may or may not be appropriate for the use case. To demonstrate, consider Figure 37.3, which shows hover information for the points, the fitted line, and the confidence band. How could we make it so hover information is only displayed for the points? p &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point() + geom_smooth() ggplotly(p) FIGURE 37.3: A scatterplot with a fitted line and confidence band. The ggplot2 package doesn‚Äôt provide an API for interactive features, but by changing the hoverinfo attribute to \"none\", we can turn off hover for the relevant traces. This sort of task (i.e. modifying trace attribute values) is best achieved through the style() function. Before using it, you may want to study the underlying traces with plotly_json() which uses the listviewer package to display a convenient interactive view of the JSON object sent to plotly.js (de Jong and Russell 2016). By clicking on the arrow next to the data element, you can see the traces (data) behind the plot. As shown in Figure 37.4, we have three traces: one for the geom_point() layer and two for the geom_smooth() layer. plotly_json(p) FIGURE 37.4: Using listviewer to inspect the JSON representation of a plotly object. This output indicates that the fitted line and confidence band are implemented in the 2nd and 3rd trace of the plotly object, so to turn off the hover of those traces: style(p, hoverinfo = &quot;none&quot;, traces = 2:3) FIGURE 37.5: Using the style() function to modify hoverinfo attribute values of a plotly object created via ggplotly() (by default, ggplotly() displays hoverinfo for all traces). In this case, the hoverinfo for a fitted line and error bounds are hidden. 37.3 Leveraging statistical output Since ggplotly() returns a plotly object, and plotly objects can have data attached to them, it attaches data from ggplot2 layer(s) (either before or after summary statistics have been applied). Furthermore, since each ggplot layer owns a data frame, it is useful to have some way to specify the particular layer of data of interest, which is done via the layerData argument in ggplotly(). Also, when a particular layer applies a summary statistic (e.g., geom_bin()), or applies a statistical model (e.g., geom_smooth()) to the data, it might be useful to access the output of that transformation, which is the point of the originalData argument in ggplotly(). p &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point() + geom_smooth() p %&gt;% ggplotly(layerData = 2, originalData = FALSE) %&gt;% plotly_data() #&gt; # A tibble: 80 x 13 #&gt; PANEL x y ymin ymax se group colour fill size linetype #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1.51 32.1 28.1 36.0 1.92 -1 #3366‚Ä¶ grey‚Ä¶ 1 1 #&gt; 2 1 1.56 31.7 28.2 35.2 1.72 -1 #3366‚Ä¶ grey‚Ä¶ 1 1 #&gt; 3 1 1.61 31.3 28.1 34.5 1.54 -1 #3366‚Ä¶ grey‚Ä¶ 1 1 #&gt; 4 1 1.66 30.9 28.0 33.7 1.39 -1 #3366‚Ä¶ grey‚Ä¶ 1 1 #&gt; 5 1 1.71 30.5 27.9 33.0 1.26 -1 #3366‚Ä¶ grey‚Ä¶ 1 1 #&gt; 6 1 1.76 30.0 27.7 32.4 1.16 -1 #3366‚Ä¶ grey‚Ä¶ 1 1 #&gt; # ‚Ä¶ with 74 more rows, and 2 more variables: weight &lt;dbl&gt;, alpha &lt;dbl&gt; The data shown above is the data ggplot2 uses to actually draw the fitted values (as a line) and standard error bounds (as a ribbon). Figure 37.6 leverages this data to add additional information about the model fit; in particular, it adds a vertical lines and annotations at the x-values that are associated with the highest and lowest amount uncertainty in the fitted values. Producing a plot like this with ggplot2 would be impossible using geom_smooth() alone.39 Providing a simple visual clue like this can help combat visual misperceptions of uncertainty bands due to the sine illusion (VanderPlas and Hofmann 2015). p %&gt;% ggplotly(layerData = 2, originalData = FALSE) %&gt;% add_fun(function(p) { p %&gt;% slice(which.max(se)) %&gt;% add_segments(x = ~x, xend = ~x, y = ~ymin, yend = ~ymax) %&gt;% add_annotations(&quot;Maximum uncertainty&quot;, ax = 60) }) %&gt;% add_fun(function(p) { p %&gt;% slice(which.min(se)) %&gt;% add_segments(x = ~x, xend = ~x, y = ~ymin, yend = ~ymax) %&gt;% add_annotations(&quot;Minimum uncertainty&quot;) }) FIGURE 37.6: Leveraging data associated with a geom_smooth() layer to display additional information about the model fit. In addition to leveraging output from StatSmooth, it is sometimes useful to leverage output of other statistics, especially for annotation purposes. Figure 37.7 leverages the output of StatBin to add annotations to a stacked bar chart. Annotation is primarily helpful for displaying the heights of bars in a stacked bar chart, since decoding the heights of bars is a fairly difficult perceptual task (Cleveland and McGill 1984). As result, it is much easier to compare bar heights representing the proportion of diamonds with a given clarity across various diamond cuts. p &lt;- ggplot(diamonds, aes(cut, fill = clarity)) + geom_bar(position = &quot;fill&quot;) ggplotly(p, originalData = FALSE) %&gt;% mutate(ydiff = ymax - ymin) %&gt;% add_text( x = ~x, y = ~(ymin + ymax) / 2, text = ~ifelse(ydiff &gt; 0.02, round(ydiff, 2), &quot;&quot;), showlegend = FALSE, hoverinfo = &quot;none&quot;, color = I(&quot;black&quot;), size = I(9) ) FIGURE 37.7: Leveraging output from StatBin to add annotations to a stacked bar chart (created via geom_bar()) which makes it easier to compare bar heights. Another useful application is labelling the levels of each piece/polygon output by StatDensity2d as shown in Figure 37.8. Note that, in this example, the add_text() layer takes advantage of ggplotly()‚Äôs ability to inherit aesthetics from the global mapping. Furthermore, since originalData is FALSE, it attaches the ‚Äúbuilt‚Äù aesthetics (i.e., the x/y positions after StatDensity2d has been applied to the raw data). p &lt;- ggplot(MASS::geyser, aes(x = waiting, y = duration)) + geom_density2d() ggplotly(p, originalData = FALSE) %&gt;% group_by(piece) %&gt;% slice(which.min(y)) %&gt;% add_text( text = ~level, size = I(9), color = I(&quot;black&quot;), hoverinfo = &quot;none&quot; ) FIGURE 37.8: Leveraging output from StatDensity2d to add annotations to contour levels. References "],
["embedding-images.html", "38 Embedding images", " 38 Embedding images There are a few ways to embed images in a plotly graph. Perhaps the easiest is to point the image source to a hyperlink containing a bitmap file (e.g., png, jpeg, tiff, etc). plot_ly() %&gt;% layout( images = list( source = &quot;https://www.rstudio.com/wp-content/uploads/2018/10/RStudio-Logo-Flat.png&quot;, x = 0, y = 1, sizex = 0.2, sizey = 0.1, xref = &quot;paper&quot;, yref = &quot;paper&quot;, xanchor = &quot;left&quot;, yanchor = &quot;bottom&quot; ), margin = list(t = 50) ) FIGURE 38.1: Embedding an image using a hyperlink. This example uses paper coordinates (i.e., normalized 0-1 scale relative to the graph area) to place the image just above the graph. The approach in Figure 38.1 has a downside though ‚Äì if that hyperlink breaks, then so does your plot. It‚Äôd be better to download the file to your machine and use the dataURI() function from the base64enc package (or similar) to embed the image as a data URI (Urbanek 2015). plot_ly() %&gt;% layout( images = list( source = base64enc::dataURI(file = &quot;images/rstudio.png&quot;), x = 0, y = 1, sizex = 0.2, sizey = 0.1, xref = &quot;paper&quot;, yref = &quot;paper&quot;, xanchor = &quot;left&quot;, yanchor = &quot;bottom&quot; ), margin = list(t = 50) ) FIGURE 38.2: Embedding an image using a data URI. This approach ensures your image stays embedded in the plot. Another approach is to convert a raster object into a data URI, which the raster2uri() function in plotly is designed to do. R actually ships with native support for raster objects and many image processing R packages either build on this data structure or provide a utility to convert to a raster object (perhaps via as.raster()). For example, the readPNG() function from the png package reads image data in an R array, which can be converted to a raster object (Urbanek 2013). pen &lt;- png::readPNG(&quot;images/penguin.png&quot;) plot_ly() %&gt;% layout( images = list( source = raster2uri(as.raster(pen)), x = 2, y = 2, sizex = 2, sizey = 1, xref = &quot;x&quot;, yref = &quot;y&quot;, xanchor = &quot;left&quot;, yanchor = &quot;bottom&quot;, sizing = &quot;stretch&quot; ) ) FIGURE 38.3: Reading a png image into R with png::readPNG(), converting the RBGA array into a raster object, generating a data URI of the raster via raster2uri(), then embedding the URI as an image in a plotly graph. Moreover, thanks to the R package magick it‚Äôs possible to rasterize non-raster file formats (e.g., pdf, svg, etc) directly in R, so if you wanted, you could also embed non-bitmap images by using image_read() and image_convert() to generate a raster object (Ooms 2019). R developers that have authored a custom ggplot2 geom and want to inform ggplotly() about the rendering rules of their geom. R developers that want to build a similar interface to another JavaScript graphing library. References "],
["custom-geoms.html", "39 Translating custom ggplot2 geoms", " 39 Translating custom ggplot2 geoms Version 2.0.0 of ggplot2 introduced a way for other R packages to implement custom geoms. Some great examples include: ggrepel, ggalt, ggraph, geomnet, ggmosaic and ggtern (Rudis 2016); (Pedersen 2016); (Tyner and Hofmann 2016); (Jeppson, Hofmann, and Cook 2016); (Hamilton 2016).40 Although the ggplotly() function translates most of the geoms bundled with the ggplot2 package, it has no way of knowing about the rendering rules for custom geoms. The plotly package does, however, provide 2 generic functions based on the S3 scheme that can leveraged to inform ggplotly() about these rules (Chambers 1992).41 To date, the ggmosaic and ggalt packages have taken advantage of this infrastructure to provide translations of their custom geoms to plotly. In ggplot2, many geoms are special cases of other geoms. For example, geom_line() is equivalent to geom_path() once the data is sorted by the x variable. For cases like this, when a geom can be reduced to another lower-level (i.e., basic) geom, authors just have to write a method for the to_basic() generic function in plotly. In fact, within the package itself, the to_basic() function has a GeomLine method which simply sorts the data by the x variable then returns it with a class of GeomPath prefixed. getS3method(&quot;to_basic&quot;, &quot;GeomLine&quot;) #&gt; function (data, prestats_data, layout, params, p, ...) #&gt; { #&gt; data &lt;- data[order(data[[&quot;x&quot;]]), ] #&gt; prefix_class(data, &quot;GeomPath&quot;) #&gt; } #&gt; &lt;bytecode: 0x7f95fd741590&gt; #&gt; &lt;environment: namespace:plotly&gt; If you have implemented a custom geom, say GeomCustom, rest assured that the data passed to to_basic() will be of class GeomCustom when ggplotly() is called on a plot with your geom. And assuming GeomCustom may be reduced to another lower-level geom support by plotly, a to_basic.GeomCustom() method that transforms the data into a form suitable for that lower-level geom is sufficient for adding support. Moreover, note that the data passed to to_basic() is essentially the last form of the data before the render stage and after statistics have been performed. This makes it trivial to add support for geoms like GeomXspline from the ggalt package. # devtools::install_github(&quot;hrbrmstr/ggalt&quot;) library(ggalt) getS3method(&quot;to_basic&quot;, &quot;GeomXspline&quot;) #&gt; function (data, prestats_data, layout, params, p, ...) #&gt; { #&gt; data &lt;- data[order(data[[&quot;x&quot;]]), ] #&gt; prefix_class(data, &quot;GeomPath&quot;) #&gt; } #&gt; &lt;bytecode: 0x7f9600e881c0&gt; #&gt; &lt;environment: namespace:plotly&gt; As shown in Figure 39.1, once the conversion has been provided. Users can call ggplotly() on the ggplot object containing the custom geom just like any other ggplot object. # example from `help(geom_xspline)` set.seed(1492) dat &lt;- data.frame( x = c(1:10, 1:10, 1:10), y = c(sample(15:30, 10), 2 * sample(15:30, 10), 3 * sample(15:30, 10)), group = factor(c(rep(1, 10), rep(2, 10), rep(3, 10))) ) p &lt;- ggplot(dat, aes(x, y, group = group, color = factor(group))) + geom_point(color = &quot;black&quot;) + geom_smooth(se = FALSE, linetype = &quot;dashed&quot;, size = 0.5) + geom_xspline(spline_shape = 1, size = 0.5) ggplotly(p) %&gt;% hide_legend() FIGURE 39.1: Converting GeomXspline from the ggalt package to plotly.js via ggplotly(). In more complicated cases, where your custom geom can not be converted to a lower level geom, a custom method for the geom2trace() generic is required (methods(geom2trace) lists all the basic geoms that we natively support). This method should involve a conversion from a data frame to a list-like object conforming to the plotly.js figure reference. References "],
["designing-an-htmlwidget-interface.html", "40 Designing an htmlwidget interface", " 40 Designing an htmlwidget interface The plotly.js library, as with many other JavaScript graphing libraries, strives to describe any plot through a plot specification defined via JavaScript Object Notation (JSON). JSON is a language independent data-interchange format that was originally designed for JavaScript, but parsers for many different languages now exist, including R (Temple Lang 2014); (Ooms 2014). JSON is a recursive key-value data structure (similar to a list in R), and essentially any valid JavaScript value has a natural R equivalent (e.g., NULL/null). As a result, any JSON object can be created from an appropriate R list, meaning that theoretically any plotly.js plot can be described via an R list. However, simply providing a bridge between R lists and JSON does not guarantee a powerful or usable interface, especially for a general purpose graphing library. Although it can be complicated to implement, R interfaces to JavaScript graphing libraries should leverage R‚Äôs strong resources for computing on the language to design a more expressive interface (Wickham 2014a). It should also look and feel like (and work well with!) other commonly used interfaces in R. A good way to do this is to embrace (pure and predictable) functional programming. Most importantly, this implies that every function modifies a central type of object ‚Äì meaning that every function input and output the same type of object (predictable). Furthermore, if the output of a function can be determined completely by the input (i.e., pure), it removes any need to search for other code that may be affecting the output. In the case of providing an interface to a JavaScript graphing library, there are a number of reasons why the central object should inherit from the central object provided by the htmlwidgets package. The idea of interfacing R with JavaScript libraries via JSON data transfer has been popular approach for quite some time (Vaidyanathan 2013); (Hocking, VanderPlas, and Sievert 2015); (Sievert and Shirley 2014). The R package htmlwidgets standardized this bridge, and provides some additional infrastructure for making sure the HTML output works as expected in multiple contexts (in the R console or RStudio, within rmarkdown documents, and even embedded inside shiny apps). The htmlwidgets package itself is opinionated about the data structure used to represent the widget in R since it needs to retain meta-information about the widget, such as the sizing policy. To avoid surprise, widget authors should strive to have all functions in their interface modify this data structure.42 JavaScript graphing libraries usually have strong requirements about the JSON structure used to create a plot. In some cases, the R interface needs to know about these requirements in order to faithfully translate R objects to JSON. For example, in plotly.js some attributes must always be an array (e.g. x/y), even if they are length 1, while other attributes cannot be an array must be a literal constant (e.g. name). This leads to a situation where the translation rules from R to JSON cannot be simply ‚Äúbox all vectors of length 1 into an array (or not)‚Äù: list(x = 1, y = 1, name = &quot;A point&quot;) =&gt; {x: [1], y: [1], name: &quot;A point&quot;} Thankfully plotly.js provides a plot schema which declares types for each attribute that plotly leverages internally. If necessary, plotly tries to coerce each attribute to its expected type at print time, and also searches for any unsupported attributes that may have been specified by the user (and throws a warning that the attribute will be ignored). This helps References "],
["references.html", "References", " References "]
]
